{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"oapi","text":"<p><code>oapi</code> is a library for authoring python client libraries for web APIs based on an OpenAPI specification (both OpenAPI/Swagger version 2  and version 3  are supported).</p> <p><code>oapi</code>-generated packages/modules differ from those generated by other tools (including but not limited to swagger-codegen) in that <code>oapi</code> generates a data model which enforces the schemas defined in the OpenAPI specification. This means that request and response objects, and their properties/items/members, cannot comprise data types which differ from those specified in their OpenAPI document. Additionally, request and response objects can be validated using <code>sob.validate</code> to verify that they were not parsed from an object having attributes not defined in the element's JSON schema, and have all required attributes. <code>oapi</code> fully supports polymorphism when a schema has an \"anyOf\", \"allOf\", or \"oneOf\" attribute (although <code>oapi</code> does not require a discriminator  to be defined).</p> <p>Notable features of an <code>oapi</code> generated client/model library include:</p> <ul> <li><code>oapi</code> generated data models and clients are fully type-annotated</li> <li><code>oapi</code> generated data models and clients adhere to PEP-8 formatting</li> <li><code>oapi</code> generated data models and clients include docstrings for all models,   model properties, client methods, and client method parameters, inferred   from \"description\" and \"summary\" attributes of elements within the   specification</li> <li><code>oapi</code> generated clients will handle the most common server-to-server   authentication methods out-of-box, including the OAuth2 authorization   code flow (client_id/client_secret), API keys, bearer tokens, HTTP basic   auth, and most cookie-based authentication patterns. Custom authentication   methods are also easily accomplished by specifying custom base classes   and/or passing initialization decorators to <code>oapi.write_client_module</code>.</li> <li><code>oapi</code> generated clients and models are easily updated. For instance: <code>oapi</code>   generated data model classes can be renamed using your favorite IDE's   refactoring tools, and subsequent updates to that data model (such as   to reflect minor-version updates to the spec which add endpoints, schemas,   parameters, etc.) will retain your new class names, so long as the   schema from which the class was generated remains in the same location   within the spec. Class naming can also be customized by passing a custom   hook to the get_class_name_from_pointer parameter for   <code>oapi.write_model_module</code>.</li> </ul>"},{"location":"contributing/","title":"Contributing to oapi","text":"<p>Please note that you must have hatch installed prior to performing the following steps.</p>"},{"location":"contributing/#for-enorganic-contributors-and-code-owners","title":"For Enorganic Contributors and Code Owners","text":"<ol> <li> <p>Clone and Install</p> <p>To install this project for development of this library, clone this repository (replacing \"~/Code\", below, with the directory under which you want your project to reside), then run <code>make</code>:</p> <pre><code>cd ~/Code &amp;&amp; \\\ngit clone\\\nhttps://github.com/enorganic/oapi.git oapi &amp;&amp; \\\ncd oapi &amp;&amp; \\\nmake\n</code></pre> </li> <li> <p>Create a new branch for your changes (replacing \"descriptive-branch-name\"     with a descriptive branch name, and replacing feature with bugfix     if the branch addresses a bug):</p> <pre><code>git branch feature/descriptive-branch-name\n</code></pre> </li> <li> <p>Make some changes.</p> </li> <li> <p>Format and lint your code:</p> <pre><code>make format\n</code></pre> </li> <li> <p>Test your changes:</p> <pre><code>make test\n</code></pre> </li> <li> <p>Push your changes and create a pull request.</p> </li> </ol>"},{"location":"contributing/#for-everyone-else","title":"For Everyone Else","text":"<p>If you are not a contributor on this project, you can still create pull requests, however you will need to fork this project, push changes to your fork, and create a pull request from your forked repository.</p>"},{"location":"template/","title":"template","text":"<p>A cookiecutter template is provided to kickstart authoring of your <code>oapi</code> client/SDK:</p> <ul> <li> <p>Install hatch</p> </li> <li> <p>Install cookiecutter</p> </li> <li> <p>Execute the following command (replacing \"~/Code\" with the path under     which you want to create your new project):</p> <pre><code>cd ~/Code &amp;&amp; \\\ncookiecutter \"https://github.com/enorganic/oapi.git\" --directory=\"template\"\n</code></pre> </li> <li> <p>Follow the prompts to enter template fields. For example:</p> <pre><code>$ cookiecutter \"https://github.com/enorganic/oapi.git\" --directory=\"template\"\nYou've downloaded /Users/nonsense/.cookiecutters/oapi/template before. Is it okay to delete and re-download it? [y/n] (y): y\n[1/9]  project_name - The name of your project (example: namespace-application-sdk) (): my-test-sdk\n[2/9] package - The module path of your base package, including namespacing, if applicable (example: enterprise_name.application_client) (oapi_test_client): \n[3/9] package_directory - The relative file path to your base package (example: src/enterprise_name/application_client) (src/oapi_test_client): \n[4/9] author_email (): info@nonsense.org\n[5/9] repository_url (): https://github.com/your-organization/my-test-sdk\n[6/9] documentation_url (): https://your-organization.github.io/my-test-sdk\n[7/9] openapi_document_url - The URL from which an OpenAPI document for this client can be obtained (example: https://raw.githubusercontent.com/cloudflare/api-schemas/refs/heads/main/openapi.json) (): https://raw.githubusercontent.com/cloudflare/api-schemas/refs/heads/main/openapi.json\n[8/9] openapi_git_repository_url - The URL of the Git repository containing the Open API document (example: https://github.com/cloudflare/api-schemas.git) (): \n[9/9] openapi_git_repository_document_path - The relative path to the OpenAPI document in the repository (example: openapi.json) ():\n</code></pre> <p>The resulting directory/file structure created by the above example input looks as follows:</p> <pre><code>$ tree -a -I '.git|.mypy_cache|.ruff_cache' my-test-sdk \nmy-test-sdk\n\u251c\u2500\u2500 .editorconfig\n\u251c\u2500\u2500 .github\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 workflows\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 distribute.yml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 test.yml\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 docs\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 api\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 oapi_test_client.client.md\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 oapi_test_client.model.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 assets\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u251c\u2500\u2500 javascripts\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 extra.js\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0 \u2514\u2500\u2500 stylesheets\n\u2502\u00a0\u00a0 \u2502\u00a0\u00a0     \u2514\u2500\u2500 style.css\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CNAME\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 contributing.md\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.md\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 mkdocs.yaml\n\u251c\u2500\u2500 openapi\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 fixed.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 original.yaml\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 scripts\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 remodel.py\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 oapi_test_client\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 client.py\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 model.py\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 conftest.py\n    \u2514\u2500\u2500 test_integration.py\n</code></pre> </li> <li> <p>Once you've created your new project, you will want to start by     editing <code>scripts/remodel.py</code> (read the inline comments for instruction).     Once you've edited this as needed, run     <code>cd my-test-sdk &amp;&amp; make remodel</code> to generate     your model and client modules.</p> </li> <li> <p>Edit <code>tests/conftest.py</code> such that <code>get_client</code> returns a client     connecting to a suitable instance of the API against which to perform     integration tests.</p> </li> <li> <p>Author your integration tests in <code>tests/test_integration.py</code>     (read inline comments for instruction).</p> </li> <li> <p>Run <code>make test</code> to execute your tests. When/if validation errors are     raised for API responses, edit the <code>fix_openapi</code> function in     <code>scripts/remodel.py</code> to fix the OpenAPI document such that it correctly     represents the data returned. For perfect Open API documents, this     step will not be necessary, but candidly I've found precious few perfect     Open API documents in the wild :-).</p> </li> <li> <p>You will first need to create your repository on Github:     <code>https://github.com/organizations/your-organization/repositories/new</code>     (replace \"your-organization\" with your organization, of course)</p> </li> <li> <p>Initialize and configure your repository locally. For the project created     in our preceding examples, those commands would be:</p> <pre><code>git init &amp;&amp; \\\ngit add . &amp;&amp; \\\ngit stage . &amp;&amp; \\\ngit commit -m \"First Commit\" &amp;&amp; \\\ngit remote add origin \"https://github.com/your-organization/my-test-sdk.git\"\n</code></pre> </li> </ul>"},{"location":"api/oapi.client/","title":"oapi.client","text":""},{"location":"api/oapi.client/#oapi.client","title":"oapi.client","text":""},{"location":"api/oapi.client/#oapi.client.SSLContext","title":"SSLContext","text":"<pre><code>SSLContext(check_hostname: bool = True)\n</code></pre> <p>               Bases: <code>ssl.SSLContext</code></p> <p>This class is a wrapper for <code>ssl.SSLContext</code> which makes it possible to connect to hosts which have an unverified SSL certificate.</p> Source code in <code>src/oapi/client.py</code> <pre><code>def __init__(\n    self,\n    check_hostname: bool = True,  # noqa: FBT001 FBT002\n) -&gt; None:\n    if check_hostname:\n        self.load_default_certs()\n    else:\n        self.check_hostname: bool = False\n        self.verify_mode: ssl.VerifyMode = ssl.CERT_NONE\n    super().__init__()\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.SSLContext.__reduce__","title":"__reduce__","text":"<pre><code>__reduce__() -&gt; tuple\n</code></pre> <p>A pickled instance of this class will just be an entirely new instance.</p> Source code in <code>src/oapi/client.py</code> <pre><code>def __reduce__(self) -&gt; tuple:\n    \"\"\"\n    A pickled instance of this class will just be an entirely new\n    instance.\n    \"\"\"\n    return SSLContext, (self.check_hostname,)\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.Client","title":"Client","text":"<pre><code>Client(\n    url: str | None = None,\n    *,\n    user: str | None = None,\n    password: str | None = None,\n    bearer_token: str | None = None,\n    api_key: str | None = None,\n    api_key_in: typing.Literal[\n        \"header\", \"query\", \"cookie\"\n    ] = \"header\",\n    api_key_name: str = \"X-API-KEY\",\n    oauth2_client_id: str | None = None,\n    oauth2_client_secret: str | None = None,\n    oauth2_username: str | None = None,\n    oauth2_password: str | None = None,\n    oauth2_authorization_url: str | None = None,\n    oauth2_token_url: str | None = None,\n    oauth2_scope: str | tuple[str, ...] | None = None,\n    oauth2_refresh_url: str | None = None,\n    oauth2_flows: (\n        tuple[\n            typing.Literal[\n                \"authorizationCode\",\n                \"implicit\",\n                \"password\",\n                \"clientCredentials\",\n                \"accessCode\",\n                \"application\",\n            ],\n            ...,\n        ]\n        | None\n    ) = None,\n    open_id_connect_url: str = \".well-known/openid-configuration\",\n    headers: (\n        collections.abc.Mapping[str, str]\n        | collections.abc.Sequence[tuple[str, str]]\n    ) = (\n        (\"Accept\", \"application/json\"),\n        (\"Content-type\", \"application/json\"),\n    ),\n    timeout: int = 0,\n    retry_number_of_attempts: int = 1,\n    retry_for_errors: tuple[\n        type[Exception], ...\n    ] = oapi.client.DEFAULT_RETRY_FOR_ERRORS,\n    retry_hook: typing.Callable[\n        [Exception], bool\n    ] = oapi.client.default_retry_hook,\n    verify_ssl_certificate: bool = True,\n    logger: logging.Logger | None = None,\n    echo: bool = False\n)\n</code></pre> <p>A base class for OpenAPI clients.</p> <p>Parameters:</p> <ul> <li> <code>url</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The base URL for API requests.</p> </li> <li> <code>user</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A user name for use with HTTP basic authentication.</p> </li> <li> <code>password</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A password for use with HTTP basic authentication.</p> </li> <li> <code>bearer_token</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A token for use with HTTP bearer authentication.</p> </li> <li> <code>api_key</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An API key with which to authenticate requests.</p> </li> <li> <code>api_key_in</code>               (<code>typing.Literal['header', 'query', 'cookie']</code>, default:                   <code>'header'</code> )           \u2013            <p>Where the API key should be conveyed: \"header\", \"query\" or \"cookie\".</p> </li> <li> <code>api_key_name</code>               (<code>str</code>, default:                   <code>'X-API-KEY'</code> )           \u2013            <p>The name of the header, query parameter, or cookie parameter in which to convey the API key.</p> </li> <li> <code>oauth2_client_id</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An OAuth2 client ID.</p> </li> <li> <code>oauth2_client_secret</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An OAuth2 client secret.</p> </li> <li> <code>oauth2_username</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A username for the \"password\" OAuth2 grant type.</p> </li> <li> <code>oauth2_password</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A password for the \"password\" OAuth2 grant type.</p> </li> <li> <code>oauth2_authorization_url</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The authorization URL to use for an OAuth2 flow. Can be relative to <code>url</code>.</p> </li> <li> <code>oauth2_token_url</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The token URL to use for OAuth2 authentication. Can be relative to <code>url</code>.</p> </li> <li> <code>oauth2_scope</code>               (<code>str | tuple[str, ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>One or more OAuth2 scopes</p> </li> <li> <code>oauth2_refresh_url</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The URL to be used for obtaining refresh tokens for OAuth2 authentication.</p> </li> <li> <code>oauth2_flows</code>               (<code>tuple[typing.Literal['authorizationCode', 'implicit', 'password', 'clientCredentials', 'accessCode', 'application'], ...] | None</code>, default:                   <code>None</code> )           \u2013            <p>A tuple containing one or more of the following: \"authorizationCode\", \"implicit\", \"password\" and/or \"clientCredentials\".</p> </li> <li> <code>open_id_connect_url</code>               (<code>str</code>, default:                   <code>'.well-known/openid-configuration'</code> )           \u2013            <p>The URL where an OpenID Provider's configuration  can be obtained.</p> </li> <li> <code>headers</code>               (<code>collections.abc.Mapping[str, str] | collections.abc.Sequence[tuple[str, str]]</code>, default:                   <code>(('Accept', 'application/json'), ('Content-type', 'application/json'))</code> )           \u2013            <p>Default headers to include with all requests. Method-specific header arguments will override or modify these, where applicable, as will dynamically modified headers such as content-length, authorization, cookie, etc.</p> </li> <li> <code>timeout</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The number of seconds before a request will timeout and throw an error. If this is 0 (the default), the system default timeout will be used.</p> </li> <li> <code>retry_number_of_attempts</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of times to retry a request which results in an error.</p> </li> <li> <code>retry_for_errors</code>               (<code>tuple[type[Exception], ...]</code>, default:                   <code>oapi.client.DEFAULT_RETRY_FOR_ERRORS</code> )           \u2013            <p>A tuple of one or more exception types on which to retry a request. To retry for all errors, pass <code>(Exception,)</code> for this argument.</p> </li> <li> <code>retry_hook</code>               (<code>typing.Callable[[Exception], bool]</code>, default:                   <code>oapi.client.default_retry_hook</code> )           \u2013            <p>A function, accepting one argument (an Exception), and returning a boolean value indicating whether to retry the request (if retries have not been exhausted). This hook applies only for exceptions which are a sub-class of an exception included in <code>retry_for_errors</code>.</p> </li> <li> <code>verify_ssl_certificate</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, SSL certificates are verified, per usual. If <code>False</code>, SSL certificates are not verified.</p> </li> <li> <code>logger</code>               (<code>logging.Logger | None</code>, default:                   <code>None</code> )           \u2013            <p>A <code>logging.Logger</code> to which requests should be logged.</p> </li> <li> <code>echo</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, requests/responses are printed as they occur.</p> </li> </ul> Source code in <code>src/oapi/client.py</code> <pre><code>def __init__(\n    self,\n    url: str | None = None,\n    *,\n    user: str | None = None,\n    password: str | None = None,\n    bearer_token: str | None = None,\n    api_key: str | None = None,\n    api_key_in: typing.Literal[\"header\", \"query\", \"cookie\"] = \"header\",\n    api_key_name: str = \"X-API-KEY\",\n    oauth2_client_id: str | None = None,\n    oauth2_client_secret: str | None = None,\n    oauth2_username: str | None = None,\n    oauth2_password: str | None = None,\n    oauth2_authorization_url: str | None = None,\n    oauth2_token_url: str | None = None,\n    oauth2_scope: str | tuple[str, ...] | None = None,\n    oauth2_refresh_url: str | None = None,\n    oauth2_flows: (\n        tuple[\n            typing.Literal[\n                \"authorizationCode\",\n                \"implicit\",\n                \"password\",\n                \"clientCredentials\",\n                # OpenAPI 2.x Compatibility:\n                \"accessCode\",\n                \"application\",\n            ],\n            ...,\n        ]\n        | None\n    ) = None,\n    open_id_connect_url: str = \".well-known/openid-configuration\",\n    headers: (\n        collections.abc.Mapping[str, str]\n        | collections.abc.Sequence[tuple[str, str]]\n    ) = (\n        (\"Accept\", \"application/json\"),\n        (\"Content-type\", \"application/json\"),\n    ),\n    timeout: int = 0,\n    retry_number_of_attempts: int = 1,\n    retry_for_errors: tuple[\n        type[Exception], ...\n    ] = DEFAULT_RETRY_FOR_ERRORS,\n    retry_hook: typing.Callable[  # Force line-break retention\n        [Exception], bool\n    ] = default_retry_hook,\n    verify_ssl_certificate: bool = True,\n    logger: Logger | None = None,\n    echo: bool = False,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        url: The base URL for API requests.\n        user: A user name for use with HTTP basic authentication.\n        password:  A password for use with HTTP basic authentication.\n        bearer_token: A token for use with HTTP bearer authentication.\n        api_key: An API key with which to authenticate requests.\n        api_key_in: Where the API key should be conveyed:\n            \"header\", \"query\" or \"cookie\".\n        api_key_name: The name of the header, query parameter, or\n            cookie parameter in which to convey the API key.\n        oauth2_client_id: An OAuth2 client ID.\n        oauth2_client_secret: An OAuth2 client secret.\n        oauth2_username: A *username* for the \"password\" OAuth2 grant\n            type.\n        oauth2_password: A *password* for the \"password\" OAuth2 grant\n            type.\n        oauth2_authorization_url: The authorization URL to use for an\n            OAuth2 flow. Can be relative to `url`.\n        oauth2_token_url: The token URL to use for OAuth2\n            authentication. Can be relative to `url`.\n        oauth2_scope: One or more\n            [OAuth2 scopes](https://oauth.net/2/scope/)\n        oauth2_refresh_url: The URL to be used for obtaining refresh\n            tokens for OAuth2 authentication.\n        oauth2_flows: A tuple containing one or more of the\n            following: \"authorizationCode\", \"implicit\", \"password\" and/or\n            \"clientCredentials\".\n        open_id_connect_url: The URL where an OpenID\n            Provider's [configuration\n            ](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig)\n            can be obtained.\n        headers: Default headers to include with all requests.\n            Method-specific header arguments will override or modify these,\n            where applicable, as will dynamically modified headers such as\n            content-length, authorization, cookie, etc.\n        timeout: The number of seconds before a request will timeout\n            and throw an error. If this is 0 (the default), the system\n            default timeout will be used.\n        retry_number_of_attempts: The number of times to retry\n            a request which results in an error.\n        retry_for_errors: A tuple of one or more exception types\n            on which to retry a request. To retry for *all* errors,\n            pass `(Exception,)` for this argument.\n        retry_hook: A function, accepting one argument (an Exception),\n            and returning a boolean value indicating whether to retry the\n            request (if retries have not been exhausted). This hook applies\n            *only* for exceptions which are a sub-class of an exception\n            included in `retry_for_errors`.\n        verify_ssl_certificate: If `True`, SSL certificates\n            are verified, per usual. If `False`, SSL certificates are *not*\n            verified.\n        logger:\n            A `logging.Logger` to which requests should be logged.\n        echo: If `True`, requests/responses are printed as\n            they occur.\n    \"\"\"\n    message: str\n    # Ensure the API key location is valid\n    if api_key_in not in (\"header\", \"query\", \"cookie\"):\n        message = (\n            f\"Invalid input for `api_key_in`:  {api_key_in!r}\\n\"\n            'Valid values are \"header\", \"query\" or \"cookie\".'\n        )\n        raise ValueError(message)\n    # Translate OpenAPI 2x OAuth2 flow names\n    if oauth2_flows:\n        flow: str\n        oauth2_flows = tuple(\n            (\n                \"authorizationCode\"\n                if flow == \"accessCode\"\n                else \"clientCredentials\"\n                if flow == \"application\"\n                else flow\n            )\n            for flow in oauth2_flows\n        )\n    # Ensure OAuth2 flows are valid\n    if oauth2_flows and not all(\n        flow\n        in {\n            \"authorizationCode\",\n            \"implicit\",\n            \"password\",\n            \"clientCredentials\",\n        }\n        for flow in oauth2_flows\n    ):\n        message = (\n            f\"Invalid value(s) for `oauth2_flows`:  {api_key_in!r}\\n\"\n            'Valid values are \"authorizationCode\", \"implicit\", '\n            '\"password\", or \"clientCredentials\".'\n        )\n        raise ValueError(message)\n    # Ensure URLs are HTTP/HTTPS (security concern) *or* are relative URLs\n    url_: str | None\n    for url_ in (\n        url,\n        oauth2_authorization_url,\n        oauth2_token_url,\n        oauth2_refresh_url,\n        open_id_connect_url,\n    ):\n        if url_ and (urlparse(url_).scheme not in (\"http\", \"https\", \"\")):\n            raise ValueError(url_)\n    # Set properties\n    self.url: str | None = url\n    self.user: str | None = user\n    self.password: str | None = password\n    self.bearer_token: str | None = bearer_token\n    self.api_key: str | None = api_key\n    self.api_key_in: typing.Literal[\"header\", \"query\", \"cookie\"] = (\n        api_key_in\n    )\n    self.api_key_name: str = api_key_name\n    self.oauth2_client_id: str | None = oauth2_client_id\n    self.oauth2_client_secret: str | None = oauth2_client_secret\n    self.oauth2_username: str | None = oauth2_username\n    self.oauth2_password: str | None = oauth2_password\n    self.oauth2_authorization_url: str | None = oauth2_authorization_url\n    self.oauth2_token_url: str | None = oauth2_token_url\n    self.oauth2_scope: str | tuple[str, ...] | None = oauth2_scope\n    self.oauth2_refresh_url: str | None = oauth2_refresh_url\n    self.oauth2_flows: (\n        typing.Literal[\n            \"authorizationCode\",\n            \"implicit\",\n            \"password\",\n            \"clientCredentials\",\n        ]\n        | None\n    ) = oauth2_flows  # type: ignore\n    self.open_id_connect_url: str | None = open_id_connect_url\n    self.headers: dict[str, str] = dict(headers)\n    self.timeout: int = timeout\n    self.retry_number_of_attempts: int = retry_number_of_attempts\n    self.retry_for_errors: tuple[type[Exception], ...] = retry_for_errors\n    self.retry_hook: typing.Callable[[Exception], bool] = retry_hook\n    self.verify_ssl_certificate: bool = verify_ssl_certificate\n    self.logger: Logger | None = logger\n    self.echo: bool = echo\n    # Support for persisting cookies\n    self._cookie_jar: CookieJar = CookieJar()\n    self.__opener: OpenerDirector | None = None\n    self._oauth2_authorization_expires: int = 0\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.Client.request","title":"request","text":"<pre><code>request(\n    path: str,\n    method: str,\n    *,\n    json: str | bytes | sob.abc.Model | None = None,\n    data: (\n        collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Sequence[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n    ) = (),\n    query: (\n        collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Sequence[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | str\n    ) = (),\n    headers: (\n        collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Sequence[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n    ) = (),\n    multipart: bool = False,\n    multipart_data_headers: (\n        collections.abc.Mapping[\n            str, collections.abc.MutableMapping[str, str]\n        ]\n        | collections.abc.Sequence[\n            tuple[\n                str,\n                collections.abc.MutableMapping[str, str],\n            ]\n        ]\n    ) = (),\n    timeout: int = 0\n) -&gt; sob.abc.Readable\n</code></pre> <p>Construct and submit an HTTP request and return the response (an instance of <code>http.client.HTTPResponse</code>).</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>This is the path of the request, relative to the server base URL</p> </li> <li> <code>query</code>               (<code>collections.abc.Mapping[str, sob.abc.MarshallableTypes] | collections.abc.Sequence[tuple[str, sob.abc.MarshallableTypes]] | str</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>json</code>               (<code>str | bytes | sob.abc.Model | None</code>, default:                   <code>None</code> )           \u2013            <p>JSON data to be conveyed in the body of the request</p> </li> <li> <code>data</code>               (<code>collections.abc.Mapping[str, sob.abc.MarshallableTypes] | collections.abc.Sequence[tuple[str, sob.abc.MarshallableTypes]]</code>, default:                   <code>()</code> )           \u2013            <p>Form data to be conveyed in the body of the request</p> </li> <li> <code>multipart</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If <code>True</code>, <code>data</code> should be conveyed as a multipart request.</p> </li> <li> <code>query</code>               (<code>collections.abc.Mapping[str, sob.abc.MarshallableTypes] | collections.abc.Sequence[tuple[str, sob.abc.MarshallableTypes]] | str</code>, default:                   <code>()</code> )           \u2013            <p>A dictionary from which to assemble the query string.</p> </li> <li> <code>headers</code>               (<code>collections.abc.Mapping[str, sob.abc.MarshallableTypes] | collections.abc.Sequence[tuple[str, sob.abc.MarshallableTypes]]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>multipart_data_headers</code>               (<code>collections.abc.Mapping[str, collections.abc.MutableMapping[str, str]] | collections.abc.Sequence[tuple[str, collections.abc.MutableMapping[str, str]]]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>timeout</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            </li> </ul> Source code in <code>src/oapi/client.py</code> <pre><code>def request(\n    self,\n    path: str,\n    method: str,\n    *,\n    json: str | bytes | sob.abc.Model | None = None,\n    data: (\n        collections.abc.Mapping[str, sob.abc.MarshallableTypes]\n        | collections.abc.Sequence[tuple[str, sob.abc.MarshallableTypes]]\n    ) = (),\n    query: (\n        collections.abc.Mapping[str, sob.abc.MarshallableTypes]\n        | collections.abc.Sequence[tuple[str, sob.abc.MarshallableTypes]]\n        | str\n    ) = (),\n    headers: (\n        collections.abc.Mapping[str, sob.abc.MarshallableTypes]\n        | collections.abc.Sequence[tuple[str, sob.abc.MarshallableTypes]]\n    ) = (),\n    multipart: bool = False,\n    multipart_data_headers: (\n        collections.abc.Mapping[\n            str, collections.abc.MutableMapping[str, str]\n        ]\n        | collections.abc.Sequence[\n            tuple[str, collections.abc.MutableMapping[str, str]]\n        ]\n    ) = (),\n    timeout: int = 0,\n) -&gt; sob.abc.Readable:\n    \"\"\"\n    Construct and submit an HTTP request and return the response\n    (an instance of `http.client.HTTPResponse`).\n\n    Parameters:\n        path: This is the path of the request, relative to the server\n            base URL\n        query:\n        json: JSON data to be conveyed in the body of the request\n        data: Form data to be conveyed\n            in the body of the request\n        multipart: If `True`, `data` should be conveyed\n            as a multipart request.\n        query: A dictionary from which to assemble the\n            query string.\n        headers:\n        multipart_data_headers:\n        timeout:\n    \"\"\"\n    # For backwards compatibility...\n    if isinstance(data, (str, bytes, sob.abc.Model)) or (data is None):\n        json = data\n        data = ()\n    request: typing.Callable[\n        [\n            str,\n            str,\n            str | bytes | sob.abc.Model | None,\n            collections.abc.Mapping[str, sob.abc.MarshallableTypes]\n            | collections.abc.Sequence[\n                tuple[str, sob.abc.MarshallableTypes]\n            ],\n            collections.abc.Mapping[str, sob.abc.MarshallableTypes]\n            | collections.abc.Sequence[\n                tuple[str, sob.abc.MarshallableTypes]\n            ]\n            | str,\n            collections.abc.Mapping[str, sob.abc.MarshallableTypes]\n            | collections.abc.Sequence[\n                tuple[str, sob.abc.MarshallableTypes]\n            ],\n            bool,\n            collections.abc.Mapping[\n                str, collections.abc.MutableMapping[str, str]\n            ]\n            | collections.abc.Sequence[\n                tuple[str, collections.abc.MutableMapping[str, str]]\n            ],\n            int,\n        ],\n        sob.abc.Readable,\n    ] = self._request\n    # Wrap the _request method with a retry decorator if more\n    # than one attempt is specified in the config\n    if self.retry_number_of_attempts &gt; 1:\n        request = retry(\n            errors=self.retry_for_errors,\n            number_of_attempts=self.retry_number_of_attempts,\n            retry_hook=self.retry_hook,\n            logger=self.logger,\n        )(self._request)\n    return request(\n        path,\n        method,\n        json,\n        data,\n        query,\n        headers,\n        multipart,\n        multipart_data_headers,\n        timeout,\n    )\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.ClientModule","title":"ClientModule","text":"<pre><code>ClientModule(\n    open_api: (\n        str | sob.abc.Readable | oapi.oas.model.OpenAPI\n    ),\n    model_path: str | pathlib.Path,\n    *,\n    class_name: str = \"Client\",\n    base_class: type[\n        oapi.client.Client\n    ] = oapi.client.Client,\n    imports: str | tuple[str, ...] = (),\n    init_decorator: str = \"\",\n    include_init_parameters: str | tuple[str, ...] = (),\n    add_init_parameters: str | tuple[str, ...] = (),\n    add_init_parameter_docs: str | tuple[str, ...] = (),\n    init_parameter_defaults: (\n        collections.abc.Mapping[str, typing.Any]\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ) = (),\n    init_parameter_defaults_source: (\n        collections.abc.Mapping[str, typing.Any]\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ) = (),\n    get_method_name_from_path_method_operation: typing.Callable[\n        [str, str, str | None], str\n    ] = oapi.client.get_default_method_name_from_path_method_operation,\n    use_operation_id: bool = False,\n    module_docstring: str | None = None,\n    class_docstring: str | None = None\n)\n</code></pre> <p>This class parses an Open API document and outputs a module defining a client class for interfacing with the API described by an OpenAPI document.</p> <p>Parameters:</p> <ul> <li> <code>open_api</code>               (<code>str | sob.abc.Readable | oapi.oas.model.OpenAPI</code>)           \u2013            <p>An OpenAPI document. This can be a URL, file-path, an HTTP response (<code>http.client.HTTPResponse</code>), a file object, or an instance of <code>oapi.oas.model.OpenAPI</code>.</p> </li> <li> <code>model_path</code>               (<code>str | pathlib.Path</code>)           \u2013            <p>The file path where the data model for this client can be found. This must be a model generated using <code>oapi.model</code>, and must be part of the same project that this client will be saved into.</p> </li> <li> <code>class_name</code>               (<code>str</code>, default:                   <code>'Client'</code> )           \u2013            </li> <li> <code>base_class</code>               (<code>type[oapi.client.Client]</code>, default:                   <code>oapi.client.Client</code> )           \u2013            <p>The base class to use for the client. If provided, this must be a sub-class of <code>oapi.client.Client</code>.</p> </li> <li> <code>imports</code>               (<code>str | tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>One or more import statements to include (in addition to those generated automatically).</p> </li> <li> <code>init_decorator</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A decorator to apply to the client class <code>.__init__</code> method. If used, make sure to include any modules referenced in your <code>imports</code>. For example: \"@decorator_function(argument_a=1, argument_b=2)\".</p> </li> <li> <code>include_init_parameters</code>               (<code>str | tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The name of all parameters to include for the client's <code>.__init__</code> method.</p> </li> <li> <code>add_init_parameters</code>               (<code>str | tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Additional parameter declarations to add to the client's <code>.__init__</code> method. These should include a type hint and default value (not just the parameter name). For example: 'additional_parameter_name: str | None = None'. Note: additional parameters will not do anything without the use of a decorator which utilizes the additional parameters, so use of this parameter should be accompanied by an <code>init_decorator</code>.</p> </li> <li> <code>add_init_parameter_docs</code>               (<code>str | tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>init_parameter_defaults</code>               (<code>collections.abc.Mapping[str, typing.Any] | collections.abc.Sequence[tuple[str, typing.Any]]</code>, default:                   <code>()</code> )           \u2013            <p>A mapping of parameter names to default values for the parameter.</p> </li> <li> <code>init_parameter_defaults_source</code>               (<code>collections.abc.Mapping[str, typing.Any] | collections.abc.Sequence[tuple[str, typing.Any]]</code>, default:                   <code>()</code> )           \u2013            <p>A mapping of parameter names to default values for the parameter expressed as source code. This is to allow for the passing of imported constants, expressions, etc.</p> </li> <li> <code>module_docstring</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A docstring to insert at the top of the module.</p> </li> <li> <code>class_docstring</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A docstring to insert in the client class.</p> </li> </ul> Source code in <code>src/oapi/client.py</code> <pre><code>def __init__(\n    self,\n    open_api: str | sob.abc.Readable | OpenAPI,\n    model_path: str | Path,\n    *,\n    class_name: str = \"Client\",\n    base_class: type[Client] = Client,\n    imports: str | tuple[str, ...] = (),\n    init_decorator: str = \"\",\n    include_init_parameters: str | tuple[str, ...] = (),\n    add_init_parameters: str | tuple[str, ...] = (),\n    add_init_parameter_docs: str | tuple[str, ...] = (),\n    init_parameter_defaults: (\n        collections.abc.Mapping[str, typing.Any]\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ) = (),\n    init_parameter_defaults_source: (\n        collections.abc.Mapping[str, typing.Any]\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ) = (),\n    get_method_name_from_path_method_operation: typing.Callable[\n        [str, str, str | None], str\n    ] = get_default_method_name_from_path_method_operation,\n    use_operation_id: bool = False,\n    module_docstring: str | None = None,\n    class_docstring: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        open_api: An OpenAPI document. This can be a URL, file-path, an\n            HTTP response (`http.client.HTTPResponse`), a file object, or\n            an instance of `oapi.oas.model.OpenAPI`.\n        model_path: The file path where the data model for this\n            client can be found. This must be a model generated using\n            `oapi.model`, and must be part of the same project that this\n            client will be saved into.\n        class_name:\n        base_class: The base class to use for the client. If provided,\n            this must be a sub-class of `oapi.client.Client`.\n        imports: One or more import statements to include\n            (in addition to those generated automatically).\n        init_decorator:  A decorator to apply to the client class\n            `.__init__` method. If used, make sure to include any modules\n            referenced in your `imports`. For example:\n            \"@decorator_function(argument_a=1, argument_b=2)\".\n        include_init_parameters: The name of all parameters to\n            include for the client's `.__init__` method.\n        add_init_parameters: Additional parameter\n            declarations to add to the client's `.__init__` method.\n            These should include a type hint and default value (not just\n            the parameter name). For example:\n            'additional_parameter_name: str | None = None'. Note:\n            additional parameters will not do anything without the use of a\n            decorator which utilizes the additional parameters, so use of\n            this parameter should be accompanied by an `init_decorator`.\n        add_init_parameter_docs:\n        init_parameter_defaults: A mapping of\n            parameter names to default values for the parameter.\n        init_parameter_defaults_source: A mapping of\n            parameter names to default values for the parameter *expressed\n            as source code*. This is to allow for the passing of imported\n            constants, expressions, etc.\n        module_docstring: A docstring to insert at the top of the module.\n        class_docstring: A docstring to insert in the client class.\n    \"\"\"\n    message: str\n    if isinstance(model_path, Path):\n        model_path = str(model_path)\n    # Ensure a valid model path has been provided\n    if not os.path.exists(model_path):\n        raise ValueError(model_path)\n    # Get an OpenAPI document\n    if isinstance(open_api, str):\n        if os.path.exists(open_api):\n            open_api = _get_path_open_api(open_api)\n        else:\n            open_api = _get_url_open_api(open_api)\n    elif isinstance(open_api, sob.abc.Readable):\n        open_api = _get_io_open_api(open_api)\n    elif not isinstance(open_api, OpenAPI):\n        message = (\n            f\"`{sob.utilities.get_calling_function_qualified_name()}` \"\n            \"requires an instance of `str`, \"\n            f\"`{sob.utilities.get_qualified_name(OpenAPI)}`, or a \"\n            \"file-like object for the `open_api` parameter--not \"\n            f\"{open_api!r}\"\n        )\n        raise TypeError(message)\n    # Ensure all elements have URLs and JSON pointers\n    sob.set_model_url(open_api, sob.get_model_url(open_api))\n    sob.set_model_pointer(open_api, sob.get_model_pointer(open_api) or \"\")\n    self.open_api: OpenAPI = open_api\n    init_decorator = init_decorator.strip()\n    if init_decorator and not init_decorator.startswith(\"@\"):\n        raise ValueError(init_decorator)\n    self._init_decorator: str = init_decorator.strip()\n    self._include_init_parameters: tuple[str, ...] = (\n        (include_init_parameters,)\n        if isinstance(include_init_parameters, str)\n        else include_init_parameters\n    )\n    self._add_init_parameters: tuple[str, ...] = (\n        (add_init_parameters,)\n        if isinstance(add_init_parameters, str)\n        else add_init_parameters\n    )\n    self._add_init_parameter_docs: tuple[str, ...] = (\n        (add_init_parameter_docs,)\n        if isinstance(add_init_parameter_docs, str)\n        else add_init_parameter_docs\n    )\n    self._init_parameter_defaults: dict[str, typing.Any] = dict(\n        init_parameter_defaults\n    )\n    self._init_parameter_defaults_source: dict[str, typing.Any] = dict(\n        init_parameter_defaults_source\n    )\n    self._resolver: Resolver = Resolver(open_api)\n    self._model_path: str = model_path\n    self._base_class: type[Client] = base_class\n    self._class_name: str = class_name\n    # This keeps track of used names in the global namespace\n    self._names: set[str] = {\n        \"sob\",\n        \"oapi\",\n        \"typing\",\n        \"Logger\",\n        self._class_name,\n    }\n    self._imports: set[str] = {\n        \"from __future__ import annotations\",\n        \"import typing\",\n        \"import oapi\",\n        \"import sob\",\n        \"from logging import Logger\",\n    } | set(\n        filter(None, (imports,) if isinstance(imports, str) else imports)\n    )\n    if \"headers\" not in self._iter_excluded_parameter_names():\n        # `collections.abc` is only referenced if `headers` is used\n        self._imports.add(\"import collections.abc\")\n        self._names.add(\"collections\")\n    self.get_method_name_from_path_method_operation = (\n        get_method_name_from_path_method_operation\n    )\n    self.use_operation_id = use_operation_id\n    self.module_docstring: str | None = module_docstring\n    self.class_docstring: str | None = class_docstring\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.ClientModule.get_source","title":"get_source","text":"<pre><code>get_source(path: str | pathlib.Path) -&gt; str\n</code></pre> <p>This generates source code for the client module.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | pathlib.Path</code>)           \u2013            <p>The file path for the client module. This is needed in order to determine the relative import for the model module.</p> </li> </ul> Source code in <code>src/oapi/client.py</code> <pre><code>def get_source(self, path: str | Path) -&gt; str:\n    \"\"\"\n    This generates source code for the client module.\n\n    Parameters:\n        path: The file path for the client module. This is needed\n            in order to determine the relative import for the model module.\n    \"\"\"\n    source: str = \"\\n\".join(\n        chain(\n            self._iter_class_declaration_source(),\n            (\n                (\n                    '    \"\"\"',\n                    sob.utilities.split_long_docstring_lines(\n                        sob.utilities.indent(\n                            self.class_docstring.strip(), start=0\n                        )\n                    ),\n                    '    \"\"\"',\n                )\n                if self.class_docstring\n                else ()\n            ),\n            self._iter_init_method_source(),\n            self._iter_paths_operations_methods_source(),\n            (\"\",),\n        )\n    )\n    # The model module import couldn't be generated until we\n    # knew the client module path, so we add it now\n    self._imports |= {\n        self._get_model_module_import(path),\n        self._get_client_base_class_import(path),\n    }\n    # Imports need to be generated last\n    imports: str = \"\\n\".join(self._iter_imports())\n    docstring: str = (\n        f'\"\"\"\\n{self.module_docstring}\\n\"\"\"\\n\\n'\n        if self.module_docstring\n        else \"\"\n    )\n    return sob.utilities.suffix_long_lines(\n        f\"{docstring}{imports}\\n\\n\\n{source.rstrip()}\\n\"\n    )\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.ClientModule.save","title":"save","text":"<pre><code>save(path: str | pathlib.Path) -&gt; None\n</code></pre> <p>This method will save the generated module to a given path.</p> Source code in <code>src/oapi/client.py</code> <pre><code>def save(self, path: str | Path) -&gt; None:\n    \"\"\"\n    This method will save the generated module to a given path.\n    \"\"\"\n    client_source: str = self.get_source(path=path)\n    # Save the module\n    with open(path, \"w\") as client_io:\n        client_io.write(client_source)\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.urlencode","title":"urlencode","text":"<pre><code>urlencode(\n    query: (\n        collections.abc.Mapping[str, typing.Any]\n        | sob.abc.Dictionary\n        | sob.abc.Object\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ),\n    doseq: bool = True,\n    safe: str = oapi.client.URLENCODE_SAFE,\n    encoding: str = \"utf-8\",\n    errors: str = \"\",\n    quote_via: typing.Callable[\n        [str, bytes | str, str, str], str\n    ] = urllib.parse.quote,\n) -&gt; str\n</code></pre> <p>This function wraps <code>urllib.parse.urlencode</code>, but has different default argument values. Additionally, when a mapping/dictionary is passed for a query value, that dictionary/mapping performs an update to the query dictionary.</p> <p>Parameters:</p> <ul> <li> <code>query</code>               (<code>collections.abc.Mapping[str, typing.Any] | sob.abc.Dictionary | sob.abc.Object | collections.abc.Sequence[tuple[str, typing.Any]]</code>)           \u2013            </li> <li> <code>doseq</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>safe</code>               (<code>str</code>, default:                   <code>oapi.client.URLENCODE_SAFE</code> )           \u2013            </li> <li> <code>encoding</code>               (<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            </li> <li> <code>errors</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            </li> <li> <code>quote_via</code>               (<code>typing.Callable[[str, bytes | str, str, str], str]</code>, default:                   <code>urllib.parse.quote</code> )           \u2013            </li> </ul> Source code in <code>src/oapi/client.py</code> <pre><code>def urlencode(\n    query: (\n        collections.abc.Mapping[str, typing.Any]\n        | sob.abc.Dictionary\n        | sob.abc.Object\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ),\n    doseq: bool = True,  # noqa: FBT001 FBT002\n    safe: str = URLENCODE_SAFE,\n    encoding: str = \"utf-8\",\n    errors: str = \"\",\n    quote_via: typing.Callable[[str, bytes | str, str, str], str] = quote,\n) -&gt; str:\n    \"\"\"\n    This function wraps `urllib.parse.urlencode`, but has different default\n    argument values. Additionally, when a mapping/dictionary is passed for a\n    query value, that dictionary/mapping performs an update to the query\n    dictionary.\n\n    Parameters:\n        query:\n        doseq:\n        safe:\n        encoding:\n        errors:\n        quote_via:\n    \"\"\"\n    items: list[tuple[str, typing.Any]] = []\n    key: str\n    value: typing.Any\n    for key, value in _iter_items(query):\n        if isinstance(value, _ITEMIZED_TYPES):\n            # The only dictionaries/objects which should exist\n            # for values which have been formatted are\n            # intended to be bumped up into the top-level\n            items.extend(_iter_items(value))\n        else:\n            items.append((key, value))\n    return _urlencode(\n        query=items,\n        doseq=doseq,\n        safe=safe,\n        encoding=encoding,\n        errors=errors,\n        quote_via=quote_via,  # type: ignore\n    )\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.format_argument_value","title":"format_argument_value","text":"<pre><code>format_argument_value(\n    name: str,\n    value: sob.abc.MarshallableTypes | typing.IO[bytes],\n    style: str,\n    *,\n    explode: bool = False,\n    multipart: bool = False\n) -&gt; (\n    str\n    | dict[str, str]\n    | dict[str, str | list[str]]\n    | collections.abc.Sequence[str]\n    | collections.abc.Sequence[bytes]\n    | bytes\n    | collections.abc.Sequence[typing.IO[bytes]]\n    | typing.IO[bytes]\n    | None\n)\n</code></pre> <p>Format an argument value for use in a path, query, cookie, header, etc.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>sob.abc.MarshallableTypes | typing.IO[bytes]</code>)           \u2013            </li> <li> <code>style</code>               (<code>str</code>)           \u2013            </li> <li> <code>explode</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>multipart</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indicates the argument will be part of a multipart request</p> </li> </ul> <p>See: https://swagger.io/docs/specification/serialization/</p> Source code in <code>src/oapi/client.py</code> <pre><code>def format_argument_value(  # noqa: C901\n    name: str,\n    value: sob.abc.MarshallableTypes | typing.IO[bytes],\n    style: str,\n    *,\n    explode: bool = False,\n    multipart: bool = False,\n) -&gt; (\n    str\n    | dict[str, str]\n    | dict[str, str | list[str]]\n    | collections.abc.Sequence[str]\n    | collections.abc.Sequence[bytes]\n    | bytes\n    | collections.abc.Sequence[typing.IO[bytes]]\n    | typing.IO[bytes]\n    | None\n):\n    \"\"\"\n    Format an argument value for use in a path, query, cookie, header, etc.\n\n    Parameters:\n        value:\n        style:\n        explode:\n        multipart: Indicates the argument will be part of a\n            multipart request\n\n    See: https://swagger.io/docs/specification/serialization/\n    \"\"\"\n    if multipart and (\n        isinstance(value, (bytes, sob.abc.Readable))\n        or (\n            value\n            and (not isinstance(value, str))\n            and isinstance(value, collections.abc.Sequence)\n            and isinstance(value[0], (bytes, sob.abc.Readable))\n        )\n    ):\n        # For multipart requests, we don't apply any formatting to `bytes`\n        # objects, as they will be sent in binary format\n        return value\n    if isinstance(value, sob.abc.Model):\n        value = sob.marshal(value)  # type: ignore\n    if style == \"simple\":\n        return _format_simple_argument_value(value, explode=explode)\n    if style == \"label\":\n        return _format_label_argument_value(value, explode=explode)\n    if style == \"matrix\":\n        return _format_matrix_argument_value(name, value, explode=explode)\n    if style == \"form\":\n        return _format_form_argument_value(value, explode=explode)\n    if style == \"spaceDelimited\":\n        return _format_space_delimited_argument_value(value, explode=explode)\n    if style == \"pipeDelimited\":\n        return _format_pipe_delimited_argument_value(value, explode=explode)\n    if style == \"deepObject\":\n        return _format_deep_object_argument_value(name, value, explode=explode)\n    if style == \"dotObject\":\n        return _format_dot_object_argument_value(name, value, explode=explode)\n    raise ValueError(style)\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.get_request_curl","title":"get_request_curl","text":"<pre><code>get_request_curl(\n    request: urllib.request.Request,\n    options: str = \"-i\",\n    censored_headers: collections.abc.Iterable[str] = (\n        \"X-api-key\",\n        \"Authorization\",\n    ),\n    censored_parameters: tuple[str, ...] = (\n        \"client_secret\",\n    ),\n) -&gt; str\n</code></pre> <p>Render an instance of <code>urllib.request.Request</code> as a <code>curl</code> command.</p> <p>Parameters:</p> <ul> <li> <code>options</code>               (<code>str</code>, default:                   <code>'-i'</code> )           \u2013            <p>Any additional parameters to pass to <code>curl</code>, (such as \"--compressed\", \"--insecure\", etc.)</p> </li> </ul> Source code in <code>src/oapi/client.py</code> <pre><code>def get_request_curl(\n    request: Request,\n    options: str = \"-i\",\n    censored_headers: collections.abc.Iterable[str] = (\n        \"X-api-key\",\n        \"Authorization\",\n    ),\n    censored_parameters: tuple[str, ...] = (\"client_secret\",),\n) -&gt; str:\n    \"\"\"\n    Render an instance of `urllib.request.Request` as a `curl` command.\n\n    Parameters:\n        options: Any additional parameters to pass to `curl`,\n            (such as \"--compressed\", \"--insecure\", etc.)\n    \"\"\"\n    content_type: str | None = request.headers.get(\"Content-type\")\n    if content_type:\n        content_type = content_type.lower()\n    content_encoding: str | None = request.headers.get(\"Content-encoding\")\n    is_json: bool = bool(\n        content_type == \"application/json\"\n        or (\n            content_type\n            and content_type.endswith(\"+json\")\n            and content_type.startswith(\"application/\")\n        )\n    )\n    censored_headers = tuple(map(str.lower, censored_headers))\n\n    def _get_request_curl_header_item(item: tuple[str, str]) -&gt; str:\n        key: str\n        value: str\n        key, value = item\n        if key.lower() in censored_headers:\n            value = \"***\"\n        return \"-H {}\".format(shlex.quote(f\"{key}: {value}\"))\n\n    data: bytes = (\n        request.data\n        if isinstance(request.data, bytes)\n        else (\n            request.data.read()  # type: ignore\n            if isinstance(request.data, sob.abc.Readable)\n            else (\n                b\"\".join(request.data) if request.data else b\"\"  # type: ignore\n            )\n        )\n    )\n    if data and content_encoding:\n        data = _decode_content(data, content_encoding)\n    repr_data: str = \"\"\n    if data:\n        try:\n            data_str = data.decode(\"utf-8\")\n            if censored_parameters and not is_json:\n                query: dict[str, list[str]] = {}\n                key: str\n                value: list[str]\n                for key, value in parse_qs(data_str).items():\n                    if key in censored_parameters:\n                        query[key] = [\"***\"]\n                    else:\n                        query[key] = value\n                data_str = urlencode(\n                    query, safe=f\"*{URLENCODE_SAFE}\", doseq=True\n                )\n            repr_data = shlex.quote(data_str)\n        except UnicodeDecodeError:\n            # If the data can't be represented as a command-line argument,\n            # use a placeholder\n            repr_data = \"***\"\n    return \" \".join(\n        filter(\n            None,\n            (\n                f\"curl -X {request.get_method()}\",\n                options,\n                \" \".join(\n                    map(\n                        _get_request_curl_header_item,\n                        sorted(request.headers.items()),  # type: ignore\n                    )\n                ),\n                (f\"-d {repr_data}\" if data else \"\"),\n                shlex.quote(request.full_url),\n            ),\n        )\n    )\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.default_retry_hook","title":"default_retry_hook","text":"<pre><code>default_retry_hook(error: Exception) -&gt; bool\n</code></pre> <p>By default, don't retry for HTTP 404 (NOT FOUND) errors and HTTP 401 (UNAUTHORIZED) errors.</p> Source code in <code>src/oapi/client.py</code> <pre><code>def default_retry_hook(error: Exception) -&gt; bool:\n    \"\"\"\n    By default, don't retry for HTTP 404 (NOT FOUND) errors\n    and HTTP 401 (UNAUTHORIZED) errors.\n    \"\"\"\n    return not (\n        isinstance(error, HTTPError) and error.code in (404, 401, 409, 410)\n    )\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.retry","title":"retry","text":"<pre><code>retry(\n    errors: (\n        tuple[type[Exception], ...] | type[Exception]\n    ) = Exception,\n    retry_hook: typing.Callable[\n        [Exception], bool\n    ] = oapi.client.default_retry_hook,\n    number_of_attempts: int = 1,\n    logger: logging.Logger | None = None,\n) -&gt; typing.Callable\n</code></pre> <p>This function decorates another, and causes the decorated function to be re-attempted a specified number of times, with exponential backoff, until the decorated function is successful or the maximum number of attempts is reached (in which case an exception is raised).</p> <p>Parameters:</p> <ul> <li> <code>errors</code>               (<code>tuple[type[Exception], ...] | type[Exception]</code>, default:                   <code>Exception</code> )           \u2013            <p>A sub-class of <code>Exception</code>, or a tuple of one or more sub-classes of <code>Exception</code>. The default is <code>Exception</code>, causing all errors to trigger a retry.</p> </li> <li> <code>retry_hook</code>               (<code>typing.Callable[[Exception], bool]</code>, default:                   <code>oapi.client.default_retry_hook</code> )           \u2013            <p>A function accepting as its only argument the handled exception, and returning a boolean value indicating whether or not to retry the function.</p> </li> <li> <code>number_of_attempts</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The maximum number of times to attempt execution of the function, including the first execution. Please note that, because the default for this parameter is 1, this decorator will do nothing if this argument is not provided.</p> </li> </ul> Source code in <code>src/oapi/client.py</code> <pre><code>def retry(\n    errors: tuple[type[Exception], ...] | type[Exception] = Exception,\n    retry_hook: typing.Callable[[Exception], bool] = default_retry_hook,\n    number_of_attempts: int = 1,\n    logger: Logger | None = None,\n) -&gt; typing.Callable:\n    \"\"\"\n    This function decorates another, and causes the decorated function\n    to be re-attempted a specified number of times, with exponential\n    backoff, until the decorated function is successful or the maximum\n    number of attempts is reached (in which case an exception is raised).\n\n    Parameters:\n        errors: A sub-class of `Exception`, or a tuple of one or more\n            sub-classes of `Exception`. The default is `Exception`, causing\n            *all* errors to trigger a retry.\n        retry_hook: A function accepting as its only argument the handled\n            exception, and returning a boolean value indicating whether or not\n            to retry the function.\n        number_of_attempts: The maximum number of times to attempt\n            execution of the function, *including* the first execution. Please\n            note that, because the default for this parameter is 1, this\n            decorator will do *nothing* if this argument is not provided.\n    \"\"\"\n\n    def decorating_function(function: typing.Callable) -&gt; typing.Callable:\n        attempt_number: int = 1\n\n        @functools.wraps(function)\n        def wrapper(*args: typing.Any, **kwargs: typing.Any) -&gt; typing.Any:\n            nonlocal attempt_number\n            nonlocal number_of_attempts\n            if number_of_attempts - attempt_number:\n                try:\n                    return function(*args, **kwargs)\n                except errors as error:\n                    if not retry_hook(error):\n                        raise\n                    warning_message: str = (\n                        f\"Attempt # {attempt_number!s}:\\n\"\n                        f\"{sob.errors.get_exception_text()}\"\n                    )\n                    warn(warning_message, stacklevel=2)\n                    if logger is not None:\n                        logger.warning(warning_message)\n                    sleep(2**attempt_number)\n                    attempt_number += 1\n                    return wrapper(*args, **kwargs)\n            return function(*args, **kwargs)\n\n        return wrapper\n\n    return decorating_function\n</code></pre>"},{"location":"api/oapi.client/#oapi.client.write_client_module","title":"write_client_module","text":"<pre><code>write_client_module(\n    client_path: str | pathlib.Path,\n    *,\n    open_api: (\n        str | sob.abc.Readable | oapi.oas.model.OpenAPI\n    ),\n    model_path: str | pathlib.Path,\n    class_name: str = \"Client\",\n    base_class: type[\n        oapi.client.Client\n    ] = oapi.client.Client,\n    imports: str | tuple[str, ...] = (),\n    init_decorator: str = \"\",\n    include_init_parameters: str | tuple[str, ...] = (),\n    add_init_parameters: str | tuple[str, ...] = (),\n    add_init_parameter_docs: str | tuple[str, ...] = (),\n    init_parameter_defaults: (\n        collections.abc.Mapping[str, typing.Any]\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ) = (),\n    init_parameter_defaults_source: (\n        collections.abc.Mapping[str, typing.Any]\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ) = (),\n    get_method_name_from_path_method_operation: typing.Callable[\n        [str, str, str | None], str\n    ] = oapi.client.get_default_method_name_from_path_method_operation,\n    use_operation_id: bool = False,\n    module_docstring: str | None = None,\n    class_docstring: str | None = None\n) -&gt; None\n</code></pre> <p>This function parses an Open API document and outputs a module defining a client class for interfacing with the API described by an OpenAPI document.</p> <p>Parameters:</p> <ul> <li> <code>client_path</code>               (<code>str | pathlib.Path</code>)           \u2013            <p>The file path where the client module will be saved (created or updated).</p> </li> <li> <code>open_api</code>               (<code>str | sob.abc.Readable | oapi.oas.model.OpenAPI</code>)           \u2013            <p>An OpenAPI document. This can be a URL, file-path, an HTTP response (<code>http.client.HTTPResponse</code>), a file object, or an instance of <code>oapi.oas.model.OpenAPI</code>.</p> </li> <li> <code>model_path</code>               (<code>str | pathlib.Path</code>)           \u2013            <p>The file path where the data model for this client can be found. This must be a model generated using <code>oapi.model</code>, and must be part of the same project that this client will be saved into.</p> </li> <li> <code>class_name</code>               (<code>str</code>, default:                   <code>'Client'</code> )           \u2013            </li> <li> <code>base_class</code>               (<code>type[oapi.client.Client]</code>, default:                   <code>oapi.client.Client</code> )           \u2013            <p>The base class to use for the client. If provided, this must be a sub-class of <code>oapi.client.Client</code>.</p> </li> <li> <code>imports</code>               (<code>str | tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>One or more import statements to include (in addition to those generated automatically).</p> </li> <li> <code>init_decorator</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A decorator to apply to the client class <code>.__init__</code> method. If used, make sure to include any modules referenced in your <code>imports</code>. For example: \"@decorator_function(argument_a=1, argument_b=2)\".</p> </li> <li> <code>include_init_parameters</code>               (<code>str | tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>The name of all parameters to include for the client's <code>.__init__</code> method.</p> </li> <li> <code>add_init_parameters</code>               (<code>str | tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            <p>Additional parameter declarations to add to the client's <code>.__init__</code> method. These should include a type hint and default value (not just the parameter name). For example: 'additional_parameter_name: str | None = None'. Note: additional parameters will not do anything without the use of a decorator which utilizes the additional parameters, so use of this parameter should be accompanied by an <code>init_decorator</code>.</p> </li> <li> <code>add_init_parameter_docs</code>               (<code>str | tuple[str, ...]</code>, default:                   <code>()</code> )           \u2013            </li> <li> <code>init_parameter_defaults</code>               (<code>collections.abc.Mapping[str, typing.Any] | collections.abc.Sequence[tuple[str, typing.Any]]</code>, default:                   <code>()</code> )           \u2013            <p>A mapping of parameter names to default values for the parameter.</p> </li> <li> <code>init_parameter_defaults_source</code>               (<code>collections.abc.Mapping[str, typing.Any] | collections.abc.Sequence[tuple[str, typing.Any]]</code>, default:                   <code>()</code> )           \u2013            <p>A mapping of parameter names to default values for the parameter expressed as source code. This is to allow for the passing of imported constants, expressions, etc.</p> </li> <li> <code>module_docstring</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A docstring to insert at the top of the module.</p> </li> <li> <code>class_docstring</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A docstring to insert in the client class.</p> </li> </ul> Source code in <code>src/oapi/client.py</code> <pre><code>def write_client_module(\n    client_path: str | Path,\n    *,\n    open_api: str | sob.abc.Readable | OpenAPI,\n    model_path: str | Path,\n    class_name: str = \"Client\",\n    base_class: type[Client] = Client,\n    imports: str | tuple[str, ...] = (),\n    init_decorator: str = \"\",\n    include_init_parameters: str | tuple[str, ...] = (),\n    add_init_parameters: str | tuple[str, ...] = (),\n    add_init_parameter_docs: str | tuple[str, ...] = (),\n    init_parameter_defaults: (\n        collections.abc.Mapping[str, typing.Any]\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ) = (),\n    init_parameter_defaults_source: (\n        collections.abc.Mapping[str, typing.Any]\n        | collections.abc.Sequence[tuple[str, typing.Any]]\n    ) = (),\n    get_method_name_from_path_method_operation: typing.Callable[\n        [str, str, str | None], str\n    ] = get_default_method_name_from_path_method_operation,\n    use_operation_id: bool = False,\n    module_docstring: str | None = None,\n    class_docstring: str | None = None,\n) -&gt; None:\n    \"\"\"\n    This function parses an Open API document and outputs a module defining\n    a client class for interfacing with the API described by an OpenAPI\n    document.\n\n    Parameters:\n        client_path: The file path where the client module will be saved\n            (created or updated).\n        open_api: An OpenAPI document. This can be a URL, file-path, an\n            HTTP response (`http.client.HTTPResponse`), a file object, or\n            an instance of `oapi.oas.model.OpenAPI`.\n        model_path: The file path where the data model for this\n            client can be found. This must be a model generated using\n            `oapi.model`, and must be part of the same project that this\n            client will be saved into.\n        class_name:\n        base_class: The base class to use for the client. If provided,\n            this must be a sub-class of `oapi.client.Client`.\n        imports: One or more import statements to include\n            (in addition to those generated automatically).\n        init_decorator:  A decorator to apply to the client class\n            `.__init__` method. If used, make sure to include any modules\n            referenced in your `imports`. For example:\n            \"@decorator_function(argument_a=1, argument_b=2)\".\n        include_init_parameters: The name of all parameters to\n            include for the client's `.__init__` method.\n        add_init_parameters: Additional parameter\n            declarations to add to the client's `.__init__` method.\n            These should include a type hint and default value (not just\n            the parameter name). For example:\n            'additional_parameter_name: str | None = None'. Note:\n            additional parameters will not do anything without the use of a\n            decorator which utilizes the additional parameters, so use of\n            this parameter should be accompanied by an `init_decorator`.\n        add_init_parameter_docs:\n        init_parameter_defaults: A mapping of\n            parameter names to default values for the parameter.\n        init_parameter_defaults_source: A mapping of\n            parameter names to default values for the parameter *expressed\n            as source code*. This is to allow for the passing of imported\n            constants, expressions, etc.\n        module_docstring: A docstring to insert at the top of the module.\n        class_docstring: A docstring to insert in the client class.\n    \"\"\"\n    locals_: dict[str, typing.Any] = dict(locals())\n    locals_.pop(\"client_path\")\n    client_module: ClientModule = ClientModule(**locals_)\n    client_module.save(client_path)\n</code></pre>"},{"location":"api/oapi.errors/","title":"oapi.errors","text":""},{"location":"api/oapi.errors/#oapi.errors","title":"oapi.errors","text":""},{"location":"api/oapi.errors/#oapi.errors.OAPIError","title":"OAPIError","text":"<p>               Bases: <code>Exception</code></p> <p>This is base class for <code>oapi</code> errors.</p>"},{"location":"api/oapi.errors/#oapi.errors.OAPIReferenceError","title":"OAPIReferenceError","text":"<p>               Bases: <code>oapi.errors.OAPIError</code>, <code>ValueError</code></p> <p>This is base class for errors encountered while attempting to resolve references in an OpenAPI document.</p>"},{"location":"api/oapi.errors/#oapi.errors.OAPIReferenceLoopError","title":"OAPIReferenceLoopError","text":"<p>               Bases: <code>oapi.errors.OAPIReferenceError</code></p> <p>This is an error raised when a referential loop is encountered. This error will only be encountered if attempting to recursively dereference a document using <code>oapi.oas.references.Resolver.dereference</code>. Typical usage of <code>oapi</code> does not require dereferencing a document.</p>"},{"location":"api/oapi.errors/#oapi.errors.OAPIReferencePointerError","title":"OAPIReferencePointerError","text":"<p>               Bases: <code>oapi.errors.OAPIReferenceError</code></p> <p>This is an error raised when a reference has a pointer which cannot be resolved (no entity exists at the indicated position).</p>"},{"location":"api/oapi.errors/#oapi.errors.OAPIDuplicateClassNameError","title":"OAPIDuplicateClassNameError","text":"<p>               Bases: <code>oapi.errors.OAPIError</code></p> <p>This is an error raised if/when an instance of <code>oapi.ModelModule</code> produces two model classes having the same name. This is not possible using the default naming algorithm, however a custom class naming callback function can be provided, so this scenario is possible in that case.</p>"},{"location":"api/oapi.model/","title":"oapi.model","text":""},{"location":"api/oapi.model/#oapi.model","title":"oapi.model","text":""},{"location":"api/oapi.model/#oapi.model.ModelModule","title":"ModelModule","text":"<pre><code>ModelModule(\n    open_api: (\n        str | sob.abc.Readable | oapi.oas.model.OpenAPI\n    ),\n    get_class_name_from_pointer: collections.abc.Callable[\n        [str, str], str\n    ] = oapi.model.get_default_class_name_from_pointer,\n    docstring: str | None = None,\n)\n</code></pre> <p>This class parses an Open API document and generates a module defining classes to represent each schema defined in the Open API document as a subclass of <code>sob.Object</code>, <code>sob.Array</code>, or <code>sob.Dictionary</code>.</p> <p>Parameters:</p> <ul> <li> <code>open_api</code>               (<code>str | sob.abc.Readable | oapi.oas.model.OpenAPI</code>)           \u2013            <p>An OpenAPI document. This can be a URL, file-path, an HTTP response (<code>http.client.HTTPResponse</code>), a file object, or an instance of <code>oapi.oas.OpenAPI</code>.</p> </li> <li> <code>get_class_name_from_pointer</code>               (<code>collections.abc.Callable[[str, str], str]</code>, default:                   <code>oapi.model.get_default_class_name_from_pointer</code> )           \u2013            <p>This argument defaults to <code>oapi.model.get_default_class_name_from_pointer</code>. If an alternate function is provided, it should accept two arguments, both being <code>str</code> instances. The first argument is a JSON pointer, or concatenated relative URL + JSON pointer, and the second being either an empty string or a parameter name, where applicable. The function should return a <code>str</code> which is a valid, unique, class name.</p> </li> <li> <code>docstring</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, this string will be inserts as the module docstring.</p> </li> </ul> Source code in <code>src/oapi/model.py</code> <pre><code>def __init__(\n    self,\n    open_api: str | sob.abc.Readable | OpenAPI,\n    get_class_name_from_pointer: Callable[\n        [str, str], str\n    ] = get_default_class_name_from_pointer,\n    docstring: str | None = None,\n) -&gt; None:\n    message: str\n    self._parser = _ModuleParser()\n    self._modeler: _Modeler\n    if isinstance(open_api, str):\n        if os.path.exists(open_api):\n            self._modeler = _get_path_modeler(open_api)\n        else:\n            self._modeler = _get_url_modeler(open_api)\n    elif isinstance(open_api, sob.abc.Readable):\n        self._modeler = _get_io_modeler(open_api)\n    elif isinstance(open_api, OpenAPI):\n        self._modeler = _get_open_api_modeler(open_api)\n    else:\n        message = (\n            f\"`{get_calling_function_qualified_name()}` requires an \"\n            f\"instance of `str`, `{get_qualified_name(OpenAPI)}`, or \"\n            \"a file-like object for the `open_api` parameter\u2014not: \"\n            f\"{open_api!r}\"\n        )\n        raise TypeError(message)\n    self._modeler.docstring = docstring\n    self._modeler.get_class_name_from_pointer = get_class_name_from_pointer\n</code></pre>"},{"location":"api/oapi.model/#oapi.model.ModelModule.save","title":"save","text":"<pre><code>save(path: str | pathlib.Path) -&gt; None\n</code></pre> <p>This method will save the generated module to a given path. If there is an existing module at that path--the existing module will be imported and the pre-existing class names will be utilized for any schemas defined by elements residing at the same location as the documented JSON pointer in the pre-existing classes' docstrings.</p> Source code in <code>src/oapi/model.py</code> <pre><code>def save(self, path: str | Path) -&gt; None:\n    \"\"\"\n    This method will save the generated module to a given path. If there is\n    an existing module at that path--the existing module will be imported\n    and the pre-existing class names will be utilized for any schemas\n    defined by elements residing at the same location as the documented\n    JSON pointer in the pre-existing classes' docstrings.\n    \"\"\"\n    # Make sure that any matching, existing classes use the same names\n    self._parse_existing_module(path)\n    model_source: str = str(self)\n    # Save the module\n    with open(path, \"w\") as model_io:\n        model_io.write(model_source)\n</code></pre>"},{"location":"api/oapi.model/#oapi.model.get_default_class_name_from_pointer","title":"get_default_class_name_from_pointer","text":"<pre><code>get_default_class_name_from_pointer(\n    pointer: str,\n    name: str = \"\",\n    log: (\n        logging.Logger\n        | collections.abc.Callable[[str], None]\n        | None\n    ) = None,\n) -&gt; str\n</code></pre> <p>This function infers a class name from a JSON pointer (or from a relative URL concatenated with a JSON pointer) + parameter name (or empty string when a parameter name is not applicable). This function is the default naming function used by <code>oapi.model.Module</code>.</p> <p>Parameters:</p> <ul> <li> <code>pointer</code>               (<code>str</code>)           \u2013            <p>A JSON pointer referencing a schema within an OpenAPI document, or a concatenation of a relative URL + \"#\" + a JSON pointer.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The parameter name, or \"\" if the element is not a parameter.</p> </li> <li> <code>log</code>               (<code>logging.Logger | collections.abc.Callable[[str], None] | None</code>, default:                   <code>None</code> )           \u2013            <p>A logger, or a callback function for log messages</p> </li> </ul> <p>Examples:</p> <p>print( ...     get_default_class_name_from_pointer( ...         \"#/paths/~1directory~1sub-directory~1name/get/parameters/1\", ...         name=\"argument-name\", ...     ) ... ) DirectorySubDirectoryNameGetArgumentName</p> <p>print( ...     get_default_class_name_from_pointer( ...         \"#/paths/~1directory~1sub-directory~1name/get/parameters/1\"  # ...         \"/item\", ...         name=\"argument-name\", ...     ) ... ) DirectorySubDirectoryNameGetArgumentNameItem</p> Source code in <code>src/oapi/model.py</code> <pre><code>def get_default_class_name_from_pointer(\n    pointer: str,\n    name: str = \"\",\n    log: Logger | Callable[[str], None] | None = None,\n) -&gt; str:\n    \"\"\"\n    This function infers a class name from a JSON pointer (or from a\n    relative URL concatenated with a JSON pointer) + parameter name (or\n    empty string when a parameter name is not applicable). This function is\n    the default naming function used by `oapi.model.Module`.\n\n    Parameters:\n        pointer: A JSON pointer referencing a schema within an OpenAPI\n            document, or a concatenation of a relative URL + \"#\" + a JSON\n            pointer.\n        name: The parameter name, or \"\" if the element is not a\n            parameter.\n        log: A logger, or a callback function for log messages\n\n    Examples:\n\n    &gt;&gt;&gt; print(\n    ...     get_default_class_name_from_pointer(\n    ...         \"#/paths/~1directory~1sub-directory~1name/get/parameters/1\",\n    ...         name=\"argument-name\",\n    ...     )\n    ... )\n    DirectorySubDirectoryNameGetArgumentName\n\n    &gt;&gt;&gt; print(\n    ...     get_default_class_name_from_pointer(\n    ...         \"#/paths/~1directory~1sub-directory~1name/get/parameters/1\"  #\n    ...         \"/item\",\n    ...         name=\"argument-name\",\n    ...     )\n    ... )\n    DirectorySubDirectoryNameGetArgumentNameItem\n    \"\"\"\n    relative_url: str = \"\"\n    if \"#\" in pointer:\n        relative_url, pointer = pointer.split(\"#\", 1)\n    class_name_: str = pointer.lstrip(\"/\")\n    pattern: str\n    repl: str\n    for pattern, repl in (\n        (\n            r\"/([^\\/]+)/responses/200/(content/[^\\/]+/)?schema\\b\",\n            r\"/\\1/response\",\n        ),\n        (\n            r\"/([^\\/]+)/responses/(\\d+)/(content/[^\\/]+/)?schema\\b\",\n            r\"/\\1/response/\\2\",\n        ),\n        (\n            r\"/(anyOf|allOf|oneOf)/\\d+/\",\n            \"/\",\n        ),\n        (\n            r\"(?:^components)?(/|^)parameters/([^/]+)/schema(/|$)\",\n            r\"\\1\\2\\3\",\n        ),\n        (\n            r\"^(components/[^/]+/|definitions/|paths/)\",\n            \"/\",\n        ),\n        (\n            r\"/properties/\",\n            \"/\",\n        ),\n        (\n            r\"/items(/|$)\",\n            r\"/item\\1\",\n        ),\n        (\n            r\"~1\",\n            \"/\",\n        ),\n        (\n            r\"~0\",\n            \"~\",\n        ),\n    ):\n        class_name_ = re.sub(pattern, repl, class_name_)\n    # For parameters, include the parameter name in the class name *if* the\n    # parameter is defined inline (if it's not defined inline, the path to\n    # the parameter definition will usually be sufficiently descriptive),\n    # and don't include \"/parameters/\" or the parameter # in the class\n    # name.\n    if name and not (\n        pointer.startswith((\"/components/parameters/\", \"/definitions/\"))\n    ):\n        parameters_pattern: Pattern = re.compile(r\"/parameters/\\d+((?:/.+)?)$\")\n        if parameters_pattern.search(class_name_):\n            class_name_ = parameters_pattern.sub(f\"/{name}/\\\\1\", class_name_)\n        else:\n            class_name_ = f\"{class_name_}/{name}\"\n    if relative_url:\n        class_name_ = f\"{relative_url}/{class_name_}\"\n    if log is not None:  # pragma: no cover\n        message: str = (\n            f\"{pointer} -&gt; {class_name_} (JSON Pointer -&gt; Class Name)\"\n        )\n        if isinstance(log, Logger):\n            log.info(message)\n        elif callable(log):\n            log(message)\n    return sob.utilities.get_class_name(class_name_)\n</code></pre>"},{"location":"api/oapi.model/#oapi.model.write_model_module","title":"write_model_module","text":"<pre><code>write_model_module(\n    model_path: str | pathlib.Path,\n    *,\n    open_api: (\n        str | sob.abc.Readable | oapi.oas.model.OpenAPI\n    ),\n    get_class_name_from_pointer: collections.abc.Callable[\n        [str, str], str\n    ] = oapi.model.get_default_class_name_from_pointer,\n    docstring: str | None = None\n) -&gt; None\n</code></pre> <p>This function creates or updates a module defining classes to represent each schema in an Open API document as a subclass of <code>sob.Object</code>, <code>sob.Array</code>, or <code>sob.Dictionary</code>.</p> <p>Parameters:</p> <ul> <li> <code>model_path</code>               (<code>str | pathlib.Path</code>)           \u2013            <p>The file path where the model module will be saved (created or updated).</p> </li> <li> <code>open_api</code>               (<code>str | sob.abc.Readable | oapi.oas.model.OpenAPI</code>)           \u2013            <p>An OpenAPI document. This can be a URL, file-path, an HTTP response (<code>http.client.HTTPResponse</code>), a file object, or an instance of <code>oapi.oas.model.OpenAPI</code>.</p> </li> <li> <code>get_class_name_from_pointer</code>               (<code>collections.abc.Callable[[str, str], str]</code>, default:                   <code>oapi.model.get_default_class_name_from_pointer</code> )           \u2013            <p>This argument defaults to <code>oapi.model.get_default_class_name_from_pointer</code>. If an alternate function is provided, it should accept two arguments, both being <code>str</code> instances. The first argument is a JSON pointer, or concatenated relative URL + JSON pointer, and the second being either an empty string or a parameter name, where applicable. The function should return a <code>str</code> which is a valid, unique, class name.</p> </li> <li> <code>docstring</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, this string will be inserted at the top of the module as the docstring.</p> </li> </ul> Source code in <code>src/oapi/model.py</code> <pre><code>def write_model_module(\n    model_path: str | Path,\n    *,\n    open_api: str | sob.abc.Readable | OpenAPI,\n    get_class_name_from_pointer: Callable[\n        [str, str], str\n    ] = get_default_class_name_from_pointer,\n    docstring: str | None = None,\n) -&gt; None:\n    \"\"\"\n    This function creates or updates a module defining classes to represent\n    each schema in an Open API document as a subclass of `sob.Object`,\n    `sob.Array`, or `sob.Dictionary`.\n\n    Parameters:\n        model_path: The file path where the model module will be saved\n            (created or updated).\n        open_api: An OpenAPI document. This can be a URL, file-path, an\n            HTTP response (`http.client.HTTPResponse`), a file object, or an\n            instance of `oapi.oas.model.OpenAPI`.\n        get_class_name_from_pointer: This argument defaults to\n            `oapi.model.get_default_class_name_from_pointer`. If an alternate\n            function is provided, it should accept two arguments, both being\n            `str` instances. The first argument is a JSON pointer, or\n            concatenated relative URL + JSON pointer, and the second being\n            either an empty string or a parameter name, where applicable.\n            The function should return a `str` which is a valid, unique,\n            class name.\n        docstring: If provided, this string will be inserted at the top of the\n            module as the docstring.\n    \"\"\"\n    locals_: dict[str, Any] = dict(locals())\n    locals_.pop(\"model_path\")\n    # Increase the recursion limit to allow deep models to be processed\n    recursion_limit: int = sys.getrecursionlimit()\n    sys.setrecursionlimit(recursion_limit * 100)\n    try:\n        model_module: ModelModule = ModelModule(**locals_)\n        model_module.save(model_path)\n    finally:\n        sys.setrecursionlimit(recursion_limit)\n</code></pre>"},{"location":"api/oapi.oas.model/","title":"oapi.oas.model","text":""},{"location":"api/oapi.oas.model/#oapi.oas.model","title":"oapi.oas.model","text":"<p>This module contains models describing objects defined by the OpenAPI Specification. The root object, <code>oapi.oas.OpenAPI</code> is capable of representing either an OpenAPI 3 Document  or an OpenAPI 2 (Swagger) Document , depending on the specification version identified in the document.</p>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Contact","title":"Contact","text":"<pre><code>Contact(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: str | None = None,\n    url: str | None = None,\n    email: str | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Contact Object </p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>url</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>email</code>               (<code>str | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: (\n        str\n        | None\n    ) = None,\n    url: (\n        str\n        | None\n    ) = None,\n    email: (\n        str\n        | None\n    ) = None\n) -&gt; None:\n    self.name: (\n        str\n        | None\n    ) = name\n    self.url: (\n        str\n        | None\n    ) = url\n    self.email: (\n        str\n        | None\n    ) = email\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Discriminator","title":"Discriminator","text":"<pre><code>Discriminator(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    property_name: str | None = None,\n    mapping: typing.Mapping[str, str] | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Discriminator Object </p> <p>Attributes:</p> <ul> <li> <code>property_name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property which will hold the discriminating value.</p> </li> <li> <code>mapping</code>               (<code>typing.Mapping[str, str] | None</code>)           \u2013            <p>An mappings of payload values to schema names or references.</p> </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    property_name: (\n        str\n        | None\n    ) = None,\n    mapping: (\n        typing.Mapping[\n            str,\n            str\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.property_name: (\n        str\n        | None\n    ) = property_name\n    self.mapping: (\n        typing.Mapping[\n            str,\n            str\n        ]\n        | None\n    ) = mapping\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Encoding","title":"Encoding","text":"<pre><code>Encoding(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    content_type: str | None = None,\n    headers: (\n        typing.Mapping[\n            str,\n            oapi.oas.model.Reference\n            | oapi.oas.model.Header,\n        ]\n        | None\n    ) = None,\n    style: str | None = None,\n    explode: bool | None = None,\n    allow_reserved: bool | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Encoding Object </p> <p>Attributes:</p> <ul> <li> <code>content_type</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>headers</code>               (<code>typing.Mapping[str, oapi.oas.model.Reference | oapi.oas.model.Header] | None</code>)           \u2013            </li> <li> <code>style</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>explode</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>allow_reserved</code>               (<code>bool | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    content_type: (\n        str\n        | None\n    ) = None,\n    headers: (\n        typing.Mapping[\n            str,\n            Reference\n            | Header\n        ]\n        | None\n    ) = None,\n    style: (\n        str\n        | None\n    ) = None,\n    explode: (\n        bool\n        | None\n    ) = None,\n    allow_reserved: (\n        bool\n        | None\n    ) = None\n) -&gt; None:\n    self.content_type: (\n        str\n        | None\n    ) = content_type\n    self.headers: (\n        typing.Mapping[\n            str,\n            Reference\n            | Header\n        ]\n        | None\n    ) = headers\n    self.style: (\n        str\n        | None\n    ) = style\n    self.explode: (\n        bool\n        | None\n    ) = explode\n    self.allow_reserved: (\n        bool\n        | None\n    ) = allow_reserved\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Example","title":"Example","text":"<pre><code>Example(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    summary: str | None = None,\n    description: str | None = None,\n    value: typing.Any | None = None,\n    external_value: str | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Example Object </p> <p>Attributes:</p> <ul> <li> <code>summary</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>value</code>               (<code>typing.Any | None</code>)           \u2013            </li> <li> <code>external_value</code>               (<code>str | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    summary: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    value: (\n        typing.Any\n        | None\n    ) = None,\n    external_value: (\n        str\n        | None\n    ) = None\n) -&gt; None:\n    self.summary: (\n        str\n        | None\n    ) = summary\n    self.description: (\n        str\n        | None\n    ) = description\n    self.value: (\n        typing.Any\n        | None\n    ) = value\n    self.external_value: (\n        str\n        | None\n    ) = external_value\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.ExternalDocumentation","title":"ExternalDocumentation","text":"<pre><code>ExternalDocumentation(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    description: str | None = None,\n    url: str | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 External Documentation Object </p> <p>Attributes:</p> <ul> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>url</code>               (<code>str | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    url: (\n        str\n        | None\n    ) = None\n) -&gt; None:\n    self.description: (\n        str\n        | None\n    ) = description\n    self.url: (\n        str\n        | None\n    ) = url\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Header","title":"Header","text":"<pre><code>Header(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    description: str | None = None,\n    required: bool | None = None,\n    deprecated: bool | None = None,\n    allow_empty_value: bool | None = None,\n    style: str | None = None,\n    explode: bool | None = None,\n    allow_reserved: bool | None = None,\n    schema: (\n        oapi.oas.model.Reference\n        | oapi.oas.model.Schema\n        | None\n    ) = None,\n    example: typing.Any | None = None,\n    examples: (\n        typing.Mapping[\n            str,\n            oapi.oas.model.Reference\n            | oapi.oas.model.Example,\n        ]\n        | None\n    ) = None,\n    content: (\n        typing.Mapping[str, oapi.oas.model.MediaType] | None\n    ) = None,\n    type_: str | None = None,\n    default: typing.Any | None = None,\n    maximum: float | int | decimal.Decimal | None = None,\n    exclusive_maximum: bool | None = None,\n    minimum: float | int | decimal.Decimal | None = None,\n    exclusive_minimum: bool | None = None,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    pattern: str | None = None,\n    max_items: int | None = None,\n    min_items: int | None = None,\n    unique_items: bool | None = None,\n    enum: (\n        typing.Sequence[sob.abc.MarshallableTypes | None]\n        | None\n    ) = None,\n    format_: str | None = None,\n    collection_format: str | None = None,\n    items: oapi.oas.model.Items | None = None,\n    multiple_of: (\n        float | int | decimal.Decimal | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Header Object </p> <p>Attributes:</p> <ul> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>required</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>deprecated</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>allow_empty_value</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>style</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>explode</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>allow_reserved</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>schema</code>               (<code>oapi.oas.model.Reference | oapi.oas.model.Schema | None</code>)           \u2013            </li> <li> <code>example</code>               (<code>typing.Any | None</code>)           \u2013            </li> <li> <code>examples</code>               (<code>typing.Mapping[str, oapi.oas.model.Reference | oapi.oas.model.Example] | None</code>)           \u2013            </li> <li> <code>content</code>               (<code>typing.Mapping[str, oapi.oas.model.MediaType] | None</code>)           \u2013            </li> <li> <code>type_</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>default</code>               (<code>typing.Any | None</code>)           \u2013            </li> <li> <code>maximum</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            </li> <li> <code>exclusive_maximum</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>minimum</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            </li> <li> <code>exclusive_minimum</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>max_length</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>min_length</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>pattern</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>max_items</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>min_items</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>unique_items</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>enum</code>               (<code>typing.Sequence[sob.abc.MarshallableTypes | None] | None</code>)           \u2013            </li> <li> <code>format_</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>collection_format</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>items</code>               (<code>oapi.oas.model.Items | None</code>)           \u2013            </li> <li> <code>multiple_of</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    required: (\n        bool\n        | None\n    ) = None,\n    deprecated: (\n        bool\n        | None\n    ) = None,\n    allow_empty_value: (\n        bool\n        | None\n    ) = None,\n    style: (\n        str\n        | None\n    ) = None,\n    explode: (\n        bool\n        | None\n    ) = None,\n    allow_reserved: (\n        bool\n        | None\n    ) = None,\n    schema: (\n        Reference\n        | Schema\n        | None\n    ) = None,\n    example: (\n        typing.Any\n        | None\n    ) = None,\n    examples: (\n        typing.Mapping[\n            str,\n            Reference\n            | Example\n        ]\n        | None\n    ) = None,\n    content: (\n        typing.Mapping[\n            str,\n            MediaType\n        ]\n        | None\n    ) = None,\n    type_: (\n        str\n        | None\n    ) = None,\n    default: (\n        typing.Any\n        | None\n    ) = None,\n    maximum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    exclusive_maximum: (\n        bool\n        | None\n    ) = None,\n    minimum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    exclusive_minimum: (\n        bool\n        | None\n    ) = None,\n    max_length: (\n        int\n        | None\n    ) = None,\n    min_length: (\n        int\n        | None\n    ) = None,\n    pattern: (\n        str\n        | None\n    ) = None,\n    max_items: (\n        int\n        | None\n    ) = None,\n    min_items: (\n        int\n        | None\n    ) = None,\n    unique_items: (\n        bool\n        | None\n    ) = None,\n    enum: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None,\n    format_: (\n        str\n        | None\n    ) = None,\n    collection_format: (\n        str\n        | None\n    ) = None,\n    items: (\n        Items\n        | None\n    ) = None,\n    multiple_of: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None\n) -&gt; None:\n    self.description: (\n        str\n        | None\n    ) = description\n    self.required: (\n        bool\n        | None\n    ) = required\n    self.deprecated: (\n        bool\n        | None\n    ) = deprecated\n    self.allow_empty_value: (\n        bool\n        | None\n    ) = allow_empty_value\n    self.style: (\n        str\n        | None\n    ) = style\n    self.explode: (\n        bool\n        | None\n    ) = explode\n    self.allow_reserved: (\n        bool\n        | None\n    ) = allow_reserved\n    self.schema: (\n        Reference\n        | Schema\n        | None\n    ) = schema\n    self.example: (\n        typing.Any\n        | None\n    ) = example\n    self.examples: (\n        typing.Mapping[\n            str,\n            Reference\n            | Example\n        ]\n        | None\n    ) = examples\n    self.content: (\n        typing.Mapping[\n            str,\n            MediaType\n        ]\n        | None\n    ) = content\n    self.type_: (\n        str\n        | None\n    ) = type_\n    self.default: (\n        typing.Any\n        | None\n    ) = default\n    self.maximum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = maximum\n    self.exclusive_maximum: (\n        bool\n        | None\n    ) = exclusive_maximum\n    self.minimum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = minimum\n    self.exclusive_minimum: (\n        bool\n        | None\n    ) = exclusive_minimum\n    self.max_length: (\n        int\n        | None\n    ) = max_length\n    self.min_length: (\n        int\n        | None\n    ) = min_length\n    self.pattern: (\n        str\n        | None\n    ) = pattern\n    self.max_items: (\n        int\n        | None\n    ) = max_items\n    self.min_items: (\n        int\n        | None\n    ) = min_items\n    self.unique_items: (\n        bool\n        | None\n    ) = unique_items\n    self.enum: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = enum\n    self.format_: (\n        str\n        | None\n    ) = format_\n    self.collection_format: (\n        str\n        | None\n    ) = collection_format\n    self.items: (\n        Items\n        | None\n    ) = items\n    self.multiple_of: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = multiple_of\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Info","title":"Info","text":"<pre><code>Info(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    title: str | None = None,\n    description: str | None = None,\n    terms_of_service: str | None = None,\n    contact: oapi.oas.model.Contact | None = None,\n    license_: oapi.oas.model.License | None = None,\n    version: str | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Info Object </p> <p>Attributes:</p> <ul> <li> <code>title</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>terms_of_service</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>contact</code>               (<code>oapi.oas.model.Contact | None</code>)           \u2013            </li> <li> <code>license_</code>               (<code>oapi.oas.model.License | None</code>)           \u2013            </li> <li> <code>version</code>               (<code>str | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    title: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    terms_of_service: (\n        str\n        | None\n    ) = None,\n    contact: (\n        Contact\n        | None\n    ) = None,\n    license_: (\n        License\n        | None\n    ) = None,\n    version: (\n        str\n        | None\n    ) = None\n) -&gt; None:\n    self.title: (\n        str\n        | None\n    ) = title\n    self.description: (\n        str\n        | None\n    ) = description\n    self.terms_of_service: (\n        str\n        | None\n    ) = terms_of_service\n    self.contact: (\n        Contact\n        | None\n    ) = contact\n    self.license_: (\n        License\n        | None\n    ) = license_\n    self.version: (\n        str\n        | None\n    ) = version\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Items","title":"Items","text":"<pre><code>Items(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    type_: str | None = None,\n    format_: str | None = None,\n    items: oapi.oas.model.Items | None = None,\n    collection_format: str | None = None,\n    default: typing.Any | None = None,\n    maximum: float | int | decimal.Decimal | None = None,\n    exclusive_maximum: bool | None = None,\n    minimum: float | int | decimal.Decimal | None = None,\n    exclusive_minimum: bool | None = None,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    pattern: str | None = None,\n    max_items: int | None = None,\n    min_items: int | None = None,\n    unique_items: bool | None = None,\n    enum: (\n        typing.Sequence[sob.abc.MarshallableTypes | None]\n        | None\n    ) = None,\n    multiple_of: (\n        float | int | decimal.Decimal | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 2 Items Object </p> <p>Attributes:</p> <ul> <li> <code>type_</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>format_</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>items</code>               (<code>oapi.oas.model.Items | None</code>)           \u2013            </li> <li> <code>collection_format</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>default</code>               (<code>typing.Any | None</code>)           \u2013            </li> <li> <code>maximum</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            </li> <li> <code>exclusive_maximum</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>minimum</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            </li> <li> <code>exclusive_minimum</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>max_length</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>min_length</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>pattern</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>max_items</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>min_items</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>unique_items</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>enum</code>               (<code>typing.Sequence[sob.abc.MarshallableTypes | None] | None</code>)           \u2013            </li> <li> <code>multiple_of</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    type_: (\n        str\n        | None\n    ) = None,\n    format_: (\n        str\n        | None\n    ) = None,\n    items: (\n        Items\n        | None\n    ) = None,\n    collection_format: (\n        str\n        | None\n    ) = None,\n    default: (\n        typing.Any\n        | None\n    ) = None,\n    maximum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    exclusive_maximum: (\n        bool\n        | None\n    ) = None,\n    minimum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    exclusive_minimum: (\n        bool\n        | None\n    ) = None,\n    max_length: (\n        int\n        | None\n    ) = None,\n    min_length: (\n        int\n        | None\n    ) = None,\n    pattern: (\n        str\n        | None\n    ) = None,\n    max_items: (\n        int\n        | None\n    ) = None,\n    min_items: (\n        int\n        | None\n    ) = None,\n    unique_items: (\n        bool\n        | None\n    ) = None,\n    enum: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None,\n    multiple_of: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None\n) -&gt; None:\n    self.type_: (\n        str\n        | None\n    ) = type_\n    self.format_: (\n        str\n        | None\n    ) = format_\n    self.items: (\n        Items\n        | None\n    ) = items\n    self.collection_format: (\n        str\n        | None\n    ) = collection_format\n    self.default: (\n        typing.Any\n        | None\n    ) = default\n    self.maximum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = maximum\n    self.exclusive_maximum: (\n        bool\n        | None\n    ) = exclusive_maximum\n    self.minimum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = minimum\n    self.exclusive_minimum: (\n        bool\n        | None\n    ) = exclusive_minimum\n    self.max_length: (\n        int\n        | None\n    ) = max_length\n    self.min_length: (\n        int\n        | None\n    ) = min_length\n    self.pattern: (\n        str\n        | None\n    ) = pattern\n    self.max_items: (\n        int\n        | None\n    ) = max_items\n    self.min_items: (\n        int\n        | None\n    ) = min_items\n    self.unique_items: (\n        bool\n        | None\n    ) = unique_items\n    self.enum: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = enum\n    self.multiple_of: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = multiple_of\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.License","title":"License","text":"<pre><code>License(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: str | None = None,\n    url: str | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 License Object </p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>url</code>               (<code>str | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: (\n        str\n        | None\n    ) = None,\n    url: (\n        str\n        | None\n    ) = None\n) -&gt; None:\n    self.name: (\n        str\n        | None\n    ) = name\n    self.url: (\n        str\n        | None\n    ) = url\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.LinkObject","title":"LinkObject","text":"<pre><code>LinkObject(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    operation_ref: str | None = None,\n    operation_id: str | None = None,\n    parameters: (\n        typing.Mapping[\n            str, sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None,\n    request_body: typing.Any | None = None,\n    description: str | None = None,\n    server: oapi.oas.model.Server | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Link Object </p> <p>Attributes:</p> <ul> <li> <code>operation_ref</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>operation_id</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>parameters</code>               (<code>typing.Mapping[str, sob.abc.MarshallableTypes | None] | None</code>)           \u2013            </li> <li> <code>request_body</code>               (<code>typing.Any | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>server</code>               (<code>oapi.oas.model.Server | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    operation_ref: (\n        str\n        | None\n    ) = None,\n    operation_id: (\n        str\n        | None\n    ) = None,\n    parameters: (\n        typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None,\n    request_body: (\n        typing.Any\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    server: (\n        Server\n        | None\n    ) = None\n) -&gt; None:\n    self.operation_ref: (\n        str\n        | None\n    ) = operation_ref\n    self.operation_id: (\n        str\n        | None\n    ) = operation_id\n    self.parameters: (\n        typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = parameters\n    self.request_body: (\n        typing.Any\n        | None\n    ) = request_body\n    self.description: (\n        str\n        | None\n    ) = description\n    self.server: (\n        Server\n        | None\n    ) = server\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.MediaType","title":"MediaType","text":"<pre><code>MediaType(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    schema: (\n        oapi.oas.model.Reference\n        | oapi.oas.model.Schema\n        | None\n    ) = None,\n    example: typing.Any | None = None,\n    examples: (\n        typing.Mapping[\n            str,\n            oapi.oas.model.Reference\n            | oapi.oas.model.Example,\n        ]\n        | None\n    ) = None,\n    encoding: (\n        typing.Mapping[\n            str,\n            oapi.oas.model.Reference\n            | oapi.oas.model.Encoding,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Media Type Object </p> <p>Attributes:</p> <ul> <li> <code>schema</code>               (<code>oapi.oas.model.Reference | oapi.oas.model.Schema | None</code>)           \u2013            </li> <li> <code>example</code>               (<code>typing.Any | None</code>)           \u2013            </li> <li> <code>examples</code>               (<code>typing.Mapping[str, oapi.oas.model.Reference | oapi.oas.model.Example] | None</code>)           \u2013            </li> <li> <code>encoding</code>               (<code>typing.Mapping[str, oapi.oas.model.Reference | oapi.oas.model.Encoding] | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    schema: (\n        Reference\n        | Schema\n        | None\n    ) = None,\n    example: (\n        typing.Any\n        | None\n    ) = None,\n    examples: (\n        typing.Mapping[\n            str,\n            Reference\n            | Example\n        ]\n        | None\n    ) = None,\n    encoding: (\n        typing.Mapping[\n            str,\n            Reference\n            | Encoding\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.schema: (\n        Reference\n        | Schema\n        | None\n    ) = schema\n    self.example: (\n        typing.Any\n        | None\n    ) = example\n    self.examples: (\n        typing.Mapping[\n            str,\n            Reference\n            | Example\n        ]\n        | None\n    ) = examples\n    self.encoding: (\n        typing.Mapping[\n            str,\n            Reference\n            | Encoding\n        ]\n        | None\n    ) = encoding\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.OAuthFlow","title":"OAuthFlow","text":"<pre><code>OAuthFlow(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    authorization_url: str | None = None,\n    token_url: str | None = None,\n    refresh_url: str | None = None,\n    scopes: typing.Mapping[str, str] | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Parameter Object </p> <p>Attributes:</p> <ul> <li> <code>authorization_url</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>token_url</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>refresh_url</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>scopes</code>               (<code>typing.Mapping[str, str] | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    authorization_url: (\n        str\n        | None\n    ) = None,\n    token_url: (\n        str\n        | None\n    ) = None,\n    refresh_url: (\n        str\n        | None\n    ) = None,\n    scopes: (\n        typing.Mapping[\n            str,\n            str\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.authorization_url: (\n        str\n        | None\n    ) = authorization_url\n    self.token_url: (\n        str\n        | None\n    ) = token_url\n    self.refresh_url: (\n        str\n        | None\n    ) = refresh_url\n    self.scopes: (\n        typing.Mapping[\n            str,\n            str\n        ]\n        | None\n    ) = scopes\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.OAuthFlows","title":"OAuthFlows","text":"<pre><code>OAuthFlows(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    implicit: oapi.oas.model.OAuthFlow | None = None,\n    password: oapi.oas.model.OAuthFlow | None = None,\n    client_credentials: (\n        oapi.oas.model.OAuthFlow | None\n    ) = None,\n    authorization_code: (\n        oapi.oas.model.OAuthFlow | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 OAuth Flows Object </p> <p>Attributes:</p> <ul> <li> <code>implicit</code>               (<code>oapi.oas.model.OAuthFlow | None</code>)           \u2013            </li> <li> <code>password</code>               (<code>oapi.oas.model.OAuthFlow | None</code>)           \u2013            </li> <li> <code>client_credentials</code>               (<code>oapi.oas.model.OAuthFlow | None</code>)           \u2013            </li> <li> <code>authorization_code</code>               (<code>oapi.oas.model.OAuthFlow | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    implicit: (\n        OAuthFlow\n        | None\n    ) = None,\n    password: (\n        OAuthFlow\n        | None\n    ) = None,\n    client_credentials: (\n        OAuthFlow\n        | None\n    ) = None,\n    authorization_code: (\n        OAuthFlow\n        | None\n    ) = None\n) -&gt; None:\n    self.implicit: (\n        OAuthFlow\n        | None\n    ) = implicit\n    self.password: (\n        OAuthFlow\n        | None\n    ) = password\n    self.client_credentials: (\n        OAuthFlow\n        | None\n    ) = client_credentials\n    self.authorization_code: (\n        OAuthFlow\n        | None\n    ) = authorization_code\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.OpenAPI","title":"OpenAPI","text":"<pre><code>OpenAPI(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    openapi: str | None = None,\n    info: oapi.oas.model.Info | None = None,\n    json_schema_dialect: str | None = None,\n    host: str | None = None,\n    servers: (\n        typing.Sequence[oapi.oas.model.Server] | None\n    ) = None,\n    base_path: str | None = None,\n    schemes: typing.Sequence[str] | None = None,\n    tags: typing.Sequence[oapi.oas.model.Tag] | None = None,\n    paths: oapi.oas.model.Paths | None = None,\n    components: oapi.oas.model.Components | None = None,\n    consumes: typing.Sequence[str] | None = None,\n    swagger: str | None = None,\n    definitions: oapi.oas.model.Definitions | None = None,\n    security_definitions: (\n        oapi.oas.model.SecuritySchemes | None\n    ) = None,\n    produces: typing.Sequence[str] | None = None,\n    external_docs: (\n        oapi.oas.model.ExternalDocumentation | None\n    ) = None,\n    parameters: (\n        typing.Mapping[str, oapi.oas.model.Parameter] | None\n    ) = None,\n    responses: (\n        typing.Mapping[str, oapi.oas.model.Response] | None\n    ) = None,\n    security: (\n        typing.Sequence[oapi.oas.model.SecurityRequirement]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 OpenAPI (root) Object </p> <p>Attributes:</p> <ul> <li> <code>openapi</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>info</code>               (<code>oapi.oas.model.Info | None</code>)           \u2013            </li> <li> <code>json_schema_dialect</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>host</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>servers</code>               (<code>typing.Sequence[oapi.oas.model.Server] | None</code>)           \u2013            </li> <li> <code>base_path</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>schemes</code>               (<code>typing.Sequence[str] | None</code>)           \u2013            </li> <li> <code>tags</code>               (<code>typing.Sequence[oapi.oas.model.Tag] | None</code>)           \u2013            </li> <li> <code>paths</code>               (<code>oapi.oas.model.Paths | None</code>)           \u2013            </li> <li> <code>components</code>               (<code>oapi.oas.model.Components | None</code>)           \u2013            </li> <li> <code>consumes</code>               (<code>typing.Sequence[str] | None</code>)           \u2013            </li> <li> <code>swagger</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>definitions</code>               (<code>oapi.oas.model.Definitions | None</code>)           \u2013            </li> <li> <code>security_definitions</code>               (<code>oapi.oas.model.SecuritySchemes | None</code>)           \u2013            </li> <li> <code>produces</code>               (<code>typing.Sequence[str] | None</code>)           \u2013            </li> <li> <code>external_docs</code>               (<code>oapi.oas.model.ExternalDocumentation | None</code>)           \u2013            </li> <li> <code>parameters</code>               (<code>typing.Mapping[str, oapi.oas.model.Parameter] | None</code>)           \u2013            </li> <li> <code>responses</code>               (<code>typing.Mapping[str, oapi.oas.model.Response] | None</code>)           \u2013            </li> <li> <code>security</code>               (<code>typing.Sequence[oapi.oas.model.SecurityRequirement] | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    openapi: (\n        str\n        | None\n    ) = None,\n    info: (\n        Info\n        | None\n    ) = None,\n    json_schema_dialect: (\n        str\n        | None\n    ) = None,\n    host: (\n        str\n        | None\n    ) = None,\n    servers: (\n        typing.Sequence[\n            Server\n        ]\n        | None\n    ) = None,\n    base_path: (\n        str\n        | None\n    ) = None,\n    schemes: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    tags: (\n        typing.Sequence[\n            Tag\n        ]\n        | None\n    ) = None,\n    paths: (\n        Paths\n        | None\n    ) = None,\n    components: (\n        Components\n        | None\n    ) = None,\n    consumes: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    swagger: (\n        str\n        | None\n    ) = None,\n    definitions: (\n        Definitions\n        | None\n    ) = None,\n    security_definitions: (\n        SecuritySchemes\n        | None\n    ) = None,\n    produces: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    external_docs: (\n        ExternalDocumentation\n        | None\n    ) = None,\n    parameters: (\n        typing.Mapping[\n            str,\n            Parameter\n        ]\n        | None\n    ) = None,\n    responses: (\n        typing.Mapping[\n            str,\n            Response\n        ]\n        | None\n    ) = None,\n    security: (\n        typing.Sequence[\n            SecurityRequirement\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.openapi: (\n        str\n        | None\n    ) = openapi\n    self.info: (\n        Info\n        | None\n    ) = info\n    self.json_schema_dialect: (\n        str\n        | None\n    ) = json_schema_dialect\n    self.host: (\n        str\n        | None\n    ) = host\n    self.servers: (\n        typing.Sequence[\n            Server\n        ]\n        | None\n    ) = servers\n    self.base_path: (\n        str\n        | None\n    ) = base_path\n    self.schemes: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = schemes\n    self.tags: (\n        typing.Sequence[\n            Tag\n        ]\n        | None\n    ) = tags\n    self.paths: (\n        Paths\n        | None\n    ) = paths\n    self.components: (\n        Components\n        | None\n    ) = components\n    self.consumes: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = consumes\n    self.swagger: (\n        str\n        | None\n    ) = swagger\n    self.definitions: (\n        Definitions\n        | None\n    ) = definitions\n    self.security_definitions: (\n        SecuritySchemes\n        | None\n    ) = security_definitions\n    self.produces: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = produces\n    self.external_docs: (\n        ExternalDocumentation\n        | None\n    ) = external_docs\n    self.parameters: (\n        typing.Mapping[\n            str,\n            Parameter\n        ]\n        | None\n    ) = parameters\n    self.responses: (\n        typing.Mapping[\n            str,\n            Response\n        ]\n        | None\n    ) = responses\n    self.security: (\n        typing.Sequence[\n            SecurityRequirement\n        ]\n        | None\n    ) = security\n    super().__init__(_data)\n    version: str = self.openapi or self.swagger or \"\"\n    if version:\n        sob.version_model(self, \"openapi\", version)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Operation","title":"Operation","text":"<pre><code>Operation(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    tags: typing.Sequence[str] | None = None,\n    summary: str | None = None,\n    description: str | None = None,\n    external_docs: (\n        oapi.oas.model.ExternalDocumentation | None\n    ) = None,\n    operation_id: str | None = None,\n    consumes: typing.Sequence[str] | None = None,\n    produces: typing.Sequence[str] | None = None,\n    parameters: (\n        typing.Sequence[\n            oapi.oas.model.Reference\n            | oapi.oas.model.Parameter\n        ]\n        | None\n    ) = None,\n    request_body: (\n        oapi.oas.model.Reference\n        | oapi.oas.model.RequestBody\n        | None\n    ) = None,\n    responses: oapi.oas.model.Responses | None = None,\n    callbacks: oapi.oas.model.Callbacks | None = None,\n    schemes: typing.Sequence[str] | None = None,\n    deprecated: bool | None = None,\n    security: (\n        typing.Sequence[oapi.oas.model.SecurityRequirement]\n        | None\n    ) = None,\n    servers: (\n        typing.Sequence[oapi.oas.model.Server] | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>Open API 3 Operation Object </p> <p>Describes a single API operation on a path.</p> <p>Attributes:</p> <ul> <li> <code>tags</code>               (<code>typing.Sequence[str] | None</code>)           \u2013            <p>A list of tags for API documentation control. Tags can be used for logical grouping of operations by resources or any other qualifier.</p> </li> <li> <code>summary</code>               (<code>str | None</code>)           \u2013            <p>A short summary of what the operation does.</p> </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            <p>A verbose explanation of the operation behavior. <code>CommonMark &lt;http://spec.commonmark.org&gt;</code> syntax may be used for rich text representation.</p> </li> <li> <code>external_docs</code>               (<code>oapi.oas.model.ExternalDocumentation | None</code>)           \u2013            <p>Additional external documentation for this operation.</p> </li> <li> <code>operation_id</code>               (<code>str | None</code>)           \u2013            <p>Unique string used to identify the operation. The ID must be unique among all operations described in the API. Tools and libraries may use the <code>operation_id</code> to uniquely identify an operation, therefore, it is recommended to follow common programming naming conventions.</p> </li> <li> <code>parameters</code>               (<code>typing.Sequence[oapi.oas.model.Reference | oapi.oas.model.Parameter] | None</code>)           \u2013            <p>A list of parameters that are applicable for this operation. If a parameter is already defined at the <code>PathItem</code>, the new definition will override it, but can never remove it.</p> </li> <li> <code>request_body</code>               (<code>oapi.oas.model.Reference | oapi.oas.model.RequestBody | None</code>)           \u2013            <p>The request body applicable for this operation. The requestBody is only supported in HTTP methods where the HTTP 1.1 specification <code>RFC7231 &lt;https://tools.ietf.org/html/rfc7231#section-4.3.1&gt;</code> has explicitly defined semantics for request bodies.</p> </li> <li> <code>responses</code>               (<code>oapi.oas.model.Responses | None</code>)           \u2013            <p>A mapping of HTTP response codes to <code>Response</code> objects.</p> </li> <li> <code>callbacks</code>               (<code>oapi.oas.model.Callbacks | None</code>)           \u2013            </li> <li> <code>deprecated</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>security</code>               (<code>typing.Sequence[oapi.oas.model.SecurityRequirement] | None</code>)           \u2013            </li> <li> <code>servers</code>               (<code>typing.Sequence[oapi.oas.model.Server] | None</code>)           \u2013            </li> <li> <code>produces</code>               (<code>typing.Sequence[str] | None</code>)           \u2013            <p>(OpenAPI 2x only)</p> </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    tags: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    summary: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    external_docs: (\n        ExternalDocumentation\n        | None\n    ) = None,\n    operation_id: (\n        str\n        | None\n    ) = None,\n    consumes: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    produces: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    parameters: (\n        typing.Sequence[\n            Reference\n            | Parameter\n        ]\n        | None\n    ) = None,\n    request_body: (\n        Reference\n        | RequestBody\n        | None\n    ) = None,\n    responses: (\n        Responses\n        | None\n    ) = None,\n    callbacks: (\n        Callbacks\n        | None\n    ) = None,\n    schemes: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    deprecated: (\n        bool\n        | None\n    ) = None,\n    security: (\n        typing.Sequence[\n            SecurityRequirement\n        ]\n        | None\n    ) = None,\n    servers: (\n        typing.Sequence[\n            Server\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.tags: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = tags\n    self.summary: (\n        str\n        | None\n    ) = summary\n    self.description: (\n        str\n        | None\n    ) = description\n    self.external_docs: (\n        ExternalDocumentation\n        | None\n    ) = external_docs\n    self.operation_id: (\n        str\n        | None\n    ) = operation_id\n    self.consumes: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = consumes\n    self.produces: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = produces\n    self.parameters: (\n        typing.Sequence[\n            Reference\n            | Parameter\n        ]\n        | None\n    ) = parameters\n    self.request_body: (\n        Reference\n        | RequestBody\n        | None\n    ) = request_body\n    self.responses: (\n        Responses\n        | None\n    ) = responses\n    self.callbacks: (\n        Callbacks\n        | None\n    ) = callbacks\n    self.schemes: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = schemes\n    self.deprecated: (\n        bool\n        | None\n    ) = deprecated\n    self.security: (\n        typing.Sequence[\n            SecurityRequirement\n        ]\n        | None\n    ) = security\n    self.servers: (\n        typing.Sequence[\n            Server\n        ]\n        | None\n    ) = servers\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Parameter","title":"Parameter","text":"<pre><code>Parameter(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: str | None = None,\n    in_: str | None = None,\n    description: str | None = None,\n    required: bool | None = None,\n    deprecated: bool | None = None,\n    allow_empty_value: bool | None = None,\n    style: str | None = None,\n    explode: bool | None = None,\n    allow_reserved: bool | None = None,\n    schema: (\n        oapi.oas.model.Reference\n        | oapi.oas.model.Schema\n        | None\n    ) = None,\n    example: typing.Any | None = None,\n    examples: (\n        typing.Mapping[\n            str,\n            oapi.oas.model.Reference\n            | oapi.oas.model.Example,\n        ]\n        | None\n    ) = None,\n    content: (\n        typing.Mapping[str, oapi.oas.model.MediaType] | None\n    ) = None,\n    type_: str | None = None,\n    default: typing.Any | None = None,\n    maximum: float | int | decimal.Decimal | None = None,\n    exclusive_maximum: bool | None = None,\n    minimum: float | int | decimal.Decimal | None = None,\n    exclusive_minimum: bool | None = None,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    pattern: str | None = None,\n    max_items: int | None = None,\n    min_items: int | None = None,\n    unique_items: bool | None = None,\n    enum: (\n        typing.Sequence[sob.abc.MarshallableTypes | None]\n        | None\n    ) = None,\n    format_: str | None = None,\n    collection_format: str | None = None,\n    items: oapi.oas.model.Items | None = None,\n    multiple_of: (\n        float | int | decimal.Decimal | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Parameter Object  | OpenAPI 2 Parameter Object </p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>in_</code>               (<code>str | None</code>)           \u2013            <p>\"path\", \"query\", \"header\", or \"cookie\"</p> </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>required</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>deprecated</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>allow_empty_value</code>               (<code>bool | None</code>)           \u2013            <p>Sets the ability to pass empty-valued parameters. This is valid only for query parameters and allows sending a parameter with an empty value. The default value is <code>False</code>. If <code>style</code> is used, and if <code>behavior</code> is inapplicable (cannot be serialized), the value of <code>allow_empty_value</code> will be ignored.</p> </li> <li> <code>style</code>               (<code>str | None</code>)           \u2013            <p>Describes how the parameter value will be serialized, depending on the type of the parameter value (see: Parameter Serialization ). Valid values include: \"matrix\", \"label\", \"form\", \"simple\", \"spaceDelimited\", \"pipeDelimited\", \"deepObject\", and \"dotObject\". The default values vary by location (<code>in_</code>). For \"query\": \"form\", path: \"simple\", header: \"simple\", and cookie: \"form\". The \"dotObject\" style is identical to \"deepObject\" except that <code>object.attribute</code> notation is used instead of <code>object[attribute]</code> notation.</p> </li> <li> <code>explode</code>               (<code>bool | None</code>)           \u2013            <p>When this is <code>True</code>, array or object parameter values generate separate parameters for each value of the array or name-value pair of the map. For other value_types of parameters this property has no effect. When <code>style</code> is \"form\", the default value is <code>True</code>. For all other styles, the default value is <code>False</code>.</p> </li> <li> <code>allow_reserved</code>               (<code>bool | None</code>)           \u2013            <p>Determines whether the parameter value SHOULD allow reserved characters :/?#[]@!$&amp;'()*+,;= (as defined by RFC3986 to be included without percent-encoding. This property only applies to \"query\" parameters. The default value is <code>False</code>.</p> </li> <li> <code>schema</code>               (<code>oapi.oas.model.Reference | oapi.oas.model.Schema | None</code>)           \u2013            <p>The schema defining the type used for the parameter.</p> </li> <li> <code>example</code>               (<code>typing.Any | None</code>)           \u2013            <p>An example of the parameter's potential value\u2014see Working With Examples . Either an <code>example</code> or <code>examples</code> parameter may be provided, but not both.</p> </li> <li> <code>examples</code>               (<code>typing.Mapping[str, oapi.oas.model.Reference | oapi.oas.model.Example] | None</code>)           \u2013            <p>Examples of the parameter's potential values\u2014see Working With Examples . Either an <code>example</code> or <code>examples</code> parameter may be provided, but not both.</p> </li> <li> <code>content</code>               (<code>typing.Mapping[str, oapi.oas.model.MediaType] | None</code>)           \u2013            <p>A mapping with a media type name and the object describing it. The mapping must only contain one entry. See Fixed fields for use with content .</p> </li> <li> <code>type_</code>               (<code>str | None</code>)           \u2013            <p>(Open API 2x only)</p> </li> <li> <code>enum</code>               (<code>typing.Sequence[sob.abc.MarshallableTypes | None] | None</code>)           \u2013            <p>(Open API 2x only)</p> </li> <li> <code>collection_format</code>               (<code>str | None</code>)           \u2013            <p>(Open API 2x only) Determines the format of the array if <code>type_ == \"array\"</code>. Possible values include:</p> <ul> <li>csv: comma separated values foo,bar.</li> <li>ssv: space separated values foo bar.</li> <li>tsv: tab separated values foo    bar.</li> <li>pipes: pipe separated values foo|bar.</li> <li>multi: corresponds to multiple parameter instances instead of     multiple values for a single instance foo=bar&amp;foo=baz. This     is valid only for parameters in \"query\" or \"formData\".</li> </ul> </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: (\n        str\n        | None\n    ) = None,\n    in_: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    required: (\n        bool\n        | None\n    ) = None,\n    deprecated: (\n        bool\n        | None\n    ) = None,\n    allow_empty_value: (\n        bool\n        | None\n    ) = None,\n    style: (\n        str\n        | None\n    ) = None,\n    explode: (\n        bool\n        | None\n    ) = None,\n    allow_reserved: (\n        bool\n        | None\n    ) = None,\n    schema: (\n        Reference\n        | Schema\n        | None\n    ) = None,\n    example: (\n        typing.Any\n        | None\n    ) = None,\n    examples: (\n        typing.Mapping[\n            str,\n            Reference\n            | Example\n        ]\n        | None\n    ) = None,\n    content: (\n        typing.Mapping[\n            str,\n            MediaType\n        ]\n        | None\n    ) = None,\n    type_: (\n        str\n        | None\n    ) = None,\n    default: (\n        typing.Any\n        | None\n    ) = None,\n    maximum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    exclusive_maximum: (\n        bool\n        | None\n    ) = None,\n    minimum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    exclusive_minimum: (\n        bool\n        | None\n    ) = None,\n    max_length: (\n        int\n        | None\n    ) = None,\n    min_length: (\n        int\n        | None\n    ) = None,\n    pattern: (\n        str\n        | None\n    ) = None,\n    max_items: (\n        int\n        | None\n    ) = None,\n    min_items: (\n        int\n        | None\n    ) = None,\n    unique_items: (\n        bool\n        | None\n    ) = None,\n    enum: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None,\n    format_: (\n        str\n        | None\n    ) = None,\n    collection_format: (\n        str\n        | None\n    ) = None,\n    items: (\n        Items\n        | None\n    ) = None,\n    multiple_of: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None\n) -&gt; None:\n    self.name: (\n        str\n        | None\n    ) = name\n    self.in_: (\n        str\n        | None\n    ) = in_\n    self.description: (\n        str\n        | None\n    ) = description\n    self.required: (\n        bool\n        | None\n    ) = required\n    self.deprecated: (\n        bool\n        | None\n    ) = deprecated\n    self.allow_empty_value: (\n        bool\n        | None\n    ) = allow_empty_value\n    self.style: (\n        str\n        | None\n    ) = style\n    self.explode: (\n        bool\n        | None\n    ) = explode\n    self.allow_reserved: (\n        bool\n        | None\n    ) = allow_reserved\n    self.schema: (\n        Reference\n        | Schema\n        | None\n    ) = schema\n    self.example: (\n        typing.Any\n        | None\n    ) = example\n    self.examples: (\n        typing.Mapping[\n            str,\n            Reference\n            | Example\n        ]\n        | None\n    ) = examples\n    self.content: (\n        typing.Mapping[\n            str,\n            MediaType\n        ]\n        | None\n    ) = content\n    self.type_: (\n        str\n        | None\n    ) = type_\n    self.default: (\n        typing.Any\n        | None\n    ) = default\n    self.maximum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = maximum\n    self.exclusive_maximum: (\n        bool\n        | None\n    ) = exclusive_maximum\n    self.minimum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = minimum\n    self.exclusive_minimum: (\n        bool\n        | None\n    ) = exclusive_minimum\n    self.max_length: (\n        int\n        | None\n    ) = max_length\n    self.min_length: (\n        int\n        | None\n    ) = min_length\n    self.pattern: (\n        str\n        | None\n    ) = pattern\n    self.max_items: (\n        int\n        | None\n    ) = max_items\n    self.min_items: (\n        int\n        | None\n    ) = min_items\n    self.unique_items: (\n        bool\n        | None\n    ) = unique_items\n    self.enum: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = enum\n    self.format_: (\n        str\n        | None\n    ) = format_\n    self.collection_format: (\n        str\n        | None\n    ) = collection_format\n    self.items: (\n        Items\n        | None\n    ) = items\n    self.multiple_of: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = multiple_of\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.PathItem","title":"PathItem","text":"<pre><code>PathItem(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    summary: str | None = None,\n    description: str | None = None,\n    get: oapi.oas.model.Operation | None = None,\n    put: oapi.oas.model.Operation | None = None,\n    post: oapi.oas.model.Operation | None = None,\n    delete: oapi.oas.model.Operation | None = None,\n    options: oapi.oas.model.Operation | None = None,\n    head: oapi.oas.model.Operation | None = None,\n    patch: oapi.oas.model.Operation | None = None,\n    trace: oapi.oas.model.Operation | None = None,\n    servers: (\n        typing.Sequence[oapi.oas.model.Server] | None\n    ) = None,\n    parameters: (\n        typing.Sequence[\n            oapi.oas.model.Reference\n            | oapi.oas.model.Parameter\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Path Item Object </p> <p>Attributes:</p> <ul> <li> <code>summary</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>get</code>               (<code>oapi.oas.model.Operation | None</code>)           \u2013            </li> <li> <code>put</code>               (<code>oapi.oas.model.Operation | None</code>)           \u2013            </li> <li> <code>post</code>               (<code>oapi.oas.model.Operation | None</code>)           \u2013            </li> <li> <code>delete</code>               (<code>oapi.oas.model.Operation | None</code>)           \u2013            </li> <li> <code>options</code>               (<code>oapi.oas.model.Operation | None</code>)           \u2013            </li> <li> <code>head</code>               (<code>oapi.oas.model.Operation | None</code>)           \u2013            </li> <li> <code>patch</code>               (<code>oapi.oas.model.Operation | None</code>)           \u2013            </li> <li> <code>trace</code>               (<code>oapi.oas.model.Operation | None</code>)           \u2013            </li> <li> <code>servers</code>               (<code>typing.Sequence[oapi.oas.model.Server] | None</code>)           \u2013            </li> <li> <code>parameters</code>               (<code>typing.Sequence[oapi.oas.model.Reference | oapi.oas.model.Parameter] | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    summary: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    get: (\n        Operation\n        | None\n    ) = None,\n    put: (\n        Operation\n        | None\n    ) = None,\n    post: (\n        Operation\n        | None\n    ) = None,\n    delete: (\n        Operation\n        | None\n    ) = None,\n    options: (\n        Operation\n        | None\n    ) = None,\n    head: (\n        Operation\n        | None\n    ) = None,\n    patch: (\n        Operation\n        | None\n    ) = None,\n    trace: (\n        Operation\n        | None\n    ) = None,\n    servers: (\n        typing.Sequence[\n            Server\n        ]\n        | None\n    ) = None,\n    parameters: (\n        typing.Sequence[\n            Reference\n            | Parameter\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.summary: (\n        str\n        | None\n    ) = summary\n    self.description: (\n        str\n        | None\n    ) = description\n    self.get: (\n        Operation\n        | None\n    ) = get\n    self.put: (\n        Operation\n        | None\n    ) = put\n    self.post: (\n        Operation\n        | None\n    ) = post\n    self.delete: (\n        Operation\n        | None\n    ) = delete\n    self.options: (\n        Operation\n        | None\n    ) = options\n    self.head: (\n        Operation\n        | None\n    ) = head\n    self.patch: (\n        Operation\n        | None\n    ) = patch\n    self.trace: (\n        Operation\n        | None\n    ) = trace\n    self.servers: (\n        typing.Sequence[\n            Server\n        ]\n        | None\n    ) = servers\n    self.parameters: (\n        typing.Sequence[\n            Reference\n            | Parameter\n        ]\n        | None\n    ) = parameters\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Reference","title":"Reference","text":"<pre><code>Reference(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    ref: str | None = None,\n    summary: str | None = None,\n    description: str | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Reference Object </p> <p>Attributes:</p> <ul> <li> <code>ref</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>summary</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    ref: (\n        str\n        | None\n    ) = None,\n    summary: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None\n) -&gt; None:\n    self.ref: (\n        str\n        | None\n    ) = ref\n    self.summary: (\n        str\n        | None\n    ) = summary\n    self.description: (\n        str\n        | None\n    ) = description\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.RequestBody","title":"RequestBody","text":"<pre><code>RequestBody(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    description: str | None = None,\n    content: (\n        typing.Mapping[str, oapi.oas.model.MediaType] | None\n    ) = None,\n    required: bool | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Request Body Object </p> <p>Attributes:</p> <ul> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>content</code>               (<code>typing.Mapping[str, oapi.oas.model.MediaType] | None</code>)           \u2013            </li> <li> <code>required</code>               (<code>bool | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    content: (\n        typing.Mapping[\n            str,\n            MediaType\n        ]\n        | None\n    ) = None,\n    required: (\n        bool\n        | None\n    ) = None\n) -&gt; None:\n    self.description: (\n        str\n        | None\n    ) = description\n    self.content: (\n        typing.Mapping[\n            str,\n            MediaType\n        ]\n        | None\n    ) = content\n    self.required: (\n        bool\n        | None\n    ) = required\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Response","title":"Response","text":"<pre><code>Response(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    description: str | None = None,\n    schema: (\n        oapi.oas.model.Reference\n        | oapi.oas.model.Schema\n        | None\n    ) = None,\n    headers: (\n        typing.Mapping[\n            str,\n            oapi.oas.model.Reference\n            | oapi.oas.model.Header,\n        ]\n        | None\n    ) = None,\n    examples: (\n        typing.Mapping[\n            str, sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None,\n    content: (\n        typing.Mapping[\n            str,\n            oapi.oas.model.Reference\n            | oapi.oas.model.MediaType,\n        ]\n        | None\n    ) = None,\n    links: (\n        typing.Mapping[\n            str,\n            oapi.oas.model.Reference\n            | oapi.oas.model.LinkObject,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Response Object </p> <p>Attributes:</p> <ul> <li> <code>description</code>               (<code>str | None</code>)           \u2013            <p>A short description of the response. CommonMark syntax may be used for rich text representation.</p> </li> <li> <code>headers</code>               (<code>typing.Mapping[str, oapi.oas.model.Reference | oapi.oas.model.Header] | None</code>)           \u2013            <p>Maps a header name to its definition (mappings are case-insensitive).</p> </li> <li> <code>content</code>               (<code>typing.Mapping[str, oapi.oas.model.Reference | oapi.oas.model.MediaType] | None</code>)           \u2013            <p>A mapping of media value_types to <code>MediaType</code> instances describing potential payloads.</p> </li> <li> <code>links</code>               (<code>typing.Mapping[str, oapi.oas.model.Reference | oapi.oas.model.LinkObject] | None</code>)           \u2013            <p>A map of operations links that can be followed from the response.</p> </li> <li> <code>examples</code>               (<code>typing.Mapping[str, sob.abc.MarshallableTypes | None] | None</code>)           \u2013            <p>Examples responses</p> </li> <li> <code>schema</code>               (<code>oapi.oas.model.Reference | oapi.oas.model.Schema | None</code>)           \u2013            <p>(OpenAPI 2x only)</p> </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    schema: (\n        Reference\n        | Schema\n        | None\n    ) = None,\n    headers: (\n        typing.Mapping[\n            str,\n            Reference\n            | Header\n        ]\n        | None\n    ) = None,\n    examples: (\n        typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None,\n    content: (\n        typing.Mapping[\n            str,\n            Reference\n            | MediaType\n        ]\n        | None\n    ) = None,\n    links: (\n        typing.Mapping[\n            str,\n            Reference\n            | LinkObject\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.description: (\n        str\n        | None\n    ) = description\n    self.schema: (\n        Reference\n        | Schema\n        | None\n    ) = schema\n    self.headers: (\n        typing.Mapping[\n            str,\n            Reference\n            | Header\n        ]\n        | None\n    ) = headers\n    self.examples: (\n        typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = examples\n    self.content: (\n        typing.Mapping[\n            str,\n            Reference\n            | MediaType\n        ]\n        | None\n    ) = content\n    self.links: (\n        typing.Mapping[\n            str,\n            Reference\n            | LinkObject\n        ]\n        | None\n    ) = links\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Schema","title":"Schema","text":"<pre><code>Schema(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    title: str | None = None,\n    description: str | None = None,\n    multiple_of: (\n        float | int | decimal.Decimal | None\n    ) = None,\n    maximum: float | int | decimal.Decimal | None = None,\n    exclusive_maximum: bool | None = None,\n    minimum: float | int | decimal.Decimal | None = None,\n    exclusive_minimum: bool | None = None,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    pattern: str | None = None,\n    max_items: int | None = None,\n    min_items: int | None = None,\n    unique_items: bool | None = None,\n    items: (\n        oapi.oas.model.Reference\n        | oapi.oas.model.Schema\n        | typing.Sequence[\n            oapi.oas.model.Reference | oapi.oas.model.Schema\n        ]\n        | None\n    ) = None,\n    max_properties: int | None = None,\n    min_properties: int | None = None,\n    properties: oapi.oas.model.Properties | None = None,\n    additional_properties: (\n        oapi.oas.model.Reference\n        | oapi.oas.model.Schema\n        | bool\n        | None\n    ) = None,\n    enum: (\n        typing.Sequence[sob.abc.MarshallableTypes | None]\n        | None\n    ) = None,\n    const: typing.Any | None = None,\n    type_: str | None = None,\n    format_: str | None = None,\n    required: typing.Sequence[str] | None = None,\n    all_of: (\n        typing.Sequence[\n            oapi.oas.model.Reference | oapi.oas.model.Schema\n        ]\n        | None\n    ) = None,\n    any_of: (\n        typing.Sequence[\n            oapi.oas.model.Reference | oapi.oas.model.Schema\n        ]\n        | None\n    ) = None,\n    one_of: (\n        typing.Sequence[\n            oapi.oas.model.Reference | oapi.oas.model.Schema\n        ]\n        | None\n    ) = None,\n    is_not: (\n        oapi.oas.model.Reference\n        | oapi.oas.model.Schema\n        | None\n    ) = None,\n    definitions: typing.Any | None = None,\n    default: typing.Any | None = None,\n    discriminator: (\n        oapi.oas.model.Discriminator | str | None\n    ) = None,\n    read_only: bool | None = None,\n    write_only: bool | None = None,\n    xml: oapi.oas.model.XML | None = None,\n    external_docs: (\n        oapi.oas.model.ExternalDocumentation | None\n    ) = None,\n    example: typing.Any | None = None,\n    deprecated: bool | None = None,\n    links: (\n        typing.Sequence[oapi.oas.model.Link] | None\n    ) = None,\n    nullable: bool | None = None,\n    content_encoding: str | None = None,\n    content_media_type: str | None = None,\n    examples: (\n        typing.Sequence[sob.abc.MarshallableTypes | None]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>Open API 3 Schema Object  | JSON Schema</p> <p>Attributes:</p> <ul> <li> <code>title</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>multiple_of</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            <p>The numeric value this schema describes should be divisible by this number.</p> </li> <li> <code>maximum</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            <p>The number this schema describes should be less than or equal to this value, or less than this value, depending on the value of <code>exclusive_maximum</code>.</p> </li> <li> <code>exclusive_maximum</code>               (<code>bool | None</code>)           \u2013            <p>If <code>True</code>, the numeric instance described by this schema must be less than <code>maximum</code>. If <code>False</code>, the numeric instance described by this schema can be less than or equal to <code>maximum</code>.</p> </li> <li> <code>minimum</code>               (<code>float | int | decimal.Decimal | None</code>)           \u2013            <p>The number this schema describes should be greater than or equal to this value, or greater than this value, depending on the value of <code>exclusive_minimum</code>.</p> </li> <li> <code>exclusive_minimum</code>               (<code>bool | None</code>)           \u2013            <p>If <code>True</code>, the numeric instance described by this schema must be greater than <code>minimum</code>. If <code>False</code>, the numeric instance described by this schema can be greater than or equal to <code>minimum</code>.</p> </li> <li> <code>max_length</code>               (<code>int | None</code>)           \u2013            <p>The number of characters in the string instance described by this schema must be less than, or equal to, the value of this property.</p> </li> <li> <code>min_length</code>               (<code>int | None</code>)           \u2013            <p>The number of characters in the string instance described by this schema must be greater than, or equal to, the value of this property.</p> </li> <li> <code>pattern</code>               (<code>str | None</code>)           \u2013            <p>The string instance described by this schema should match this regular expression (ECMA 262).</p> </li> <li> <code>items</code>               (<code>oapi.oas.model.Reference | oapi.oas.model.Schema | typing.Sequence[oapi.oas.model.Reference | oapi.oas.model.Schema] | None</code>)           \u2013            <ul> <li>If <code>items</code> is a sub-schema--each item in the array instance     described by this schema should be valid as described by this     sub-schema.</li> <li>If <code>items</code> is a sequence of sub-schemas, the array instance     described by this schema should be equal in length to this     sequence, and each value should be valid as described by the     sub-schema at the corresponding index within this sequence of     sub-schemas.</li> </ul> </li> <li> <code>max_items</code>               (<code>int | None</code>)           \u2013            <p>The array instance described by this schema should contain no more than this number of items.</p> </li> <li> <code>min_items</code>               (<code>int | None</code>)           \u2013            <p>The array instance described by this schema should contain at least this number of items.</p> </li> <li> <code>unique_items</code>               (<code>bool | None</code>)           \u2013            <p>The array instance described by this schema should contain only unique items.</p> </li> <li> <code>max_properties</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>min_properties</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>properties</code>               (<code>oapi.oas.model.Properties | None</code>)           \u2013            <p>Any properties of the object instance described by this schema which correspond to a name in this mapping should be valid as described by the sub-schema corresponding to that name.</p> </li> <li> <code>additional_properties</code>               (<code>oapi.oas.model.Reference | oapi.oas.model.Schema | bool | None</code>)           \u2013            <ul> <li>If <code>additional_properties</code> is <code>True</code>\u2014properties may be     present in the object described by this schema with names which     do not match those in <code>properties</code>.</li> <li>If <code>additional_properties</code> is <code>False</code>\u2014all properties     present in the object described by this schema must correspond     to a property matched in <code>properties</code>.</li> <li>If <code>additional_properties</code> is a schema object,     all properties not described in <code>properties</code> must have     values matching the <code>additional_properties</code> schema.</li> </ul> </li> <li> <code>enum</code>               (<code>typing.Sequence[sob.abc.MarshallableTypes | None] | None</code>)           \u2013            <p>The value/instance described by this schema should be among those in this sequence.</p> </li> <li> <code>const</code>               (<code>typing.Any | None</code>)           \u2013            <p>The value/instance described by this schema should be exactly this value.</p> </li> <li> <code>type_</code>               (<code>str | None</code>)           \u2013            <p>See [OpenAPI 3 Data Types (https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3. 1.1.md#data-types)], Swagger - OpenAPI 3 Data Types  and OpenAPI 2 Data Types </p> <ul> <li>\"boolean\"</li> <li>\"object\"</li> <li>\"array\"</li> <li>\"number\"</li> <li>\"string\"</li> <li>\"integer\"</li> <li>\"file\"</li> </ul> </li> <li> <code>format_</code>               (<code>str | None</code>)           \u2013            <p>See Open API 3 Data Type Format </p> <ul> <li>\"date-time\":     A date and time in the format YYYY-MM-DDThh:mm:ss.sTZD     (eg 1997-07-16T19:20:30.45+01:00),     YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00), or     YYYY-MM-DDThh:mmTZD (eg 1997-07-16T19:20+01:00).</li> <li>\"email\"</li> <li>\"hostname\"</li> <li>\"ipv4\"</li> <li>\"ipv6\"</li> <li>\"uri\"</li> <li>\"uriref\": A URI or a relative reference.</li> </ul> </li> <li> <code>all_of</code>               (<code>typing.Sequence[oapi.oas.model.Reference | oapi.oas.model.Schema] | None</code>)           \u2013            <p>The value/instance described by the schema should also be valid as described by all sub-schemas in this sequence.</p> </li> <li> <code>any_of</code>               (<code>typing.Sequence[oapi.oas.model.Reference | oapi.oas.model.Schema] | None</code>)           \u2013            <p>The value/instance described by the schema should also be valid as described in at least one of the sub-schemas in this sequence.</p> </li> <li> <code>one_of</code>               (<code>typing.Sequence[oapi.oas.model.Reference | oapi.oas.model.Schema] | None</code>)           \u2013            <p>The value/instance described by the schema should also be valid as described in one (but only one) of the sub-schemas in this sequence.</p> </li> <li> <code>is_not</code>               (<code>oapi.oas.model.Reference | oapi.oas.model.Schema | None</code>)           \u2013            <p>The value/instance described by this schema should * not* be valid as described by this sub-schema.</p> </li> <li> <code>definitions</code>               (<code>typing.Any | None</code>)           \u2013            <p>Schema}): A dictionary of sub-schemas, stored for the purpose of referencing these sub-schemas elsewhere in the schema.</p> </li> <li> <code>required</code>               (<code>typing.Sequence[str] | None</code>)           \u2013            <p>A list of attributes which must be present on the object instance described by this schema.</p> </li> <li> <code>default</code>               (<code>typing.Any | None</code>)           \u2013            <p>The value presumed if the value/instance described by this schema is absent.</p> </li> <li> <code>content_media_type</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>content_encoding</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>examples</code>               (<code>typing.Sequence[sob.abc.MarshallableTypes | None] | None</code>)           \u2013            <p>A list of valid examples of this object</p> </li> <li> <code>nullable</code>               (<code>bool | None</code>)           \u2013            <p>If <code>True</code>, the value/instance described by this schema may be a null value (<code>None</code>). (Specific to OpenAPI, not part of the JSON Schema)</p> </li> <li> <code>discriminator</code>               (<code>oapi.oas.model.Discriminator | str | None</code>)           \u2013            <p>Adds support for polymorphism. (Specific to OpenAPI, not part of the JSON Schema)</p> </li> <li> <code>read_only</code>               (<code>bool | None</code>)           \u2013            <p>If <code>True</code>, the property described may be returned as part of a response, but should not be part of a request (Specific to OpenAPI, not part of the JSON Schema).</p> </li> <li> <code>write_only</code>               (<code>bool | None</code>)           \u2013            <p>If <code>True</code>, the property described may be sent as part of a request, but should not be returned as part of a response (Specific to OpenAPI, not part of the JSON Schema).</p> </li> <li> <code>xml</code>               (<code>oapi.oas.model.XML | None</code>)           \u2013            <p>Provides additional information describing XML representation of the property described by this schema (Specific to OpenAPI, not part of the JSON Schema).</p> </li> <li> <code>external_docs</code>               (<code>oapi.oas.model.ExternalDocumentation | None</code>)           \u2013            <p>(Specific to OpenAPI, not part of the JSON Schema)</p> </li> <li> <code>example</code>               (<code>typing.Any | None</code>)           \u2013            <p>(Specific to OpenAPI, not part of the JSON Schema)</p> </li> <li> <code>definitions</code>               (<code>typing.Any | None</code>)           \u2013            <p>(Specific to OpenAPI, not part of the JSON Schema)</p> </li> <li> <code>depracated</code>               (<code>typing.Any | None</code>)           \u2013            <p>If <code>True</code>, the property or instance described by this schema should be phased out, as if will no longer be supported in future versions (Specific to OpenAPI, not part of the JSON Schema).</p> </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    title: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    multiple_of: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    maximum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    exclusive_maximum: (\n        bool\n        | None\n    ) = None,\n    minimum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = None,\n    exclusive_minimum: (\n        bool\n        | None\n    ) = None,\n    max_length: (\n        int\n        | None\n    ) = None,\n    min_length: (\n        int\n        | None\n    ) = None,\n    pattern: (\n        str\n        | None\n    ) = None,\n    max_items: (\n        int\n        | None\n    ) = None,\n    min_items: (\n        int\n        | None\n    ) = None,\n    unique_items: (\n        bool\n        | None\n    ) = None,\n    items: (\n        Reference\n        | Schema\n        | typing.Sequence[\n            Reference\n            | Schema\n        ]\n        | None\n    ) = None,\n    max_properties: (\n        int\n        | None\n    ) = None,\n    min_properties: (\n        int\n        | None\n    ) = None,\n    properties: (\n        Properties\n        | None\n    ) = None,\n    additional_properties: (\n        Reference\n        | Schema\n        | bool\n        | None\n    ) = None,\n    enum: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None,\n    const: (\n        typing.Any\n        | None\n    ) = None,\n    type_: (\n        str\n        | None\n    ) = None,\n    format_: (\n        str\n        | None\n    ) = None,\n    required: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    all_of: (\n        typing.Sequence[\n            Reference\n            | Schema\n        ]\n        | None\n    ) = None,\n    any_of: (\n        typing.Sequence[\n            Reference\n            | Schema\n        ]\n        | None\n    ) = None,\n    one_of: (\n        typing.Sequence[\n            Reference\n            | Schema\n        ]\n        | None\n    ) = None,\n    is_not: (\n        Reference\n        | Schema\n        | None\n    ) = None,\n    definitions: (\n        typing.Any\n        | None\n    ) = None,\n    default: (\n        typing.Any\n        | None\n    ) = None,\n    discriminator: (\n        Discriminator\n        | str\n        | None\n    ) = None,\n    read_only: (\n        bool\n        | None\n    ) = None,\n    write_only: (\n        bool\n        | None\n    ) = None,\n    xml: (\n        XML\n        | None\n    ) = None,\n    external_docs: (\n        ExternalDocumentation\n        | None\n    ) = None,\n    example: (\n        typing.Any\n        | None\n    ) = None,\n    deprecated: (\n        bool\n        | None\n    ) = None,\n    links: (\n        typing.Sequence[\n            Link\n        ]\n        | None\n    ) = None,\n    nullable: (\n        bool\n        | None\n    ) = None,\n    content_encoding: (\n        str\n        | None\n    ) = None,\n    content_media_type: (\n        str\n        | None\n    ) = None,\n    examples: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.title: (\n        str\n        | None\n    ) = title\n    self.description: (\n        str\n        | None\n    ) = description\n    self.multiple_of: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = multiple_of\n    self.maximum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = maximum\n    self.exclusive_maximum: (\n        bool\n        | None\n    ) = exclusive_maximum\n    self.minimum: (\n        float\n        | int\n        | decimal.Decimal\n        | None\n    ) = minimum\n    self.exclusive_minimum: (\n        bool\n        | None\n    ) = exclusive_minimum\n    self.max_length: (\n        int\n        | None\n    ) = max_length\n    self.min_length: (\n        int\n        | None\n    ) = min_length\n    self.pattern: (\n        str\n        | None\n    ) = pattern\n    self.max_items: (\n        int\n        | None\n    ) = max_items\n    self.min_items: (\n        int\n        | None\n    ) = min_items\n    self.unique_items: (\n        bool\n        | None\n    ) = unique_items\n    self.items: (\n        Reference\n        | Schema\n        | typing.Sequence[\n            Reference\n            | Schema\n        ]\n        | None\n    ) = items\n    self.max_properties: (\n        int\n        | None\n    ) = max_properties\n    self.min_properties: (\n        int\n        | None\n    ) = min_properties\n    self.properties: (\n        Properties\n        | None\n    ) = properties\n    self.additional_properties: (\n        Reference\n        | Schema\n        | bool\n        | None\n    ) = additional_properties\n    self.enum: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = enum\n    self.const: (\n        typing.Any\n        | None\n    ) = const\n    self.type_: (\n        str\n        | None\n    ) = type_\n    self.format_: (\n        str\n        | None\n    ) = format_\n    self.required: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = required\n    self.all_of: (\n        typing.Sequence[\n            Reference\n            | Schema\n        ]\n        | None\n    ) = all_of\n    self.any_of: (\n        typing.Sequence[\n            Reference\n            | Schema\n        ]\n        | None\n    ) = any_of\n    self.one_of: (\n        typing.Sequence[\n            Reference\n            | Schema\n        ]\n        | None\n    ) = one_of\n    self.is_not: (\n        Reference\n        | Schema\n        | None\n    ) = is_not\n    self.definitions: (\n        typing.Any\n        | None\n    ) = definitions\n    self.default: (\n        typing.Any\n        | None\n    ) = default\n    self.discriminator: (\n        Discriminator\n        | str\n        | None\n    ) = discriminator\n    self.read_only: (\n        bool\n        | None\n    ) = read_only\n    self.write_only: (\n        bool\n        | None\n    ) = write_only\n    self.xml: (\n        XML\n        | None\n    ) = xml\n    self.external_docs: (\n        ExternalDocumentation\n        | None\n    ) = external_docs\n    self.example: (\n        typing.Any\n        | None\n    ) = example\n    self.deprecated: (\n        bool\n        | None\n    ) = deprecated\n    self.links: (\n        typing.Sequence[\n            Link\n        ]\n        | None\n    ) = links\n    self.nullable: (\n        bool\n        | None\n    ) = nullable\n    self.content_encoding: (\n        str\n        | None\n    ) = content_encoding\n    self.content_media_type: (\n        str\n        | None\n    ) = content_media_type\n    self.examples: (\n        typing.Sequence[\n            sob.abc.MarshallableTypes | None\n        ]\n        | None\n    ) = examples\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.SecurityScheme","title":"SecurityScheme","text":"<pre><code>SecurityScheme(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    type_: str | None = None,\n    description: str | None = None,\n    name: str | None = None,\n    in_: str | None = None,\n    scheme: str | None = None,\n    bearer_format: str | None = None,\n    flows: oapi.oas.model.OAuthFlows | None = None,\n    open_id_connect_url: str | None = None,\n    flow: str | None = None,\n    authorization_url: str | None = None,\n    token_url: str | None = None,\n    scopes: typing.Mapping[str, str] | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>[OpenAPI 3 Security Scheme Object] ](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.1.md# security-scheme-object) | OpenAPI 2 Security Scheme Object </p> <p>Attributes:</p> <ul> <li> <code>type_</code>               (<code>str | None</code>)           \u2013            <p>OpenAPI 3x: \"apiKey\", \"http\", \"mutualTLS\", \"oauth2\", or \"openIdConnect\". OpenAPI 2x: \"basic\", \"apiKey\" or \"oauth2\".</p> </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>name</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>in_</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>scheme</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>bearer_format</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>flows</code>               (<code>oapi.oas.model.OAuthFlows | None</code>)           \u2013            </li> <li> <code>open_id_connect_url</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>scopes</code>               (<code>typing.Mapping[str, str] | None</code>)           \u2013            </li> <li> <code>flow</code>               (<code>str | None</code>)           \u2013            <p>\"implicit\", \"password\", \"application\" or \"accessCode\"</p> </li> <li> <code>authorization_url</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>token_url</code>               (<code>str | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    type_: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    name: (\n        str\n        | None\n    ) = None,\n    in_: (\n        str\n        | None\n    ) = None,\n    scheme: (\n        str\n        | None\n    ) = None,\n    bearer_format: (\n        str\n        | None\n    ) = None,\n    flows: (\n        OAuthFlows\n        | None\n    ) = None,\n    open_id_connect_url: (\n        str\n        | None\n    ) = None,\n    flow: (\n        str\n        | None\n    ) = None,\n    authorization_url: (\n        str\n        | None\n    ) = None,\n    token_url: (\n        str\n        | None\n    ) = None,\n    scopes: (\n        typing.Mapping[\n            str,\n            str\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.type_: (\n        str\n        | None\n    ) = type_\n    self.description: (\n        str\n        | None\n    ) = description\n    self.name: (\n        str\n        | None\n    ) = name\n    self.in_: (\n        str\n        | None\n    ) = in_\n    self.scheme: (\n        str\n        | None\n    ) = scheme\n    self.bearer_format: (\n        str\n        | None\n    ) = bearer_format\n    self.flows: (\n        OAuthFlows\n        | None\n    ) = flows\n    self.open_id_connect_url: (\n        str\n        | None\n    ) = open_id_connect_url\n    self.flow: (\n        str\n        | None\n    ) = flow\n    self.authorization_url: (\n        str\n        | None\n    ) = authorization_url\n    self.token_url: (\n        str\n        | None\n    ) = token_url\n    self.scopes: (\n        typing.Mapping[\n            str,\n            str\n        ]\n        | None\n    ) = scopes\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Server","title":"Server","text":"<pre><code>Server(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    url: str | None = None,\n    description: str | None = None,\n    variables: (\n        typing.Mapping[str, oapi.oas.model.ServerVariable]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Server Object </p> <p>Attributes:</p> <ul> <li> <code>url</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>variables</code>               (<code>typing.Mapping[str, oapi.oas.model.ServerVariable] | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    url: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    variables: (\n        typing.Mapping[\n            str,\n            ServerVariable\n        ]\n        | None\n    ) = None\n) -&gt; None:\n    self.url: (\n        str\n        | None\n    ) = url\n    self.description: (\n        str\n        | None\n    ) = description\n    self.variables: (\n        typing.Mapping[\n            str,\n            ServerVariable\n        ]\n        | None\n    ) = variables\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.ServerVariable","title":"ServerVariable","text":"<pre><code>ServerVariable(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    enum: typing.Sequence[str] | None = None,\n    default: str | None = None,\n    description: str | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Server Variable Object </p> <p>Attributes:</p> <ul> <li> <code>enum</code>               (<code>typing.Sequence[str] | None</code>)           \u2013            </li> <li> <code>default</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    enum: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = None,\n    default: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None\n) -&gt; None:\n    self.enum: (\n        typing.Sequence[\n            str\n        ]\n        | None\n    ) = enum\n    self.default: (\n        str\n        | None\n    ) = default\n    self.description: (\n        str\n        | None\n    ) = description\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.Tag","title":"Tag","text":"<pre><code>Tag(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: str | None = None,\n    description: str | None = None,\n    external_docs: (\n        oapi.oas.model.ExternalDocumentation | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 Tag Object </p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>description</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>external_docs</code>               (<code>oapi.oas.model.ExternalDocumentation | None</code>)           \u2013            </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: (\n        str\n        | None\n    ) = None,\n    description: (\n        str\n        | None\n    ) = None,\n    external_docs: (\n        ExternalDocumentation\n        | None\n    ) = None\n) -&gt; None:\n    self.name: (\n        str\n        | None\n    ) = name\n    self.description: (\n        str\n        | None\n    ) = description\n    self.external_docs: (\n        ExternalDocumentation\n        | None\n    ) = external_docs\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.model/#oapi.oas.model.XML","title":"XML","text":"<pre><code>XML(\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[str, sob.abc.MarshallableTypes]\n        | typing.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: str | None = None,\n    name_space: str | None = None,\n    prefix: str | None = None,\n    attribute: bool | None = None,\n    wrapped: bool | None = None,\n)\n</code></pre> <p>               Bases: <code>sob.Object</code></p> <p>OpenAPI 3 XML Object </p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The element name.</p> </li> <li> <code>name_space</code>               (<code>str | None</code>)           \u2013            <p>The absolute URI of a namespace.</p> </li> <li> <code>prefix</code>               (<code>str | None</code>)           \u2013            <p>The prefix to be used with the name to reference the name-space.</p> </li> <li> <code>attribute</code>               (<code>bool | None</code>)           \u2013            <p>If <code>True</code>, the property described is an attribute rather than a sub-element.</p> </li> <li> <code>wrapped</code>               (<code>bool | None</code>)           \u2013            <p>If <code>True</code>, an array instance described by the schema will be wrapped by a tag (named according to the parent element's property, while <code>name</code> refers to the child element name).</p> </li> </ul> Source code in <code>src/oapi/oas/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        sob.abc.Dictionary\n        | typing.Mapping[\n            str,\n            sob.abc.MarshallableTypes\n        ]\n        | typing.Iterable[\n            tuple[\n                str,\n                sob.abc.MarshallableTypes\n            ]\n        ]\n        | sob.abc.Readable\n        | typing.IO\n        | str\n        | bytes\n        | None\n    ) = None,\n    name: (\n        str\n        | None\n    ) = None,\n    name_space: (\n        str\n        | None\n    ) = None,\n    prefix: (\n        str\n        | None\n    ) = None,\n    attribute: (\n        bool\n        | None\n    ) = None,\n    wrapped: (\n        bool\n        | None\n    ) = None\n) -&gt; None:\n    self.name: (\n        str\n        | None\n    ) = name\n    self.name_space: (\n        str\n        | None\n    ) = name_space\n    self.prefix: (\n        str\n        | None\n    ) = prefix\n    self.attribute: (\n        bool\n        | None\n    ) = attribute\n    self.wrapped: (\n        bool\n        | None\n    ) = wrapped\n    super().__init__(_data)\n</code></pre>"},{"location":"api/oapi.oas.references/","title":"oapi.oas.references","text":""},{"location":"api/oapi.oas.references/#oapi.oas.references","title":"oapi.oas.references","text":"<p>This module provides functionality for resolving references within an instance of <code>oapi.oas.OpenAPI</code>.</p> <p>The following will replace all references in the Open API document <code>open_api_document</code> with the objects targeted by the <code>ref</code> property of the reference.</p> <p>Example:</p> <pre><code>import yaml\nfrom urllib.request import urlopen\nfrom oapi.oas import OpenAPI\nfrom oapi.oas.references import Resolver\n\n\nwith urlopen(\n    \"https://raw.githubusercontent.com/OAI/OpenAPI-Specification/3.1.1/\"\n    \"examples/v3.0/callback-example.yaml\"\n) as response:\n    open_api_document = OpenAPI(\n        yaml.safe_load(response)\n    )\n\nresolver = Resolver(open_api_document)\nresolver.dereference()\n</code></pre>"},{"location":"api/oapi.oas.references/#oapi.oas.references.Resolver","title":"Resolver","text":"<pre><code>Resolver(\n    root: oapi.oas.model.OpenAPI,\n    url: str | None = None,\n    urlopen: collections.abc.Callable = oapi.oas.references._urlopen,\n)\n</code></pre> <p>This class should be used, with an instance of <code>oapi.oas.OpenAPI</code>, to resolve references.</p> <p>Parameters:</p> <ul> <li> <code>root</code>               (<code>oapi.oas.model.OpenAPI</code>)           \u2013            <p>The OpenAPI document against which pointers will be resolved.</p> </li> <li> <code>url</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The URL or file path from where <code>root</code> was retrieved. The base URL for relative paths will be the directory above this URL. This will not typically be needed, as it can be inferred from most <code>Model</code> instances.</p> </li> <li> <code>urlopen</code>               (<code>collections.abc.Callable</code>, default:                   <code>oapi.oas.references._urlopen</code> )           \u2013            <p>If provided, this should be a function taking one argument (a <code>str</code>), which can be used in lieu of <code>urllib.request.urlopen</code> to retrieve a document and return an instance of a sub-class of <code>IOBase</code> (such as <code>http.client.HTTPResponse</code>). This should be used if authentication is needed in order to retrieve external references in the document, or if local file paths will be referenced instead of web URL's (use <code>open</code> as the value for the <code>urlopen</code> parameter in this case).</p> </li> </ul> Source code in <code>src/oapi/oas/references.py</code> <pre><code>def __init__(\n    self,\n    root: OpenAPI,\n    url: str | None = None,\n    urlopen: Callable = _urlopen,\n) -&gt; None:\n    # Ensure arguments are of the correct types\n    if not callable(urlopen):\n        raise TypeError(urlopen)\n    if not isinstance(root, OpenAPI):\n        raise TypeError(root)\n    if not ((url is None) or isinstance(url, str)):\n        raise TypeError(url)\n    # This is the function used to open external pointer references\n    self.urlopen = urlopen\n    # Infer the URL from the `OpenAPI` document, if not explicitly provided\n    if url is None:\n        url = sob.get_model_url(root) or \"\"\n    self.url = url\n    # This is the primary document--the one we are resolving\n    document: _Document = _Document(self, root, url)\n    # Store the primary document both by URL and under the key \"#\" (for\n    # convenient reference)\n    self.documents = {url: document}\n    if url != \"\":\n        self.documents[\"\"] = document\n</code></pre>"},{"location":"api/oapi.oas.references/#oapi.oas.references.Resolver.get_document","title":"get_document","text":"<pre><code>get_document(url: str) -&gt; oapi.oas.references._Document\n</code></pre> <p>Retrieve a document by URL, or use the cached document if previously retrieved</p> Source code in <code>src/oapi/oas/references.py</code> <pre><code>def get_document(self, url: str) -&gt; _Document:\n    \"\"\"\n    Retrieve a document by URL, or use the cached document if previously\n    retrieved\n    \"\"\"\n    if url not in self.documents:\n        try:\n            with self.urlopen(url) as response:\n                self.documents[url] = _Document(\n                    self, sob.unmarshal(sob.deserialize(response)), url=url\n                )\n        except (HTTPError, FileNotFoundError) as error:\n            sob.errors.append_exception_text(error, f\": {url}\")\n            raise\n    return self.documents[url]\n</code></pre>"},{"location":"api/oapi.oas.references/#oapi.oas.references.Resolver.dereference","title":"dereference","text":"<pre><code>dereference() -&gt; None\n</code></pre> <p>Dereference the primary document</p> Source code in <code>src/oapi/oas/references.py</code> <pre><code>def dereference(self) -&gt; None:\n    \"\"\"\n    Dereference the primary document\n    \"\"\"\n    self.documents[\"\"].dereference_all()\n</code></pre>"},{"location":"api/oapi.oas.references/#oapi.oas.references.Resolver.resolve","title":"resolve","text":"<pre><code>resolve(\n    pointer: str,\n    types: (\n        sob.abc.Types\n        | collections.abc.Sequence[type | sob.abc.Property]\n    ) = (),\n    *,\n    dereference: bool = False\n) -&gt; sob.abc.Model\n</code></pre> <p>Retrieve an object at the specified pointer</p> Source code in <code>src/oapi/oas/references.py</code> <pre><code>def resolve(\n    self,\n    pointer: str,\n    types: sob.abc.Types | Sequence[type | sob.abc.Property] = (),\n    *,\n    dereference: bool = False,\n) -&gt; sob.abc.Model:\n    \"\"\"\n    Retrieve an object at the specified pointer\n    \"\"\"\n    url, pointer = self.documents[\"\"].get_url_pointer(pointer)\n    return self.documents[url].resolve(\n        pointer, types, dereference=dereference\n    )\n</code></pre>"},{"location":"api/oapi.oas.references/#oapi.oas.references.Resolver.resolve_reference","title":"resolve_reference","text":"<pre><code>resolve_reference(\n    reference: oapi.oas.model.Reference,\n    types: (\n        sob.abc.Types\n        | collections.abc.Sequence[type | sob.abc.Property]\n    ) = (),\n) -&gt; sob.abc.Model\n</code></pre> <p>Retrieve a referenced object.</p> <p>Parameters:</p> <ul> <li> <code>reference</code>               (<code>oapi.oas.model.Reference</code>)           \u2013            </li> <li> <code>types</code>               (<code>sob.abc.Types | collections.abc.Sequence[type | sob.abc.Property]</code>, default:                   <code>()</code> )           \u2013            </li> </ul> Source code in <code>src/oapi/oas/references.py</code> <pre><code>def resolve_reference(\n    self,\n    reference: Reference,\n    types: sob.abc.Types | Sequence[type | sob.abc.Property] = (),\n) -&gt; sob.abc.Model:\n    \"\"\"\n    Retrieve a referenced object.\n\n    Parameters:\n        reference:\n        types:\n    \"\"\"\n    message: str\n    url: str = sob.get_model_url(reference) or \"\"\n    if not reference.ref:\n        raise ValueError(reference)\n    pointer: str = urljoin(\n        sob.get_model_pointer(reference) or \"\",\n        reference.ref,\n    )\n    resolved_model: sob.abc.Model = self.get_document(url).resolve(\n        pointer, types\n    )\n    if resolved_model is reference or (\n        isinstance(resolved_model, Reference)\n        and resolved_model.ref == reference.ref\n    ):\n        message = f\"`Reference` instance is self-referential: {pointer}\"\n        raise OAPIReferenceLoopError(message)\n    if isinstance(resolved_model, Reference):\n        resolved_model = self.resolve_reference(\n            resolved_model, types=types\n        )\n    return resolved_model\n</code></pre>"},{"location":"api/oapi.oas.references/#oapi.oas.references.Resolver.get_relative_url","title":"get_relative_url","text":"<pre><code>get_relative_url(url: str) -&gt; str\n</code></pre> <p>Given a URL, return that URL relative to the base document</p> Source code in <code>src/oapi/oas/references.py</code> <pre><code>def get_relative_url(self, url: str) -&gt; str:\n    \"\"\"\n    Given a URL, return that URL relative to the base document\n    \"\"\"\n    relative_url: str = \"\"\n    if url:\n        parse_result: ParseResult = urlparse(url)\n        # Determine if the URL is absolute or relative\n        if parse_result.netloc or parse_result.scheme == \"file\":\n            # Only include the relative URL if it is not the root document\n            if url == self.url:\n                relative_url = \"\"\n            else:\n                relative_url = sob.utilities.get_url_relative_to(\n                    url, self.url\n                )\n        else:\n            relative_url = url\n    return relative_url\n</code></pre>"},{"location":"api/sob.abc/","title":"sob.abc","text":""},{"location":"api/sob.abc/#sob.abc","title":"sob.abc","text":"<p>This module contains abstract base classes declaring the interface for classes defined in <code>sob.model</code>, <code>sob.properties</code>, <code>sob.types</code>, <code>sob.meta</code>, and <code>sob.hooks</code>.</p>"},{"location":"api/sob.abc/#sob.abc.Types","title":"Types","text":"<pre><code>Types(\n    items: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>This class is an abstract base for <code>sob.Types</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Iterable[type | Property] | type | Property | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.MutableTypes","title":"MutableTypes","text":"<pre><code>MutableTypes(\n    items: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Types</code></p> <p>This class is an abstract base for <code>sob.MutableTypes</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Iterable[type | Property] | type | Property | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.Hooks","title":"Hooks","text":"<pre><code>Hooks(\n    before_marshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        collections.abc.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_validate: (\n        collections.abc.Callable[[sob.abc.Model], None]\n        | None\n    ) = None,\n)\n</code></pre> <p>This class is an abstract base for <code>sob.Hooks</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    before_marshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[Model], Model] | None = None,\n    after_validate: Callable[[Model], None] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.ObjectHooks","title":"ObjectHooks","text":"<pre><code>ObjectHooks(\n    before_marshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        collections.abc.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_validate: (\n        collections.abc.Callable[[sob.abc.Model], None]\n        | None\n    ) = None,\n    before_setattr: (\n        collections.abc.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setattr: (\n        collections.abc.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n    before_setitem: (\n        collections.abc.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        collections.abc.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Hooks</code></p> <p>This class is an abstract base for <code>sob.ObjectHooks</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    before_marshal: Callable[[MarshallableTypes], Any] | None = None,\n    after_marshal: Callable[[JSONTypes], Any] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], Any] | None = None,\n    after_unmarshal: Callable[[MarshallableTypes], Any] | None = None,\n    before_serialize: Callable[[JSONTypes], Any] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[Model], Model] | None = None,\n    after_validate: Callable[[Model], None] | None = None,\n    before_setattr: Callable[\n        [Object, str, MarshallableTypes], tuple[str, MarshallableTypes]\n    ]\n    | None = None,\n    after_setattr: Callable[[Object, str, MarshallableTypes], None]\n    | None = None,\n    before_setitem: Callable[\n        [Object, str, MarshallableTypes], tuple[str, MarshallableTypes]\n    ]\n    | None = None,\n    after_setitem: Callable[[Object, str, MarshallableTypes], None]\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.ArrayHooks","title":"ArrayHooks","text":"<pre><code>ArrayHooks(\n    before_marshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        collections.abc.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_validate: (\n        collections.abc.Callable[[sob.abc.Model], None]\n        | None\n    ) = None,\n    before_setitem: (\n        collections.abc.Callable[\n            [sob.abc.Array, int, sob.abc.MarshallableTypes],\n            tuple[int, typing.Any],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        collections.abc.Callable[\n            [sob.abc.Array, int, sob.abc.MarshallableTypes],\n            None,\n        ]\n        | None\n    ) = None,\n    before_append: (\n        collections.abc.Callable[\n            [sob.abc.Array, sob.abc.MarshallableTypes],\n            typing.Any | None,\n        ]\n        | None\n    ) = None,\n    after_append: (\n        collections.abc.Callable[\n            [sob.abc.Array, sob.abc.MarshallableTypes], None\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Hooks</code></p> <p>This class is an abstract base for <code>sob.ArrayHooks</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    before_marshal: Callable[[MarshallableTypes], Any] | None = None,\n    after_marshal: Callable[[JSONTypes], Any] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], Any] | None = None,\n    after_unmarshal: Callable[[MarshallableTypes], Any] | None = None,\n    before_serialize: Callable[[JSONTypes], Any] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[Model], Model] | None = None,\n    after_validate: Callable[[Model], None] | None = None,\n    before_setitem: Callable[\n        [Array, int, MarshallableTypes], tuple[int, Any]\n    ]\n    | None = None,\n    after_setitem: Callable[[Array, int, MarshallableTypes], None]\n    | None = None,\n    before_append: Callable[[Array, MarshallableTypes], Any | None]\n    | None = None,\n    after_append: Callable[[Array, MarshallableTypes], None] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.DictionaryHooks","title":"DictionaryHooks","text":"<pre><code>DictionaryHooks(\n    before_marshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], typing.Any\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        collections.abc.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_validate: (\n        collections.abc.Callable[[sob.abc.Model], None]\n        | None\n    ) = None,\n    before_setitem: (\n        collections.abc.Callable[\n            [\n                sob.abc.Dictionary,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, typing.Any],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        collections.abc.Callable[\n            [\n                sob.abc.Dictionary,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Hooks</code></p> <p>This class is an abstract base for <code>sob.DictionaryHooks</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    before_serialize: Callable[[JSONTypes], Any] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[Model], Model] | None = None,\n    after_validate: Callable[[Model], None] | None = None,\n    before_setitem: Callable[\n        [Dictionary, str, MarshallableTypes], tuple[str, Any]\n    ]\n    | None = None,\n    after_setitem: Callable[[Dictionary, str, MarshallableTypes], None]\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.Readable","title":"Readable","text":"<p>This is an abstract base for file-like objects which are readable, but not necessarily writable (such an which are found in the <code>io</code> module, but also objects such as <code>http.client.HTTPResponse</code>). Objects will be identified as sub-classes if they have a callable <code>read</code> method.</p>"},{"location":"api/sob.abc/#sob.abc.Meta","title":"Meta","text":"<p>This class is an abstract base for <code>sob.Meta</code>.</p>"},{"location":"api/sob.abc/#sob.abc.ObjectMeta","title":"ObjectMeta","text":"<pre><code>ObjectMeta(\n    properties: (\n        collections.abc.Mapping[str, sob.abc.Property]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.Property]\n        ]\n        | sob.abc.Properties\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Meta</code></p> <p>This class is an abstract base for <code>sob.ObjectMeta</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    properties: Mapping[str, Property]\n    | Iterable[tuple[str, Property]]\n    | Properties\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.DictionaryMeta","title":"DictionaryMeta","text":"<pre><code>DictionaryMeta(\n    value_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n        | sob.abc.Property\n        | type\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Meta</code></p> <p>This class is an abstract base for <code>sob.DictionaryMeta</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    value_types: Iterable[Property | type]\n    | Types\n    | None\n    | Property\n    | type = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.ArrayMeta","title":"ArrayMeta","text":"<pre><code>ArrayMeta(\n    item_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n        | sob.abc.Property\n        | type\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Meta</code></p> <p>This class is an abstract base for <code>sob.ArrayMeta</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    item_types: Iterable[Property | type]\n    | Types\n    | None\n    | Property\n    | type = None,\n):\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.Properties","title":"Properties","text":"<pre><code>Properties(\n    items: (\n        collections.abc.Mapping[str, sob.abc.Property]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.Property]\n        ]\n        | sob.abc.Properties\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Meta</code></p> <p>This class is an abstract base for <code>sob.Properties</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Mapping[str, Property]\n    | Iterable[tuple[str, Property]]\n    | Properties\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.Model","title":"Model","text":"<p>This class is an abstract base for <code>sob.Model</code>.</p>"},{"location":"api/sob.abc/#sob.abc.Dictionary","title":"Dictionary","text":"<pre><code>Dictionary(\n    items: (\n        sob.abc.Dictionary\n        | collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n    value_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Model</code></p> <p>This class is an abstract base for <code>sob.Dictionary</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Dictionary\n    | Mapping[str, MarshallableTypes]\n    | Iterable[tuple[str, MarshallableTypes]]\n    | Readable\n    | str\n    | bytes\n    | None = None,\n    value_types: Iterable[type | Property]\n    | type\n    | Property\n    | Types\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.Object","title":"Object","text":"<pre><code>Object(\n    _data: (\n        sob.abc.Object\n        | sob.abc.Dictionary\n        | collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Model</code></p> <p>This class is an abstract base for <code>sob.Object</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    _data: Object\n    | Dictionary\n    | Mapping[str, MarshallableTypes]\n    | Iterable[tuple[str, MarshallableTypes]]\n    | Readable\n    | str\n    | bytes\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.Array","title":"Array","text":"<pre><code>Array(\n    items: (\n        sob.abc.Array\n        | collections.abc.Iterable[\n            sob.abc.MarshallableTypes\n        ]\n        | str\n        | bytes\n        | sob.abc.Readable\n        | None\n    ) = None,\n    item_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Model</code></p> <p>This class is an abstract base for <code>sob.Array</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    items: Array\n    | Iterable[MarshallableTypes]\n    | str\n    | bytes\n    | Readable\n    | None = None,\n    item_types: Iterable[type | Property]\n    | type\n    | Property\n    | Types\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.Property","title":"Property","text":"<pre><code>Property(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>This class is an abstract base for <code>sob.Property</code>.</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.StringProperty","title":"StringProperty","text":"<pre><code>StringProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.StringProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.DateProperty","title":"DateProperty","text":"<pre><code>DateProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.DateProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.DateTimeProperty","title":"DateTimeProperty","text":"<pre><code>DateTimeProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.DateTimeProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.BytesProperty","title":"BytesProperty","text":"<pre><code>BytesProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.BytesProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.EnumeratedProperty","title":"EnumeratedProperty","text":"<pre><code>EnumeratedProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.EnumeratedProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.NumberProperty","title":"NumberProperty","text":"<pre><code>NumberProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.NumberProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.IntegerProperty","title":"IntegerProperty","text":"<pre><code>IntegerProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.IntegerProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.BooleanProperty","title":"BooleanProperty","text":"<pre><code>BooleanProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.BooleanProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.ArrayProperty","title":"ArrayProperty","text":"<pre><code>ArrayProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.ArrayProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.DictionaryProperty","title":"DictionaryProperty","text":"<pre><code>DictionaryProperty(\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool | collections.abc.Callable = False,\n    versions: (\n        collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This class is an abstract base for <code>sob.DictionaryProperty</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    types: Iterable[type | Property] | None = None,\n    name: str | None = None,\n    *,\n    required: bool | Callable = False,\n    versions: Iterable[str | Version] | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.abc/#sob.abc.Version","title":"Version","text":"<pre><code>Version(\n    version_number: str | None = None,\n    specification: str | None = None,\n    equals: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    not_equals: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    less_than: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    less_than_or_equal_to: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    greater_than: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    greater_than_or_equal_to: (\n        collections.abc.Sequence[\n            str | float | int | decimal.Decimal\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>This class is an abstract base for <code>sob.Version</code> .</p> Source code in <code>sob/abc.py</code> <pre><code>@abstractmethod\ndef __init__(\n    self,\n    version_number: str | None = None,\n    specification: str | None = None,\n    equals: Sequence[str | float | int | Decimal] | None = None,\n    not_equals: Sequence[str | float | int | Decimal] | None = None,\n    less_than: Sequence[str | float | int | Decimal] | None = None,\n    less_than_or_equal_to: Sequence[str | float | int | Decimal]\n    | None = None,\n    greater_than: Sequence[str | float | int | Decimal] | None = None,\n    greater_than_or_equal_to: Sequence[str | float | int | Decimal]\n    | None = None,\n) -&gt; None:\n    pass\n</code></pre>"},{"location":"api/sob.errors/","title":"sob.errors","text":""},{"location":"api/sob.errors/#sob.errors","title":"sob.errors","text":""},{"location":"api/sob.errors/#sob.errors.DefinitionExistsError","title":"DefinitionExistsError","text":"<p>               Bases: <code>Exception</code></p> <p>This error is raised when an attempt is made to redefine a singleton class instance.</p>"},{"location":"api/sob.errors/#sob.errors.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>Exception</code></p> <p>This error is raised when <code>sob.validate</code> encounters extraneous attributes associated with a model instance, or discovers missing required attributes.</p>"},{"location":"api/sob.errors/#sob.errors.VersionError","title":"VersionError","text":"<p>               Bases: <code>AttributeError</code></p> <p>This error is raised when versioning an object fails due to having data which is incompatible with the target version.</p>"},{"location":"api/sob.errors/#sob.errors.DeserializeError","title":"DeserializeError","text":"<pre><code>DeserializeError(data: str | bytes, message: str = '')\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>This error is raised when data is encountered during deserialization which cannot be parsed.</p> <p>Attributes:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The data that could not be parsed.</p> </li> <li> <code>message</code>               (<code>str</code>)           \u2013            <p>Additional information about the error.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes</code>)           \u2013            <p>The data that could not be parsed.</p> </li> <li> <code>message</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>An optional message to include with the error.</p> </li> </ul> Source code in <code>sob/errors.py</code> <pre><code>def __init__(self, data: str | bytes, message: str = \"\") -&gt; None:\n    \"\"\"\n    Parameters:\n        data: The data that could not be parsed.\n        message: An optional message to include with the error.\n    \"\"\"\n    self.data: str | bytes = data\n    self.message: str = message\n    super().__init__(*((data,) + ((message,) if message else ())))\n</code></pre>"},{"location":"api/sob.errors/#sob.errors.UnmarshalError","title":"UnmarshalError","text":"<pre><code>UnmarshalError(\n    message: str | None = None,\n    data: sob.abc.MarshallableTypes | None = None,\n    types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n    ) = None,\n    item_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n    ) = None,\n    value_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>This is an error message raised when data cannot be un-marshalled due to not matching metadata specs.</p> <p>Attributes:</p> <ul> <li> <code>message</code>           \u2013            </li> <li> <code>data</code>               (<code>sob.abc.MarshallableTypes | None</code>)           \u2013            </li> <li> <code>types</code>               (<code>sob.abc.MarshallableTypes | None</code>)           \u2013            </li> <li> <code>item_types</code>               (<code>sob.abc.MarshallableTypes | None</code>)           \u2013            </li> <li> <code>value_types</code>               (<code>sob.abc.MarshallableTypes | None</code>)           \u2013            </li> </ul> Source code in <code>sob/errors.py</code> <pre><code>def __init__(\n    self,\n    message: str | None = None,\n    data: abc.MarshallableTypes | None = None,\n    types: Iterable[abc.Property | type] | abc.Types | None = None,\n    item_types: Iterable[abc.Property | type] | abc.Types | None = None,\n    value_types: Iterable[abc.Property | type] | abc.Types | None = None,\n) -&gt; None:\n    self.data: abc.MarshallableTypes | None = data\n    error_message_lines: list[str] = []\n    # Identify which parameter is being used for type validation\n    types_label: str = (\n        \"item_types\"\n        if item_types\n        else \"value_types\"\n        if value_types\n        else \"types\"\n    )\n    types = item_types or value_types or types\n    if types is None:\n        error_message_lines.append(\n            \"The data provided is not an instance of an un-marshallable \"\n            \"type:\\n\"\n        )\n    else:\n        error_message_lines.append(\n            \"The data provided does not match any of the expected types \"\n            \"and/or property definitions:\\n\"\n        )\n    error_message_lines.append(f\"- data: {indent(represent(data))}\")\n    if types is None:\n        types = abc.MARSHALLABLE_TYPES\n        types_label = \"un-marshallable types\"\n    type_representation: str = indent(\n        represent(tuple(types)), number_of_spaces=2\n    )\n    error_message_lines.append(f\"- {types_label}: {type_representation}\")\n    if message:\n        error_message_lines += [\"\", message]\n    super().__init__(\"\\n\".join(error_message_lines))\n</code></pre>"},{"location":"api/sob.errors/#sob.errors.get_exception_text","title":"get_exception_text","text":"<pre><code>get_exception_text() -&gt; str\n</code></pre> <p>When called within an exception, this function returns a text representation of the error matching what is found in <code>traceback.print_exception</code>, but is returned as a string value rather than printing.</p> Source code in <code>sob/errors.py</code> <pre><code>def get_exception_text() -&gt; str:\n    \"\"\"\n    When called within an exception, this function returns a text\n    representation of the error matching what is found in\n    `traceback.print_exception`, but is returned as a string value rather than\n    printing.\n    \"\"\"\n    return \"\".join(format_exception(*sys.exc_info()))\n</code></pre>"},{"location":"api/sob.errors/#sob.errors.append_exception_text","title":"append_exception_text","text":"<pre><code>append_exception_text(\n    error: Exception, message: str\n) -&gt; None\n</code></pre> <p>Cause <code>message</code> to be appended to an error's exception text.</p> Source code in <code>sob/errors.py</code> <pre><code>def append_exception_text(error: Exception, message: str) -&gt; None:\n    \"\"\"\n    Cause `message` to be appended to an error's exception text.\n    \"\"\"\n    attribute_name: str\n    for attribute_name in (\"strerror\", \"msg\", \"errmsg\"):\n        attribute_value: str = getattr(error, attribute_name, \"\")\n        if attribute_value:\n            setattr(error, attribute_name, f\"{attribute_value}{message}\")\n    found: bool = False\n    index: int\n    arg: Any\n    reversed_args: list[Any] = list(reversed(error.args)) or [\"\"]\n    for index, value in enumerate(reversed_args):\n        if isinstance(value, str):\n            found = True\n            reversed_args[index] = f\"{value}{message}\"\n            break\n    if found:\n        error.args = tuple(reversed(reversed_args))\n    else:\n        error.args = (message,)\n</code></pre>"},{"location":"api/sob.hooks/","title":"sob.hooks","text":""},{"location":"api/sob.hooks/#sob.hooks","title":"sob.hooks","text":""},{"location":"api/sob.hooks/#sob.hooks.Hooks","title":"Hooks","text":"<pre><code>Hooks(\n    before_marshal: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        collections.abc.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_validate: (\n        collections.abc.Callable[[sob.abc.Model], None]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Hooks</code></p> <p>Instances of this class hold functions (\"hooks\") to be executed at various points during marshalling, un-marshalling, serializing, de-serializing or validation.</p> <p>Please note the following context-specific definitions:</p> <ul> <li>marshal: To convert an instance of an <code>sob.Model</code> sub-class into data     suitable for serializing with <code>json.dumps</code>. For example, marshalling     an instance of <code>sob.Dictionary</code>, or marshalling an instance of a     sub-class of <code>sob.Object</code>, would result in a <code>dict</code> object.</li> <li>unmarshal: To convert data de-serialized using <code>json.loads</code> into an     instance of an <code>sob.Model</code> sub-class. For example, un-marshalling a     <code>dict</code> object could return in an instance of <code>sob.Dictionary</code>     (this would be the default if no types were specified), or could     return an instance of one of the <code>sob.Model</code> sub-classes     specified in the <code>types</code> parameter passed to <code>sob.unmarshal</code>.</li> <li>serialize: To convert a marshalled object into a JSON string.</li> <li>deserialize: To convert a JSON string into a python-native object.</li> <li>validate: To check that the data held by a model instance is in     compliance with that model's metadata. Because data types are     enforced when attributes are set, validation only entails verifying     that all required attributes are present, and that no extraneous     attributes are present. Validation is only initiated explicitly,     by passing a model instance to the <code>sob.validate</code> function.</li> </ul> <p>Attributes:</p> <ul> <li> <code>before_marshal</code>           \u2013            <p>A function called before marshalling a model. The <code>before_marshal</code> function should accept deserialized JSON data (pre-marshalling) as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>after_marshal</code>           \u2013            <p>A function to be called after marshalling a model. The <code>after_marshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_unmarshal</code>           \u2013            <p>A function to be called before un-marshalling a model. The <code>before_unmarshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_unmarshal</code>           \u2013            <p>A function to be called after un-marshalling a model. The <code>after_unmarshal</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>before_serialize</code>           \u2013            <p>A function to be called before serializing a model. The <code>before_serialize</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value. For most use cases, assigning a function to <code>after_unmarshal</code> and to <code>before_serialize</code> will produce the same result, however it is technically possible to unmarshal data without ever serializing it, so both hooks are provided.</p> </li> <li> <code>after_serialize</code>           \u2013            <p>A function to be called after serializing a model. The <code>after_serialize</code> function should accept a JSON string as the only argument, and return a JSON string as the return value.</p> </li> <li> <code>before_validate</code>           \u2013            <p>A function to be called before validating a model. The <code>before_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_validate</code>           \u2013            <p>A function to be called after validating a model. The <code>after_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> </ul> Source code in <code>sob/hooks.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[abc.Model], abc.Model] | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[abc.Model], abc.Model] | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[abc.Model], abc.Model] | None = None,\n    after_validate: Callable[[abc.Model], None] | None = None,\n):\n    self.before_marshal = before_marshal\n    self.after_marshal = after_marshal\n    self.before_unmarshal = before_unmarshal\n    self.after_unmarshal = after_unmarshal\n    self.before_serialize = before_serialize\n    self.after_serialize = after_serialize\n    self.before_validate = before_validate\n    self.after_validate = after_validate\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.ObjectHooks","title":"ObjectHooks","text":"<pre><code>ObjectHooks(\n    before_marshal: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        collections.abc.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_validate: (\n        collections.abc.Callable[[sob.abc.Model], None]\n        | None\n    ) = None,\n    before_setattr: (\n        collections.abc.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setattr: (\n        collections.abc.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n    before_setitem: (\n        collections.abc.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        collections.abc.Callable[\n            [\n                sob.abc.Object,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.hooks.Hooks</code>, <code>sob.abc.ObjectHooks</code></p> <p>Instances of this class hold functions (\"hooks\") to be executed at various points during marshalling, un-marshalling, serializing, de-serializing or validation.</p> <p>Please note the following context-specific definitions:</p> <ul> <li>marshal: To convert an instance of an <code>sob.Model</code> sub-class into data     suitable for serializing with <code>json.dumps</code>. For example, marshalling     an instance of <code>sob.Dictionary</code>, or marshalling an instance of a     sub-class of <code>sob.Object</code>, would result in a <code>dict</code> object.</li> <li>unmarshal: To convert data de-serialized using <code>json.loads</code> into an     instance of an <code>sob.Model</code> sub-class. For example, un-marshalling a     <code>dict</code> object could return in an instance of <code>sob.Dictionary</code>     (this would be the default if no types were specified), or could     return an instance of one of the <code>sob.Model</code> sub-classes     specified in the <code>types</code> parameter passed to <code>sob.unmarshal</code>.</li> <li>serialize: To convert a marshalled object into a JSON string.</li> <li>deserialize: To convert a JSON string into a python-native object.</li> <li>validate: To check that the data held by a model instance is in     compliance with that model's metadata. Because data types are     enforced when attributes are set, validation only entails verifying     that all required attributes are present, and that no extraneous     attributes are present. Validation is only initiated explicitly,     by passing a model instance to the <code>sob.validate</code> function.</li> </ul> <p>Attributes:</p> <ul> <li> <code>before_marshal</code>           \u2013            <p>A function called before marshalling a model. The <code>before_marshal</code> function should accept deserialized JSON data (pre-marshalling) as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>after_marshal</code>           \u2013            <p>A function to be called after marshalling a model. The <code>after_marshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_unmarshal</code>           \u2013            <p>A function to be called before un-marshalling a model. The <code>before_unmarshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_unmarshal</code>           \u2013            <p>A function to be called after un-marshalling a model. The <code>after_unmarshal</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>before_serialize</code>           \u2013            <p>A function to be called before serializing a model. The <code>before_serialize</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value. For most use cases, assigning a function to <code>after_unmarshal</code> and to <code>before_serialize</code> will produce the same result, however it is technically possible to unmarshal data without ever serializing it, so both hooks are provided.</p> </li> <li> <code>after_serialize</code>           \u2013            <p>A function to be called after serializing a model. The <code>after_serialize</code> function should accept a JSON string as the only argument, and return a JSON string as the return value.</p> </li> <li> <code>before_validate</code>           \u2013            <p>A function to be called before validating a model. The <code>before_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_validate</code>           \u2013            <p>A function to be called after validating a model. The <code>after_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_setattr</code>           \u2013            <p>A function to be called before setting an attribute. The <code>before_setattr</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the attribute name, and the value to be assigned to that attribute. The function should return a tuple containing an attribute name and a value to be assigned to that attribute.</p> </li> <li> <code>after_setattr</code>           \u2013            <p>A function to be called after setting an attribute. The <code>after_setattr</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the attribute name, and the value assigned to that attribute. The function should return <code>None</code>.</p> </li> <li> <code>before_setitem</code>           \u2013            <p>A function to be called before assigning a value to an object by key. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the item key, and the value to be assigned to that key. The function should return a tuple containing a key and a value to be assigned.</p> </li> <li> <code>after_setitem</code>           \u2013            <p>A function to be called after assigning a value to an object by key. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the item key, and the value assigned to that key. The function should return <code>None</code>.</p> </li> </ul> Source code in <code>sob/hooks.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[abc.Model], abc.Model] | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[abc.Model], abc.Model] | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[abc.Model], abc.Model] | None = None,\n    after_validate: Callable[[abc.Model], None] | None = None,\n    before_setattr: Callable[\n        [abc.Object, str, MarshallableTypes], tuple[str, MarshallableTypes]\n    ]\n    | None = None,\n    after_setattr: Callable[[abc.Object, str, MarshallableTypes], None]\n    | None = None,\n    before_setitem: Callable[\n        [abc.Object, str, MarshallableTypes], tuple[str, MarshallableTypes]\n    ]\n    | None = None,\n    after_setitem: Callable[[abc.Object, str, MarshallableTypes], None]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        before_marshal=before_marshal,\n        after_marshal=after_marshal,\n        before_unmarshal=before_unmarshal,\n        after_unmarshal=after_unmarshal,\n        before_serialize=before_serialize,\n        after_serialize=after_serialize,\n        before_validate=before_validate,\n        after_validate=after_validate,\n    )\n    self.before_setattr = before_setattr\n    self.after_setattr = after_setattr\n    self.before_setitem = before_setitem\n    self.after_setitem = after_setitem\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.ArrayHooks","title":"ArrayHooks","text":"<pre><code>ArrayHooks(\n    before_marshal: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        collections.abc.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_validate: (\n        collections.abc.Callable[[sob.abc.Model], None]\n        | None\n    ) = None,\n    before_setitem: (\n        collections.abc.Callable[\n            [sob.abc.Array, int, sob.abc.MarshallableTypes],\n            tuple[int, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        collections.abc.Callable[\n            [sob.abc.Array, int, sob.abc.MarshallableTypes],\n            None,\n        ]\n        | None\n    ) = None,\n    before_append: (\n        collections.abc.Callable[\n            [sob.abc.Array, sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_append: (\n        collections.abc.Callable[\n            [sob.abc.Array, sob.abc.MarshallableTypes], None\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.hooks.Hooks</code>, <code>sob.abc.ArrayHooks</code></p> <p>Instances of this class hold functions (\"hooks\") to be executed at various points during marshalling, un-marshalling, serializing, de-serializing or validation.</p> <p>Please note the following context-specific definitions:</p> <ul> <li>marshal: To convert an instance of an <code>sob.Model</code> sub-class into data     suitable for serializing with <code>json.dumps</code>. For example, marshalling     an instance of <code>sob.Dictionary</code>, or marshalling an instance of a     sub-class of <code>sob.Object</code>, would result in a <code>dict</code> object.</li> <li>unmarshal: To convert data de-serialized using <code>json.loads</code> into an     instance of an <code>sob.Model</code> sub-class. For example, un-marshalling a     <code>dict</code> object could return in an instance of <code>sob.Dictionary</code>     (this would be the default if no types were specified), or could     return an instance of one of the <code>sob.Model</code> sub-classes     specified in the <code>types</code> parameter passed to <code>sob.unmarshal</code>.</li> <li>serialize: To convert a marshalled object into a JSON string.</li> <li>deserialize: To convert a JSON string into a python-native object.</li> <li>validate: To check that the data held by a model instance is in     compliance with that model's metadata. Because data types are     enforced when attributes are set, validation only entails verifying     that all required attributes are present, and that no extraneous     attributes are present. Validation is only initiated explicitly,     by passing a model instance to the <code>sob.validate</code> function.</li> </ul> <p>Attributes:</p> <ul> <li> <code>before_marshal</code>           \u2013            <p>A function called before marshalling a model. The <code>before_marshal</code> function should accept deserialized JSON data (pre-marshalling) as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>after_marshal</code>           \u2013            <p>A function to be called after marshalling a model. The <code>after_marshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_unmarshal</code>           \u2013            <p>A function to be called before un-marshalling a model. The <code>before_unmarshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_unmarshal</code>           \u2013            <p>A function to be called after un-marshalling a model. The <code>after_unmarshal</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>before_serialize</code>           \u2013            <p>A function to be called before serializing a model. The <code>before_serialize</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value. For most use cases, assigning a function to <code>after_unmarshal</code> and to <code>before_serialize</code> will produce the same result, however it is technically possible to unmarshal data without ever serializing it, so both hooks are provided.</p> </li> <li> <code>after_serialize</code>           \u2013            <p>A function to be called after serializing a model. The <code>after_serialize</code> function should accept a JSON string as the only argument, and return a JSON string as the return value.</p> </li> <li> <code>before_validate</code>           \u2013            <p>A function to be called before validating a model. The <code>before_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_validate</code>           \u2013            <p>A function to be called after validating a model. The <code>after_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_setitem</code>           \u2013            <p>A function to be called before assigning a value to an object by index. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the index, and the value to be assigned to that index position. The function should return a tuple containing an index and a value to be assigned to that position.</p> </li> <li> <code>after_setitem</code>           \u2013            <p>A function to be called after assigning a value to an object by index. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the index, and the value assigned to that position. The function should return <code>None</code>.</p> </li> <li> <code>before_append</code>           \u2013            <p>A function to be called before appending a value to the array. The <code>before_append</code> function should accept 2 positional arguments: an instance of the class to which it is associated, and the value to be appended. The function should return the value to be appended.</p> </li> <li> <code>after_append</code>           \u2013            <p>A function to be called after appending a value to the array. The <code>after_append</code> function should accept 2 positional arguments: an instance of the class to which it is associated, and the value appended. The function should return <code>None</code>.</p> </li> </ul> Source code in <code>sob/hooks.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[abc.Model], abc.Model] | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[abc.Model], abc.Model] | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[abc.Model], abc.Model] | None = None,\n    after_validate: Callable[[abc.Model], None] | None = None,\n    before_setitem: Callable[\n        [abc.Array, int, MarshallableTypes], tuple[int, MarshallableTypes]\n    ]\n    | None = None,\n    after_setitem: Callable[[abc.Array, int, MarshallableTypes], None]\n    | None = None,\n    before_append: Callable[\n        [abc.Array, MarshallableTypes], MarshallableTypes\n    ]\n    | None = None,\n    after_append: Callable[[abc.Array, MarshallableTypes], None]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        before_marshal=before_marshal,\n        after_marshal=after_marshal,\n        before_unmarshal=before_unmarshal,\n        after_unmarshal=after_unmarshal,\n        before_serialize=before_serialize,\n        after_serialize=after_serialize,\n        before_validate=before_validate,\n        after_validate=after_validate,\n    )\n    self.before_setitem = before_setitem\n    self.after_setitem = after_setitem\n    self.before_append = before_append\n    self.after_append = after_append\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.DictionaryHooks","title":"DictionaryHooks","text":"<pre><code>DictionaryHooks(\n    before_marshal: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_marshal: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    before_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.MarshallableTypes],\n            sob.abc.MarshallableTypes,\n        ]\n        | None\n    ) = None,\n    after_unmarshal: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    before_serialize: (\n        collections.abc.Callable[\n            [sob.abc.JSONTypes], sob.abc.JSONTypes\n        ]\n        | None\n    ) = None,\n    after_serialize: (\n        collections.abc.Callable[[str], str] | None\n    ) = None,\n    before_validate: (\n        collections.abc.Callable[\n            [sob.abc.Model], sob.abc.Model\n        ]\n        | None\n    ) = None,\n    after_validate: (\n        collections.abc.Callable[[sob.abc.Model], None]\n        | None\n    ) = None,\n    before_setitem: (\n        collections.abc.Callable[\n            [\n                sob.abc.Dictionary,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            tuple[str, sob.abc.MarshallableTypes],\n        ]\n        | None\n    ) = None,\n    after_setitem: (\n        collections.abc.Callable[\n            [\n                sob.abc.Dictionary,\n                str,\n                sob.abc.MarshallableTypes,\n            ],\n            None,\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.hooks.Hooks</code>, <code>sob.abc.DictionaryHooks</code></p> <p>Instances of this class hold functions (\"hooks\") to be executed at various points during marshalling, un-marshalling, serializing, de-serializing or validation.</p> <p>Please note the following context-specific definitions:</p> <ul> <li>marshal: To convert an instance of an <code>sob.Dictionary</code> sub-class into     data suitable for serializing with <code>json.dumps</code>. For example,     marshalling an instance of <code>sob.Dictionary</code> would result in a <code>dict</code>     object.</li> <li>unmarshal: To convert data de-serialized using <code>json.loads</code> into an     instance of an <code>sob.Model</code> sub-class. For example, un-marshalling a     <code>dict</code> object could return in an instance of <code>sob.Dictionary</code>     (this would be the default if no types were specified), or could     return an instance of one of the <code>sob.Model</code> sub-classes     specified in the <code>types</code> parameter passed to <code>sob.unmarshal</code>.</li> <li>serialize: To convert a marshalled object into a JSON string.</li> <li>deserialize: To convert a JSON string into a python-native object.</li> <li>validate: To check that the data held by a model instance is in     compliance with that model's metadata. Because data types are     enforced when attributes are set, validation only entails verifying     that all required attributes are present, and that no extraneous     attributes are present. Validation is only initiated explicitly,     by passing a model instance to the <code>sob.validate</code> function.</li> </ul> <p>Attributes:</p> <ul> <li> <code>before_marshal</code>           \u2013            <p>A function called before marshalling a model. The <code>before_marshal</code> function should accept deserialized JSON data (pre-marshalling) as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>after_marshal</code>           \u2013            <p>A function to be called after marshalling a model. The <code>after_marshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_unmarshal</code>           \u2013            <p>A function to be called before un-marshalling a model. The <code>before_unmarshal</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_unmarshal</code>           \u2013            <p>A function to be called after un-marshalling a model. The <code>after_unmarshal</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value.</p> </li> <li> <code>before_serialize</code>           \u2013            <p>A function to be called before serializing a model. The <code>before_serialize</code> function should accept unmarshalled, but pre-serialized, JSON serializable data as the first argument, and return the same type of data (or <code>None</code>) as the return value. For most use cases, assigning a function to <code>after_unmarshal</code> and to <code>before_serialize</code> will produce the same result, however it is technically possible to unmarshal data without ever serializing it, so both hooks are provided.</p> </li> <li> <code>after_serialize</code>           \u2013            <p>A function to be called after serializing a model. The <code>after_serialize</code> function should accept a JSON string as the only argument, and return a JSON string as the return value.</p> </li> <li> <code>before_validate</code>           \u2013            <p>A function to be called before validating a model. The <code>before_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>after_validate</code>           \u2013            <p>A function to be called after validating a model. The <code>after_validate</code> function should accept an instance of the class to which it is associated as the only argument, and must return an instance of that class as the return value.</p> </li> <li> <code>before_setitem</code>           \u2013            <p>A function to be called before assigning a value to an object by key. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the item key, and the value to be assigned to that key. The function should return a tuple containing a key and a value to be assigned.</p> </li> <li> <code>after_setitem</code>           \u2013            <p>A function to be called after assigning a value to an object by key. The <code>before_setitem</code> function should accept 3 positional arguments: an instance of the class to which it is associated, the item key, and the value assigned to that key. The function should return <code>None</code>.</p> </li> </ul> Source code in <code>sob/hooks.py</code> <pre><code>def __init__(\n    self,\n    before_marshal: Callable[[abc.Model], abc.Model] | None = None,\n    after_marshal: Callable[[JSONTypes], JSONTypes] | None = None,\n    before_unmarshal: Callable[[MarshallableTypes], MarshallableTypes]\n    | None = None,\n    after_unmarshal: Callable[[abc.Model], abc.Model] | None = None,\n    before_serialize: Callable[[JSONTypes], JSONTypes] | None = None,\n    after_serialize: Callable[[str], str] | None = None,\n    before_validate: Callable[[abc.Model], abc.Model] | None = None,\n    after_validate: Callable[[abc.Model], None] | None = None,\n    before_setitem: Callable[\n        [abc.Dictionary, str, MarshallableTypes],\n        tuple[str, MarshallableTypes],\n    ]\n    | None = None,\n    after_setitem: Callable[[abc.Dictionary, str, MarshallableTypes], None]\n    | None = None,\n):\n    super().__init__(\n        before_marshal=before_marshal,\n        after_marshal=after_marshal,\n        before_unmarshal=before_unmarshal,\n        after_unmarshal=after_unmarshal,\n        before_serialize=before_serialize,\n        after_serialize=after_serialize,\n        before_validate=before_validate,\n        after_validate=after_validate,\n    )\n    self.before_setitem = before_setitem\n    self.after_setitem = after_setitem\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.read_model_hooks","title":"read_model_hooks","text":"<pre><code>read_model_hooks(\n    model: type | sob.abc.Model,\n) -&gt; sob.abc.Hooks | None\n</code></pre> <p>Read the hooks associated with a sub-class or instance of <code>sob.Model</code>, or return <code>None</code> if no hooks are defined.</p> <p>Please note that the returned hooks may be inherited, and therefore should not be modified. Use <code>get_writable_model_hooks</code> to retrieve an instance of these hooks suitable for modification.</p> Source code in <code>sob/hooks.py</code> <pre><code>def read_model_hooks(model: type | abc.Model) -&gt; abc.Hooks | None:\n    \"\"\"\n    Read the hooks associated with a sub-class or instance of `sob.Model`,\n    or return `None` if no hooks are defined.\n\n    Please note that the returned hooks may be inherited,\n    and therefore should not be modified. Use `get_writable_model_hooks` to\n    retrieve an instance of these hooks suitable for modification.\n    \"\"\"\n    message: str\n    if isinstance(model, abc.Model):\n        return getattr(model, \"_instance_hooks\", None) or read_model_hooks(\n            type(model)\n        )\n    if isinstance(model, type) and issubclass(model, abc.Model):\n        base: type\n        try:\n            return next(\n                getattr(base, \"_class_hooks\", None)\n                for base in filter(\n                    lambda base: issubclass(base, abc.Model),\n                    model.__mro__,\n                )\n            )\n        except StopIteration:\n            return None\n    repr_model: str = represent(model)\n    message = (\n        \"{} requires a parameter which is an instance or sub-class of \"\n        \"`{}`, not{}\".format(\n            get_calling_function_qualified_name(),\n            get_qualified_name(abc.Model),\n            (f\":\\n{repr_model}\" if \"\\n\" in repr_model else f\" `{repr_model}`\"),\n        )\n    )\n    raise TypeError(message)\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.read_object_hooks","title":"read_object_hooks","text":"<pre><code>read_object_hooks(\n    model: type | sob.abc.Object,\n) -&gt; sob.abc.ObjectHooks | None\n</code></pre> <p>Read the hooks associated with a sub-class or instance of <code>sob.Object</code>, or return <code>None</code> if no hooks are defined.</p> <p>Please note that the returned hooks may be inherited, and therefore should not be modified. Use <code>get_writable_object_hooks</code> to retrieve an instance of these hooks suitable for modification.</p> Source code in <code>sob/hooks.py</code> <pre><code>def read_object_hooks(model: type | abc.Object) -&gt; abc.ObjectHooks | None:\n    \"\"\"\n    Read the hooks associated with a sub-class or instance of `sob.Object`,\n    or return `None` if no hooks are defined.\n\n    Please note that the returned hooks may be inherited,\n    and therefore should not be modified. Use `get_writable_object_hooks` to\n    retrieve an instance of these hooks suitable for modification.\n    \"\"\"\n    return read_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.read_array_hooks","title":"read_array_hooks","text":"<pre><code>read_array_hooks(\n    model: type | sob.abc.Array,\n) -&gt; sob.abc.ArrayHooks | None\n</code></pre> <p>Read the hooks associated with a sub-class or instance of <code>sob.Array</code>, or return <code>None</code> if no hooks are defined.</p> <p>Please note that the returned hooks may be inherited, and therefore should not be modified. Use <code>get_writable_array_hooks</code> to retrieve an instance of these hooks suitable for modification.</p> Source code in <code>sob/hooks.py</code> <pre><code>def read_array_hooks(model: type | abc.Array) -&gt; abc.ArrayHooks | None:\n    \"\"\"\n    Read the hooks associated with a sub-class or instance of `sob.Array`,\n    or return `None` if no hooks are defined.\n\n    Please note that the returned hooks may be inherited,\n    and therefore should not be modified. Use\n    `get_writable_array_hooks` to retrieve an instance of these hooks\n    suitable for modification.\n    \"\"\"\n    return read_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.read_dictionary_hooks","title":"read_dictionary_hooks","text":"<pre><code>read_dictionary_hooks(\n    model: type | sob.abc.Dictionary,\n) -&gt; sob.abc.DictionaryHooks | None\n</code></pre> <p>Read hooks from a sub-class or instance of <code>sob.Dictionary</code>.</p> <p>Please note that the returned hooks may be inherited, and therefore should not be modified. Use <code>get_writable_dictionary_hooks</code> to retrieve an instance of these hooks suitable for modification.</p> Source code in <code>sob/hooks.py</code> <pre><code>def read_dictionary_hooks(\n    model: type | abc.Dictionary,\n) -&gt; abc.DictionaryHooks | None:\n    \"\"\"\n    Read hooks from a sub-class or instance of `sob.Dictionary`.\n\n    Please note that the returned hooks may be inherited,\n    and therefore should not be modified. Use `get_writable_dictionary_hooks`\n    to retrieve an instance of these hooks suitable for modification.\n    \"\"\"\n    return read_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.get_writable_model_hooks","title":"get_writable_model_hooks","text":"<pre><code>get_writable_model_hooks(\n    model: type[sob.abc.Model] | sob.abc.Model,\n) -&gt; sob.abc.Hooks\n</code></pre> <p>Retrieve an instance of <code>sob.Hooks</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Model</code> sub-class, and the instance does not have any hooks associated, the class hooks will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Model</code>, but does not have any hooks associated, hooks will be copied from the first parent class which has hooks attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any hooks associated\u2014a new instance of <code>sob.Hooks</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>sob/hooks.py</code> <pre><code>def get_writable_model_hooks(model: type[abc.Model] | abc.Model) -&gt; abc.Hooks:\n    \"\"\"\n    Retrieve an instance of `sob.Hooks` which is associated directly with the\n    `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Model` sub-class, and the instance\n    does not have any hooks associated, the class hooks will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Model`, but does not have any hooks\n    associated, hooks will be copied from the first parent class which\n    has hooks attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any hooks associated\u2014a new instance of `sob.Hooks` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    if not _is_model(model):\n        raise TypeError(model)\n    if isinstance(model, abc.Model):\n        if model._instance_hooks is None:  # noqa: SLF001\n            model._instance_hooks = deepcopy(  # noqa: SLF001\n                read_model_hooks(type(model))\n            )\n        if model._instance_hooks is None:  # noqa: SLF001\n            model._instance_hooks = (  # noqa: SLF001\n                ObjectHooks()\n                if isinstance(model, abc.Object)\n                else ArrayHooks()\n                if isinstance(model, abc.Array)\n                else DictionaryHooks()\n            )\n        return model._instance_hooks  # noqa: SLF001\n    if isinstance(model, type) and issubclass(model, abc.Model):\n        if model._class_hooks is None:  # noqa: SLF001\n            model._class_hooks = deepcopy(  # noqa: SLF001\n                read_model_hooks(model)\n            )\n        if model._class_hooks is None:  # noqa: SLF001\n            model._class_hooks = (  # noqa: SLF001\n                ObjectHooks()\n                if issubclass(model, abc.Object)\n                else ArrayHooks()\n                if issubclass(model, abc.Array)\n                else DictionaryHooks()\n            )\n        return model._class_hooks  # noqa: SLF001\n    repr_model: str = represent(model)\n    message: str = (\n        \"{} requires a parameter which is an instance or sub-class of \"\n        \"`{}`, not{}\".format(\n            get_calling_function_qualified_name(),\n            get_qualified_name(abc.Model),\n            (\":\\n\" + repr_model if \"\\n\" in repr_model else f\" `{repr_model}`\"),\n        )\n    )\n    raise TypeError(message)\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.get_writable_object_hooks","title":"get_writable_object_hooks","text":"<pre><code>get_writable_object_hooks(\n    model: type | sob.abc.Object,\n) -&gt; sob.abc.ObjectHooks\n</code></pre> <p>Retrieve an instance of <code>sob.ObjectHooks</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Object</code> sub-class, and the instance does not have any hooks associated, the class hooks will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Object</code>, but does not have any hooks associated, hooks will be copied from the first parent class which has hooks attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any hooks associated\u2014a new instance of <code>sob.ObjectHooks</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>sob/hooks.py</code> <pre><code>def get_writable_object_hooks(model: type | abc.Object) -&gt; abc.ObjectHooks:\n    \"\"\"\n    Retrieve an instance of `sob.ObjectHooks` which is associated directly with\n    the `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Object` sub-class, and the instance\n    does not have any hooks associated, the class hooks will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Object`, but does not have any hooks\n    associated, hooks will be copied from the first parent class which\n    has hooks attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any hooks associated\u2014a new instance of `sob.ObjectHooks` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.get_writable_array_hooks","title":"get_writable_array_hooks","text":"<pre><code>get_writable_array_hooks(\n    model: type | sob.abc.Array,\n) -&gt; sob.abc.ArrayHooks\n</code></pre> <p>Retrieve an instance of <code>sob.ArrayHooks</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Array</code> sub-class, and the instance does not have any hooks associated, the class hooks will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Array</code>, but does not have any hooks associated, hooks will be copied from the first parent class which has hooks attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any hooks associated\u2014a new instance of <code>sob.ArrayHooks</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>sob/hooks.py</code> <pre><code>def get_writable_array_hooks(model: type | abc.Array) -&gt; abc.ArrayHooks:\n    \"\"\"\n    Retrieve an instance of `sob.ArrayHooks` which is associated directly with\n    the `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Array` sub-class, and the instance\n    does not have any hooks associated, the class hooks will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Array`, but does not have any hooks\n    associated, hooks will be copied from the first parent class which\n    has hooks attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any hooks associated\u2014a new instance of `sob.ArrayHooks` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.get_writable_dictionary_hooks","title":"get_writable_dictionary_hooks","text":"<pre><code>get_writable_dictionary_hooks(\n    model: type | sob.abc.Dictionary,\n) -&gt; sob.abc.DictionaryHooks\n</code></pre> <p>Retrieve an instance of <code>sob.DictionaryHooks</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for writing hooks to.</p> <p>If <code>model</code> is an instance of an <code>sob.Dictionary</code> sub-class, and the instance does not have any hooks associated, the parent class'es hooks will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Dictionary</code>, but does not have any hooks associated, hooks will be copied from the first parent class which does have hooks attributed.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any hooks associated\u2014a new instance of <code>sob.DictionaryHooks</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>sob/hooks.py</code> <pre><code>def get_writable_dictionary_hooks(\n    model: type | abc.Dictionary,\n) -&gt; abc.DictionaryHooks:\n    \"\"\"\n    Retrieve an instance of `sob.DictionaryHooks` which is associated directly\n    with the `model` class or instance, and therefore suitable for writing\n    hooks to.\n\n    If `model` is an instance of an `sob.Dictionary` sub-class, and the\n    instance does not have any hooks associated, the parent class'es hooks will\n    be copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Dictionary`, but does not have any hooks\n    associated, hooks will be copied from the first parent class which does\n    have hooks attributed.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any hooks associated\u2014a new instance of `sob.DictionaryHooks` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_hooks(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.get_model_hooks_type","title":"get_model_hooks_type","text":"<pre><code>get_model_hooks_type(model: type | sob.abc.Model) -&gt; type\n</code></pre> <p>Determine the type of metadata required for the specified <code>model</code> class or instance.</p> Source code in <code>sob/hooks.py</code> <pre><code>def get_model_hooks_type(model: type | abc.Model) -&gt; type:\n    \"\"\"\n    Determine the type of metadata required for the specified `model`\n    class or instance.\n    \"\"\"\n    hooks_type: type\n    if not isinstance(model, (type, abc.Object, abc.Dictionary, abc.Array)):\n        raise TypeError(model)\n    if isinstance(model, type):\n        if not issubclass(model, (abc.Object, abc.Dictionary, abc.Array)):\n            raise TypeError(model)\n        hooks_type = (\n            ObjectHooks\n            if issubclass(model, abc.Object)\n            else ArrayHooks\n            if issubclass(model, abc.Array)\n            else DictionaryHooks\n        )\n    else:\n        hooks_type = (\n            ObjectHooks\n            if isinstance(model, abc.Object)\n            else ArrayHooks\n            if isinstance(model, abc.Array)\n            else DictionaryHooks\n        )\n    return hooks_type\n</code></pre>"},{"location":"api/sob.hooks/#sob.hooks.write_model_hooks","title":"write_model_hooks","text":"<pre><code>write_model_hooks(\n    model: type[sob.abc.Model] | sob.abc.Model,\n    hooks: sob.abc.Hooks | None,\n) -&gt; None\n</code></pre> <p>Write hooks to a sub-class or instance of <code>sob.Model</code>.</p> Source code in <code>sob/hooks.py</code> <pre><code>def write_model_hooks(\n    model: type[abc.Model] | abc.Model, hooks: abc.Hooks | None\n) -&gt; None:\n    \"\"\"\n    Write hooks to a sub-class or instance of `sob.Model`.\n    \"\"\"\n    if hooks is not None:\n        # Verify that the metadata is of the correct type\n        hooks_type: type[abc.Hooks] = get_model_hooks_type(model)\n        if not isinstance(hooks, hooks_type):\n            message: str = (\n                f\"Hooks assigned to `{get_qualified_name(type(model))}` \"\n                f\"must be of type `{get_qualified_name(hooks_type)}`\"\n            )\n            raise ValueError(message)\n    if isinstance(model, abc.Model):\n        model._instance_hooks = hooks  # noqa: SLF001\n    else:\n        if not issubclass(model, abc.Model):\n            raise TypeError(model)\n        model._class_hooks = hooks  # noqa: SLF001\n</code></pre>"},{"location":"api/sob.meta/","title":"sob.meta","text":""},{"location":"api/sob.meta/#sob.meta","title":"sob.meta","text":""},{"location":"api/sob.meta/#sob.meta.Meta","title":"Meta","text":"<p>               Bases: <code>sob.abc.Meta</code></p> <p>This is a base class for <code>sob.ObjectMeta</code>, <code>sob.ArrayMeta</code>, and <code>sob.DictionaryMeta</code>, and implements methods common to these three classes.</p>"},{"location":"api/sob.meta/#sob.meta.ObjectMeta","title":"ObjectMeta","text":"<pre><code>ObjectMeta(\n    properties: (\n        collections.abc.Mapping[str, sob.abc.Property]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.Property]\n        ]\n        | sob.abc.Properties\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.meta.Meta</code>, <code>sob.abc.ObjectMeta</code></p> <p>This class holds metadata for a sub-class or instance of <code>sob.Object</code>.</p> <p>Attributes:</p> <ul> <li> <code>properties</code>               (<code>sob.abc.Properties | None</code>)           \u2013            <p>This is a dictionary-like object mapping property names to a corresponding instance (or sub-class instance) of <code>sob.Property</code>  for a sub-class or sub-class instance of <code>sob.Object</code> . Attempting to set values for a property which do not correspond to the property metadata will raise a <code>TypeError</code>. Deserializing data with dictionary keys not corresponding to a defined property will not raise an error on deserializing, but will raise an <code>sob.ValidationError</code>  when/if the instance is validated using <code>sob.validate</code> .</p> </li> </ul> Source code in <code>sob/meta.py</code> <pre><code>def __init__(\n    self,\n    properties: Mapping[str, abc.Property]\n    | Iterable[tuple[str, abc.Property]]\n    | abc.Properties\n    | None = None,\n) -&gt; None:\n    self._properties: abc.Properties | None = None\n    self.properties = properties  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.DictionaryMeta","title":"DictionaryMeta","text":"<pre><code>DictionaryMeta(\n    value_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n        | sob.abc.Property\n        | type\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.meta.Meta</code>, <code>sob.abc.DictionaryMeta</code></p> <p>This class holds metadata for a sub-class or instance of <code>sob.Dictionary</code>.</p> <p>Attributes:</p> <ul> <li> <code>value_types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>This is a sequence of types and/or instances of <code>sob.Property</code>  or one of its sub-classes determining the types of values which can be stored in a sub-class or sub-class instance of <code>sob.Dictionary</code> . Attempting to set values of a type not described by the dictionary value types will raise a <code>TypeError</code>.</p> </li> </ul> Source code in <code>sob/meta.py</code> <pre><code>def __init__(\n    self,\n    value_types: Iterable[abc.Property | type]\n    | abc.Types\n    | None\n    | abc.Property\n    | type = None,\n) -&gt; None:\n    self._value_types: abc.Types | None = None\n    self.value_types = value_types  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.ArrayMeta","title":"ArrayMeta","text":"<pre><code>ArrayMeta(\n    item_types: (\n        collections.abc.Iterable[sob.abc.Property | type]\n        | sob.abc.Types\n        | None\n        | sob.abc.Property\n        | type\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.meta.Meta</code>, <code>sob.abc.ArrayMeta</code></p> <p>This class holds metadata for a sub-class or instance of <code>sob.Array</code>.</p> <p>Attributes:</p> <ul> <li> <code>item_types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>This is a sequence of types and/or instances of <code>sob.Property</code>  or one of its sub-classes determining the types of items which can be stored in a sub-class or sub-class instance of <code>sob.Array</code> . Attempting to insert or append items of a type not described by the array item types will raise a <code>TypeError</code>.</p> </li> </ul> Source code in <code>sob/meta.py</code> <pre><code>def __init__(\n    self,\n    item_types: Iterable[abc.Property | type]\n    | abc.Types\n    | None\n    | abc.Property\n    | type = None,\n):\n    self._item_types: abc.Types | None = None\n    self.item_types = item_types  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.Properties","title":"Properties","text":"<pre><code>Properties(\n    items: (\n        collections.abc.Mapping[str, sob.abc.Property]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.Property]\n        ]\n        | sob.abc.Properties\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Properties</code></p> <p>Instances of this class are dictionary-like objects mapping property names to a corresponding instance (or sub-class instance) of <code>sob.Property</code> .</p> Source code in <code>sob/meta.py</code> <pre><code>def __init__(\n    self,\n    items: Mapping[str, abc.Property]\n    | Iterable[tuple[str, abc.Property]]\n    | abc.Properties\n    | None = None,\n) -&gt; None:\n    self._dict: dict[str, abc.Property] = {}\n    if items is not None:\n        self.update(items)\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.read_model_meta","title":"read_model_meta","text":"<pre><code>read_model_meta(\n    model: type | sob.abc.Model,\n) -&gt; sob.abc.Meta | None\n</code></pre> <p>Read the metadata associated with a sub-class or instance of <code>sob.Model</code>, or return <code>None</code> if no metadata is defined.</p> <p>Please note that the returned metadata may be inherited, and therefore should not be modified. Use <code>get_writable_model_meta</code> to retrieve an instance of this metadata suitable for modification.</p> Source code in <code>sob/meta.py</code> <pre><code>def read_model_meta(model: type | abc.Model) -&gt; abc.Meta | None:\n    \"\"\"\n    Read the metadata associated with a sub-class or instance of `sob.Model`,\n    or return `None` if no metadata is defined.\n\n    Please note that the returned metadata may be inherited,\n    and therefore should not be modified. Use `get_writable_model_meta` to\n    retrieve an instance of this metadata suitable for modification.\n    \"\"\"\n    message: str\n    if isinstance(model, abc.Model):\n        return getattr(model, \"_instance_meta\", None) or read_model_meta(\n            type(model)\n        )\n    if isinstance(model, type) and issubclass(model, abc.Model):\n        base: type | None\n        try:\n            return next(\n                getattr(base, \"_class_meta\", None)\n                for base in filter(\n                    lambda base: issubclass(base, abc.Model),\n                    model.__mro__,\n                )\n            )\n        except StopIteration:\n            return None\n    repr_model: str = represent(model)\n    message = (\n        \"{} requires a parameter which is an instance or sub-class of \"\n        \"`{}`, not{}\".format(\n            get_calling_function_qualified_name(),\n            get_qualified_name(abc.Model),\n            (f\":\\n{repr_model}\" if \"\\n\" in repr_model else f\" `{repr_model}`\"),\n        )\n    )\n    raise TypeError(message)\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.read_object_meta","title":"read_object_meta","text":"<pre><code>read_object_meta(\n    model: type | sob.abc.Object,\n) -&gt; sob.abc.ObjectMeta | None\n</code></pre> <p>Read the metadata associated with a sub-class or instance of <code>sob.Object</code>, or return <code>None</code> if no metadata is defined.</p> <p>Please note that the returned metadata may be inherited, and therefore should not be modified. Use <code>get_writable_object_meta</code> to retrieve an instance of this metadata suitable for modification.</p> Source code in <code>sob/meta.py</code> <pre><code>def read_object_meta(model: type | abc.Object) -&gt; abc.ObjectMeta | None:\n    \"\"\"\n    Read the metadata associated with a sub-class or instance of `sob.Object`,\n    or return `None` if no metadata is defined.\n\n    Please note that the returned metadata may be inherited,\n    and therefore should not be modified. Use `get_writable_object_meta` to\n    retrieve an instance of this metadata suitable for modification.\n    \"\"\"\n    return read_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.read_array_meta","title":"read_array_meta","text":"<pre><code>read_array_meta(\n    model: type | sob.abc.Array,\n) -&gt; sob.abc.ArrayMeta | None\n</code></pre> <p>Read the metadata associated with a sub-class or instance of <code>sob.Array</code>, or return <code>None</code> if no metadata is defined.</p> <p>Please note that the returned metadata may be inherited, and therefore should not be modified. Use <code>get_writable_array_meta</code> to retrieve an instance of this metadata suitable for modification.</p> Source code in <code>sob/meta.py</code> <pre><code>def read_array_meta(model: type | abc.Array) -&gt; abc.ArrayMeta | None:\n    \"\"\"\n    Read the metadata associated with a sub-class or instance of `sob.Array`,\n    or return `None` if no metadata is defined.\n\n    Please note that the returned metadata may be inherited,\n    and therefore should not be modified. Use `get_writable_array_meta` to\n    retrieve an instance of this metadata suitable for modification.\n    \"\"\"\n    return read_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.read_dictionary_meta","title":"read_dictionary_meta","text":"<pre><code>read_dictionary_meta(\n    model: type[sob.abc.Dictionary] | sob.abc.Dictionary,\n) -&gt; sob.abc.DictionaryMeta | None\n</code></pre> <p>Read metadata from a sub-class or instance of <code>sob.Dictionary</code>.</p> <p>Please note that the returned metadata may be inherited, and therefore should not be modified. Use <code>get_writable_dictionary_hooks</code> to retrieve an instance of this metadata suitable for modification.</p> Source code in <code>sob/meta.py</code> <pre><code>def read_dictionary_meta(\n    model: type[abc.Dictionary] | abc.Dictionary,\n) -&gt; abc.DictionaryMeta | None:\n    \"\"\"\n    Read metadata from a sub-class or instance of `sob.Dictionary`.\n\n    Please note that the returned metadata may be inherited,\n    and therefore should not be modified. Use `get_writable_dictionary_hooks`\n    to retrieve an instance of this metadata suitable for modification.\n    \"\"\"\n    return read_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.get_writable_model_meta","title":"get_writable_model_meta","text":"<pre><code>get_writable_model_meta(\n    model: type | sob.abc.Model,\n) -&gt; sob.abc.Meta\n</code></pre> <p>Retrieve an instance of <code>sob.Meta</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Model</code> sub-class, and the instance does not have any metadata associated, the class hooks will be copied to the instance and returned</p> <p>If <code>model</code> is a sub-class of <code>sob.Model</code>, but does not have any metadata associated, hooks will be copied from the first parent class which has metadata attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any metadata associated\u2014a new instance of <code>sob.Meta</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>sob/meta.py</code> <pre><code>def get_writable_model_meta(model: type | abc.Model) -&gt; abc.Meta:\n    \"\"\"\n    Retrieve an instance of `sob.Meta` which is associated directly with the\n    `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Model` sub-class, and the instance\n    does not have any metadata associated, the class hooks will be\n    copied to the instance and returned\n\n    If `model` is a sub-class of `sob.Model`, but does not have any metadata\n    associated, hooks will be copied from the first parent class which\n    has metadata attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any metadata associated\u2014a new instance of `sob.Meta` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    if not _is_model(model):\n        raise TypeError(model)\n    if isinstance(model, abc.Model):\n        if model._instance_meta is None:  # noqa: SLF001\n            model._instance_meta = deepcopy(  # noqa: SLF001\n                read_model_meta(type(model))\n            )\n        if model._instance_meta is None:  # noqa: SLF001\n            model._instance_meta = (  # noqa: SLF001\n                ObjectMeta()\n                if isinstance(model, abc.Object)\n                else ArrayMeta()\n                if isinstance(model, abc.Array)\n                else DictionaryMeta()\n            )\n        return model._instance_meta  # noqa: SLF001\n    if isinstance(model, type) and issubclass(model, abc.Model):\n        if model._class_meta is None:  # noqa: SLF001\n            model._class_meta = deepcopy(  # noqa: SLF001\n                read_model_meta(model)\n            )\n        if model._class_meta is None:  # noqa: SLF001\n            model._class_meta = (  # noqa: SLF001\n                ObjectMeta()\n                if issubclass(model, abc.Object)\n                else ArrayMeta()\n                if issubclass(model, abc.Array)\n                else DictionaryMeta()\n            )\n        return model._class_meta  # noqa: SLF001\n    repr_model: str = represent(model)\n    message: str = (\n        \"{} requires a parameter which is an instance or sub-class of \"\n        \"`{}`, not{}\".format(\n            get_calling_function_qualified_name(),\n            get_qualified_name(abc.Model),\n            (\":\\n\" + repr_model if \"\\n\" in repr_model else f\" `{repr_model}`\"),\n        )\n    )\n    raise TypeError(message)\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.get_writable_object_meta","title":"get_writable_object_meta","text":"<pre><code>get_writable_object_meta(\n    object_: type[sob.abc.Object] | sob.abc.Object,\n) -&gt; sob.abc.ObjectMeta\n</code></pre> <p>Retrieve an instance of <code>sob.ObjectMeta</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Object</code> sub-class, and the instance does not have any metadata associated, the class metadata will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Object</code>, but does not have any metadata associated, metadata will be copied from the first parent class which has metadata attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any metadata associated\u2014a new instance of <code>sob.ObjectMeta</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>sob/meta.py</code> <pre><code>def get_writable_object_meta(\n    object_: type[abc.Object] | abc.Object,\n) -&gt; abc.ObjectMeta:\n    \"\"\"\n    Retrieve an instance of `sob.ObjectMeta` which is associated directly with\n    the `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Object` sub-class, and the instance\n    does not have any metadata associated, the class metadata will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Object`, but does not have any metadata\n    associated, metadata will be copied from the first parent class which\n    has metadata attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any metadata associated\u2014a new instance of `sob.ObjectMeta` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_meta(object_)  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.get_writable_array_meta","title":"get_writable_array_meta","text":"<pre><code>get_writable_array_meta(\n    model: type | sob.abc.Array,\n) -&gt; sob.abc.ArrayMeta\n</code></pre> <p>Retrieve an instance of <code>sob.ArrayMeta</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for modifying.</p> <p>If <code>model</code> is an instance of an <code>sob.Array</code> sub-class, and the instance does not have any metadata associated, the class metadata will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Array</code>, but does not have any metadata associated, metadata will be copied from the first parent class which has metadata attributed, and the copy will be returned.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any metadata associated\u2014a new instance of <code>sob.ArrayMeta</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>sob/meta.py</code> <pre><code>def get_writable_array_meta(model: type | abc.Array) -&gt; abc.ArrayMeta:\n    \"\"\"\n    Retrieve an instance of `sob.ArrayMeta` which is associated directly with\n    the `model` class or instance, and therefore suitable for modifying.\n\n    If `model` is an instance of an `sob.Array` sub-class, and the instance\n    does not have any metadata associated, the class metadata will be\n    copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Array`, but does not have any metadata\n    associated, metadata will be copied from the first parent class which\n    has metadata attributed, and the copy will be returned.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any metadata associated\u2014a new instance of `sob.ArrayMeta` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.get_writable_dictionary_meta","title":"get_writable_dictionary_meta","text":"<pre><code>get_writable_dictionary_meta(\n    model: type | sob.abc.Dictionary,\n) -&gt; sob.abc.DictionaryMeta\n</code></pre> <p>Retrieve an instance of <code>sob.DictionaryMeta</code> which is associated directly with the <code>model</code> class or instance, and therefore suitable for writing metadata to.</p> <p>If <code>model</code> is an instance of an <code>sob.Dictionary</code> sub-class, and the instance does not have any metadata associated, the parent class metadata will be copied to the instance and returned.</p> <p>If <code>model</code> is a sub-class of <code>sob.Dictionary</code>, but does not have any metadata associated, metadata will be copied from the first parent class which does have metadata attributed.</p> <p>If neither the <code>model</code> class or instance, nor any parent classes, have any metadata associated\u2014a new instance of <code>sob.DictionaryMeta</code> will be created, attributed to <code>model</code>, and returned.</p> Source code in <code>sob/meta.py</code> <pre><code>def get_writable_dictionary_meta(\n    model: type | abc.Dictionary,\n) -&gt; abc.DictionaryMeta:\n    \"\"\"\n    Retrieve an instance of `sob.DictionaryMeta` which is associated directly\n    with the `model` class or instance, and therefore suitable for writing\n    metadata to.\n\n    If `model` is an instance of an `sob.Dictionary` sub-class, and the\n    instance does not have any metadata associated, the parent class metadata\n    will be copied to the instance and returned.\n\n    If `model` is a sub-class of `sob.Dictionary`, but does not have any\n    metadata associated, metadata will be copied from the first parent class\n    which does have metadata attributed.\n\n    If neither the `model` class or instance, nor any parent classes,\n    have any metadata associated\u2014a new instance of `sob.DictionaryMeta` will be\n    created, attributed to `model`, and returned.\n    \"\"\"\n    return get_writable_model_meta(model)  # type: ignore\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.get_model_meta_type","title":"get_model_meta_type","text":"<pre><code>get_model_meta_type(model: type | sob.abc.Model) -&gt; type\n</code></pre> <p>Determine the type of metadata required for the specified <code>model</code> class or instance.</p> Source code in <code>sob/meta.py</code> <pre><code>def get_model_meta_type(model: type | abc.Model) -&gt; type:\n    \"\"\"\n    Determine the type of metadata required for the specified `model`\n    class or instance.\n    \"\"\"\n    meta_type: type | None\n    if not isinstance(model, (type, abc.Object, abc.Dictionary, abc.Array)):\n        raise TypeError(model)\n    if isinstance(model, type):\n        if not issubclass(model, (abc.Object, abc.Dictionary, abc.Array)):\n            raise TypeError(model)\n        meta_type = (\n            ObjectMeta\n            if issubclass(model, abc.Object)\n            else ArrayMeta\n            if issubclass(model, abc.Array)\n            else DictionaryMeta\n        )\n    else:\n        meta_type = (\n            ObjectMeta\n            if isinstance(model, abc.Object)\n            else ArrayMeta\n            if isinstance(model, abc.Array)\n            else DictionaryMeta\n        )\n    return meta_type\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.write_model_meta","title":"write_model_meta","text":"<pre><code>write_model_meta(\n    model: type[sob.abc.Model] | sob.abc.Model,\n    meta: sob.abc.Meta | None,\n) -&gt; None\n</code></pre> <p>Write metadata to a sub-class or instance of <code>sob.Model</code>.</p> Source code in <code>sob/meta.py</code> <pre><code>def write_model_meta(\n    model: type[abc.Model] | abc.Model, meta: abc.Meta | None\n) -&gt; None:\n    \"\"\"\n    Write metadata to a sub-class or instance of `sob.Model`.\n    \"\"\"\n    if meta is not None:\n        # Verify that the metadata is of the correct type\n        meta_type: type[abc.Meta] = get_model_meta_type(model)\n        if not isinstance(meta, meta_type):\n            message: str = (\n                f\"Metadata assigned to `{get_qualified_name(type(model))}` \"\n                f\"must be of type `{get_qualified_name(meta_type)}`\"\n            )\n            raise ValueError(message)\n    if isinstance(model, abc.Model):\n        model._instance_meta = meta  # noqa: SLF001\n    else:\n        if not issubclass(model, abc.Model):\n            raise TypeError(model)\n        model._class_meta = meta  # noqa: SLF001\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.get_model_pointer","title":"get_model_pointer","text":"<pre><code>get_model_pointer(model: sob.abc.Model) -&gt; str | None\n</code></pre> <p>Get the JSON pointer associated with this model. Please note that this will typically only be available for models which have been deserialized from JSON data, otherwise, this function will return <code>None</code> (unless explicitly set using <code>set_model_pointer</code> on this instance, or a parent).</p> Source code in <code>sob/meta.py</code> <pre><code>def get_model_pointer(model: abc.Model) -&gt; str | None:\n    \"\"\"\n    Get the JSON pointer associated with this model. Please note that this\n    will typically only be available for models which have been deserialized\n    from JSON data, otherwise, this function will return `None` (unless\n    explicitly set using `set_model_pointer` on this instance, or a parent).\n    \"\"\"\n    return model._pointer  # noqa: SLF001\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.set_model_pointer","title":"set_model_pointer","text":"<pre><code>set_model_pointer(\n    model: sob.abc.Model, pointer_: str | None\n) -&gt; None\n</code></pre> <p>Set the JSON pointer associated with this model, and all models assigned to object properties, array items, or dictionary values of this model.</p> Source code in <code>sob/meta.py</code> <pre><code>def set_model_pointer(model: abc.Model, pointer_: str | None) -&gt; None:\n    \"\"\"\n    Set the JSON pointer associated with this model, and all models\n    assigned to object properties, array items, or dictionary values\n    of this model.\n    \"\"\"\n    key: str\n    value: Any\n    model._pointer = pointer_  # noqa: SLF001\n    if isinstance(model, abc.Dictionary):\n        for key, value in model.items():\n            if isinstance(\n                value,\n                (abc.Object, abc.Dictionary, abc.Array),\n            ):\n                set_model_pointer(\n                    value,\n                    \"{}/{}\".format(\n                        pointer_,\n                        (\n                            escape_reference_token(key)\n                            if isinstance(key, str)\n                            else str(key)\n                        ),\n                    ),\n                )\n    elif isinstance(model, abc.Object):\n        property_name: str\n        property_: abc.Property\n        for property_name, property_ in _read_object_properties(model) or ():\n            key = property_.name or property_name\n            value = getattr(model, property_name)\n            if isinstance(\n                value,\n                (abc.Object, abc.Dictionary, abc.Array),\n            ):\n                set_model_pointer(\n                    value,\n                    \"{}/{}\".format(\n                        pointer_,\n                        (\n                            escape_reference_token(key)\n                            if isinstance(key, str)\n                            else str(key)\n                        ),\n                    ),\n                )\n    elif isinstance(model, abc.Array):\n        index: int\n        for index in range(len(model)):\n            value = model[index]\n            if isinstance(\n                value,\n                (abc.Object, abc.Dictionary, abc.Array),\n            ):\n                set_model_pointer(value, f\"{pointer_}/{index!s}\")\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.pointer","title":"pointer","text":"<pre><code>pointer(\n    model: sob.abc.Model, pointer_: str | None = None\n) -&gt; str | None\n</code></pre> <p>Get or set a model's pointer</p> Source code in <code>sob/meta.py</code> <pre><code>@deprecated(\n    \"`sob.meta.pointer` is deprecated and will be removed in sob 3. \"\n    \"Use `sob.get_model_pointer` and `sob.set_model_pointer` \"\n    \"instead.\",\n)\ndef pointer(model: abc.Model, pointer_: str | None = None) -&gt; str | None:\n    \"\"\"\n    Get or set a model's pointer\n    \"\"\"\n    if not isinstance(model, (abc.Object, abc.Dictionary, abc.Array)):\n        raise TypeError(model)\n    if pointer_ is not None:\n        set_model_pointer(model, pointer_)\n    return get_model_pointer(model)\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.set_model_url","title":"set_model_url","text":"<pre><code>set_model_url(\n    model_instance: sob.abc.Model, source_url: str | None\n) -&gt; None\n</code></pre> <p>Set a source URL to be associated with this model, and all models assigned to object properties, array items, or dictionary values of this model.</p> Source code in <code>sob/meta.py</code> <pre><code>def set_model_url(model_instance: abc.Model, source_url: str | None) -&gt; None:\n    \"\"\"\n    Set a source URL to be associated with this model, and all models\n    assigned to object properties, array items, or dictionary values\n    of this model.\n    \"\"\"\n    if not isinstance(model_instance, (abc.Object, abc.Dictionary, abc.Array)):\n        raise TypeError(model_instance)\n    if (source_url is not None) and not isinstance(source_url, str):\n        raise TypeError(source_url)\n    model_instance._url = source_url  # noqa: SLF001\n    child_model: abc.Model\n    for child_model in _traverse_models(model_instance):\n        set_model_url(child_model, source_url)\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.get_model_url","title":"get_model_url","text":"<pre><code>get_model_url(model: sob.abc.Model) -&gt; str | None\n</code></pre> <p>Get the source URL from which this model was deserialized.</p> Source code in <code>sob/meta.py</code> <pre><code>def get_model_url(model: abc.Model) -&gt; str | None:\n    \"\"\"\n    Get the source URL from which this model was deserialized.\n    \"\"\"\n    return model._url  # noqa: SLF001\n</code></pre>"},{"location":"api/sob.meta/#sob.meta.version_model","title":"version_model","text":"<pre><code>version_model(\n    data: sob.abc.Model,\n    specification: str,\n    version_number: (\n        str | int | collections.abc.Sequence[int]\n    ),\n) -&gt; None\n</code></pre> <p>Recursively alters model class or instance metadata based on version number metadata associated with an object's properties. This allows one data model to represent multiple versions of a specification and dynamically change based on the version of a specification represented.</p> <p>Parameters:</p> <ul> <li>data (sob.model.Model)</li> <li>specification (str): The specification to which the <code>version_number</code>   argument applies.</li> <li>version_number (str|int|[int]): A version number represented as text   (in the form of integers separated by periods), an integer, or a   sequence of integers.</li> </ul> Source code in <code>sob/meta.py</code> <pre><code>def version_model(\n    data: abc.Model,\n    specification: str,\n    version_number: str | int | Sequence[int],\n) -&gt; None:\n    \"\"\"\n    Recursively alters model class or instance metadata based on version number\n    metadata associated with an object's properties. This allows one data model\n    to represent multiple versions of a specification and dynamically change\n    based on the version of a specification represented.\n\n    Parameters:\n\n    - data ([sob.model.Model](#Model))\n    - specification (str): The specification to which the `version_number`\n      argument applies.\n    - version_number (str|int|[int]): A version number represented as text\n      (in the form of integers separated by periods), an integer, or a\n      sequence of integers.\n    \"\"\"\n    if not (\n        isinstance(version_number, (str, float))\n        or (\n            isinstance(version_number, Sequence)\n            and isinstance(next(iter(version_number)), int)\n        )\n    ):\n        raise TypeError(version_number)\n    if not isinstance(data, abc.Model):\n        raise TypeError(data)\n    if isinstance(data, abc.Object):\n        _version_object(data, specification, version_number)\n    elif isinstance(data, abc.Dictionary):\n        _version_dictionary(data, specification, version_number)\n    elif isinstance(data, abc.Array):\n        _version_array(data, specification, version_number)\n</code></pre>"},{"location":"api/sob.model/","title":"sob.model","text":""},{"location":"api/sob.model/#sob.model","title":"sob.model","text":"<p>This module defines the building blocks of an <code>sob</code> based data model.</p>"},{"location":"api/sob.model/#sob.model.Model","title":"Model","text":"<pre><code>Model()\n</code></pre> <p>               Bases: <code>sob.abc.Model</code></p> <p>This class serves as a base class for <code>sob.Object</code>, <code>sob.Dictionary</code>, and <code>sob.Array</code>. This class should not be instantiated or sub-classed directly.</p> Source code in <code>sob/model.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._instance_meta: abc.Meta | None = None\n    self._instance_hooks: abc.Hooks | None = None\n    self._url: str | None = None\n    self._pointer: str | None = None\n</code></pre>"},{"location":"api/sob.model/#sob.model.Array","title":"Array","text":"<pre><code>Array(\n    items: (\n        sob.abc.Array\n        | collections.abc.Iterable[\n            sob.abc.MarshallableTypes\n        ]\n        | str\n        | bytes\n        | sob.abc.Readable\n        | None\n    ) = None,\n    item_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | sob.abc.Types\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.model.Model</code>, <code>sob.abc.Array</code>, <code>sob.abc.Model</code></p> <p>This class may either be instantiated directly or serve as a base class for defining typed JSON arrays (python lists).</p> <p>Typing can be set at the instance level by providing the keyword argument <code>item_types</code> when initializing an instance of <code>sob.Array</code>, or by assigning item types to the class or instance metadata.</p> <p>Example:</p> <pre><code>from __future__ import annotations\nfrom io import StringIO\nfrom typing import IO, Iterable\nimport sob\nfrom datetime import datetime, date\n\nclass ObjectA(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"name\",\n        \"iso8601_datetime\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | None = None,\n        name: str | None = None,\n        iso8601_datetime: datetime | None = None,\n    ) -&gt; None:\n        self.name: str | None = name\n        self.iso8601_datetime: datetime | None = iso8601_datetime\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectA).properties = sob.Properties([\n    (\"name\", sob.StringProperty()),\n    (\n        \"iso8601_datetime\",\n        sob.DateTimeProperty(name=\"iso8601DateTime\")\n    ),\n])\n\nclass ObjectB(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"name\",\n        \"iso8601_date\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | None = None,\n        name: str | None = None,\n        iso8601_date: date | None = None,\n    ) -&gt; None:\n        self.name: str | None = name\n        self.iso8601_date: date | None = iso8601_date\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectB).properties = sob.Properties([\n    (\"name\", sob.StringProperty()),\n    (\"iso8601_date\", sob.DateProperty(name=\"iso8601Date\")),\n])\n\nclass ArrayA(sob.Array):\n    def __init__(\n        self,\n        items: (\n            Iterable[ObjectA|ObjectB|dict]\n            | IO\n            | str\n            | bytes\n            | None\n        ) = None,\n    ) -&gt; None:\n        super().__init__(items)\n\n\nsob.get_writable_array_meta(ArrayA).item_types = sob.Types([\n    ObjectA, ObjectB\n])\n\n\n# Instances can be initialized using attribute parameters\narray_a_instance_1: ArrayA = ArrayA(\n    [\n        ObjectA(\n            name=\"Object A\",\n            iso8601_datetime=datetime(1999, 12, 31, 23, 59, 59),\n        ),\n        ObjectB(\n            name=\"Object B\",\n            iso8601_date=date(1999, 12, 31),\n        ),\n    ]\n)\n\n# ...or by passing the JSON data, either as a string, bytes, sequence,\n# or file-like object, as the first positional argument when\n# initializing the class:\nassert array_a_instance_1 == ArrayA(\n    \"\"\"\n    [\n        {\n            \"name\": \"Object A\",\n            \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n        },\n        {\n            \"name\": \"Object B\",\n            \"iso8601Date\": \"1999-12-31\"\n        }\n    ]\n    \"\"\"\n) == ArrayA(\n    [\n        {\n            \"name\": \"Object A\",\n            \"iso8601DateTime\": datetime(1999, 12, 31, 23, 59, 59)\n        },\n        {\n            \"name\": \"Object B\",\n            \"iso8601Date\": date(1999, 12, 31)\n        }\n    ]\n) == ArrayA(\n    StringIO(\n        \"\"\"\n        [\n            {\n                \"name\": \"Object A\",\n                \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n            },\n            {\n                \"name\": \"Object B\",\n                \"iso8601Date\": \"1999-12-31\"\n            }\n        ]\n        \"\"\"\n    )\n)\n\n# An array instance can be serialized to JSON using the `sob.serialize`\n# function, or by simply casting it as a string\n\nassert sob.serialize(array_a_instance_1, indent=4) == \"\"\"\n[\n    {\n        \"name\": \"Object A\",\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n    },\n    {\n        \"name\": \"Object B\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n]\n\"\"\".strip()\n\nassert str(array_a_instance_1) == (\n    '[{\"name\": \"Object A\", \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"}'\n    ', {\"name\": \"Object B\", \"iso8601Date\": \"1999-12-31\"}]'\n)\n\n# An array can be converted into a list of JSON-serializable\n# python objects using `sob.marshal`\nassert sob.marshal(array_a_instance_1) == [\n    {\n        \"name\": \"Object A\",\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n    },\n    {\n        \"name\": \"Object B\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n]\n</code></pre> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>sob.abc.Array | collections.abc.Iterable[sob.abc.MarshallableTypes] | str | bytes | sob.abc.Readable | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>item_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | sob.abc.Types | type | sob.abc.Property | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> Source code in <code>sob/model.py</code> <pre><code>def __init__(\n    self,\n    items: (\n        abc.Array\n        | Iterable[abc.MarshallableTypes]\n        | str\n        | bytes\n        | abc.Readable\n        | None\n    ) = None,\n    item_types: (\n        Iterable[type | abc.Property]\n        | abc.Types\n        | type\n        | abc.Property\n        | None\n    ) = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        items:\n        item_types:\n    \"\"\"\n    Model.__init__(self)\n    self._instance_meta: abc.ArrayMeta | None = None\n    self._instance_hooks: abc.ArrayHooks | None = None\n    self._list: list[abc.MarshallableTypes] = []\n    self._init_url(items)\n    deserialized_items: (\n        Iterable[abc.MarshallableTypes] | abc.Model | None\n    ) = self._init_format(items)\n    if not isinstance(deserialized_items, (NoneType, Iterable)):\n        raise TypeError(deserialized_items)\n    self._init_item_types(deserialized_items, item_types)\n    self._init_items(deserialized_items)\n    self._init_pointer()\n</code></pre>"},{"location":"api/sob.model/#sob.model.Dictionary","title":"Dictionary","text":"<pre><code>Dictionary(\n    items: (\n        sob.abc.Dictionary\n        | collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n    value_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.model.Model</code>, <code>sob.abc.Dictionary</code>, <code>sob.abc.Model</code></p> <p>This class may either be instantiated directly or serve as a base class for defining JSON objects for which there is not a predetermined set of properties/attributes, but for which there may be a pre-determined set of permitted value types.</p> <p>Typing can be set at the instance level by providing the keyword argument <code>value_types</code> when initializing an instance of <code>sob.Dictionary</code>, or by assigning value types to the class or instance metadata.</p> <p>Example:</p> <pre><code>from __future__ import annotations\nimport sob\nfrom io import StringIO\nfrom typing import IO, Any, Iterable, Mapping\nfrom datetime import datetime, date\n\nclass ObjectA(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"name\",\n        \"iso8601_datetime\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | None = None,\n        name: str | None = None,\n        iso8601_datetime: datetime | None = None,\n    ) -&gt; None:\n        self.name: str | None = name\n        self.iso8601_datetime: datetime | None = iso8601_datetime\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectA).properties = sob.Properties([\n    (\"name\", sob.StringProperty()),\n    (\n        \"iso8601_datetime\",\n        sob.DateTimeProperty(name=\"iso8601DateTime\")\n    ),\n])\n\nclass ObjectB(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"name\",\n        \"iso8601_date\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | None = None,\n        name: str | None = None,\n        iso8601_date: date | None = None,\n    ) -&gt; None:\n        self.name: str | None = name\n        self.iso8601_date: date | None = iso8601_date\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectB).properties = sob.Properties([\n    (\"name\", sob.StringProperty()),\n    (\"iso8601_date\", sob.DateProperty(name=\"iso8601Date\")),\n])\n\nclass DictionaryA(sob.Dictionary):\n    def __init__(\n        self,\n        items: (\n            Mapping[str, Any]\n            | Iterable[tuple[str, ObjectA|ObjectB|dict]]\n            | IO\n            | str\n            | bytes\n            | None\n        ) = None,\n    ) -&gt; None:\n        super().__init__(items)\n\n\nsob.get_writable_dictionary_meta(DictionaryA).value_types = sob.Types([\n    ObjectA, ObjectB\n])\n\n\n# Instances can be initialized with a dictionary\ndictionary_a_instance_1: DictionaryA = DictionaryA(\n    {\n        \"a\": ObjectA(\n            name=\"Object A\",\n            iso8601_datetime=datetime(1999, 12, 31, 23, 59, 59),\n        ),\n        \"b\": ObjectB(\n            name=\"Object B\",\n            iso8601_date=date(1999, 12, 31),\n        ),\n    }\n)\n\n# ...or by passing the JSON data, either as a string, bytes, sequence,\n# or file-like object, as the first positional argument when\n# initializing the class:\nassert dictionary_a_instance_1 == DictionaryA(\n    \"\"\"\n    {\n        \"a\": {\n            \"name\": \"Object A\",\n            \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n        },\n        \"b\": {\n            \"name\": \"Object B\",\n            \"iso8601Date\": \"1999-12-31\"\n        }\n    }\n    \"\"\"\n) == DictionaryA(\n    StringIO(\n        \"\"\"\n        {\n            \"a\": {\n                \"name\": \"Object A\",\n                \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n            },\n            \"b\": {\n                \"name\": \"Object B\",\n                \"iso8601Date\": \"1999-12-31\"\n            }\n        }\n        \"\"\"\n    )\n) == DictionaryA(\n    (\n        (\n            \"a\",\n            ObjectA(\n                name=\"Object A\",\n                iso8601_datetime=datetime(1999, 12, 31, 23, 59, 59),\n            )\n        ),\n        (\n            \"b\",\n            ObjectB(\n                name=\"Object B\",\n                iso8601_date=date(1999, 12, 31),\n            )\n        ),\n    )\n)\n\n# A dictionary instance can be serialized to JSON using the\n# `sob.serialize` function, or by simply casting it as a string\nassert sob.serialize(dictionary_a_instance_1, indent=4) == \"\"\"\n{\n    \"a\": {\n        \"name\": \"Object A\",\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n    },\n    \"b\": {\n        \"name\": \"Object B\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n}\n\"\"\".strip()\n\nassert str(dictionary_a_instance_1) == (\n    '{\"a\": {\"name\": \"Object A\", \"iso8601DateTime\": '\n    '\"1999-12-31T23:59:59Z\"}, \"b\": {\"name\": \"Object B\", '\n    '\"iso8601Date\": \"1999-12-31\"}}'\n)\n\n# A dictionary can be converted into a JSON-serializable\n# objects using `sob.marshal`\nassert sob.marshal(dictionary_a_instance_1) == {\n    \"a\": {\n        \"name\": \"Object A\",\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\"\n    },\n    \"b\": {\n        \"name\": \"Object B\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n}\n</code></pre> Source code in <code>sob/model.py</code> <pre><code>def __init__(\n    self,\n    items: (\n        abc.Dictionary\n        | Mapping[str, abc.MarshallableTypes]\n        | Iterable[tuple[str, abc.MarshallableTypes]]\n        | abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n    value_types: (\n        Iterable[type | abc.Property]\n        | type\n        | abc.Property\n        | abc.Types\n        | None\n    ) = None,\n) -&gt; None:\n    Model.__init__(self)\n    self._instance_hooks: abc.DictionaryHooks | None = None\n    self._instance_meta: abc.DictionaryMeta | None = None\n    self._dict: dict[str, abc.MarshallableTypes] = {}\n    self._init_url(items)\n    deserialized_items: (\n        Iterable[abc.MarshallableTypes]\n        | Mapping[str, abc.MarshallableTypes]\n        | abc.Model\n        | None\n    ) = self._init_format(items)\n    self._init_value_types(deserialized_items, value_types)  # type: ignore\n    self._init_items(deserialized_items)  # type: ignore\n    self._init_pointer()\n</code></pre>"},{"location":"api/sob.model/#sob.model.Object","title":"Object","text":"<pre><code>Object(\n    _data: (\n        sob.abc.Object\n        | sob.abc.Dictionary\n        | collections.abc.Mapping[\n            str, sob.abc.MarshallableTypes\n        ]\n        | collections.abc.Iterable[\n            tuple[str, sob.abc.MarshallableTypes]\n        ]\n        | sob.abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.model.Model</code>, <code>sob.abc.Object</code>, <code>sob.abc.Model</code></p> <p>This class serves as a base for defining models for JSON objects (python dictionaries) which have a predetermined set of properties (attributes). This class should not be instantiated directly, but rather sub-classed to create object models.</p> <p>Example:</p> <pre><code>from __future__ import annotations\nfrom io import StringIO\nfrom typing import IO, Iterable\nimport sob\nfrom datetime import datetime, date\n\nclass ObjectA(sob.Object):\n    __slots__: tuple[str, ...] = (\n        \"boolean\",\n        \"boolean_or_string\",\n        \"integer\",\n        \"number\",\n        \"object_a\",\n        \"iso8601_datetime\",\n        \"iso8601_date\",\n    )\n\n    def __init__(\n        self,\n        _data: str | IO | dict | Iterable | None = None,\n        boolean: bool | None = None,\n        boolean_or_string: bool | str | None = None,\n        integer: int | None = None,\n        enumerated: int | None = None,\n        number: float | None = None,\n        object_a: ObjectA | None = None,\n        iso8601_datetime: datetime | None = None,\n        iso8601_date: date | None = None,\n    ) -&gt; None:\n        self.boolean: bool | None = boolean\n        self.boolean_or_string: bool | str | None = boolean_or_string\n        self.integer: int | None = integer\n        self.enumerated: int | None = enumerated\n        self.number: float | None = integer\n        self.object_a: ObjectA | None = None\n        self.iso8601_datetime: datetime | None = iso8601_datetime\n        self.iso8601_date: date | None = iso8601_date\n        super().__init__(_data)\n\n\nsob.get_writable_object_meta(ObjectA).properties = sob.Properties([\n    (\"boolean\", sob.BooleanProperty()),\n    (\n        \"boolean_or_string\",\n        sob.Property(\n            name=\"booleanOrString\",\n            types=sob.Types([bool, str])\n        )\n    ),\n    (\"integer\", sob.IntegerProperty()),\n    (\"enumerated\", sob.EnumeratedProperty(values=(1, 2, 3))),\n    (\"number\", sob.NumberProperty()),\n    (\n        \"iso8601_datetime\",\n        sob.DateTimeProperty(name=\"iso8601DateTime\")\n    ),\n    (\"iso8601_date\", sob.DateProperty(name=\"iso8601Date\")),\n])\n\n# Instances can be initialized using attribute parameters\nobject_a_instance_1: ObjectA = ObjectA(\n    boolean=True,\n    boolean_or_string=\"Maybe\",\n    integer=99,\n    enumerated=2,\n    number=3.14,\n    iso8601_datetime=datetime(1999, 12, 31, 23, 59, 59),\n    iso8601_date=date(1999, 12, 31),\n)\n\n# ...or by passing the JSON data, either as a string, bytes, dict, or\n# file-like object, as the first positional argument when initializing\n# the class:\nassert object_a_instance_1 == ObjectA(\n    \"\"\"\n    {\n        \"boolean\": true,\n        \"booleanOrString\": \"Maybe\",\n        \"integer\": 99,\n        \"enumerated\": 2,\n        \"number\": 99,\n        \"iso8601DateTime\": \"1999-12-31T23:59:59Z\",\n        \"iso8601Date\": \"1999-12-31\"\n    }\n    \"\"\"\n) == ObjectA(\n    {\n        \"boolean\": True,\n        \"booleanOrString\": \"Maybe\",\n        \"integer\": 99,\n        \"enumerated\": 2,\n        \"number\": 99,\n        \"iso8601DateTime\": datetime(1999, 12, 31, 23, 59, 59),\n        \"iso8601Date\": date(1999, 12, 31)\n    }\n) == ObjectA(\n    (\n        (\"boolean\", True),\n        (\"booleanOrString\", \"Maybe\"),\n        (\"integer\", 99),\n        (\"enumerated\", 2),\n        (\"number\", 99),\n        (\"iso8601DateTime\", datetime(1999, 12, 31, 23, 59, 59)),\n        (\"iso8601Date\", date(1999, 12, 31))\n    )\n) == ObjectA(\n    StringIO(\n        \"\"\"\n        {\n            \"boolean\": true,\n            \"booleanOrString\": \"Maybe\",\n            \"integer\": 99,\n            \"enumerated\": 2,\n            \"number\": 99,\n            \"iso8601DateTime\": \"1999-12-31T23:59:59Z\",\n            \"iso8601Date\": \"1999-12-31\"\n        }\n        \"\"\"\n    )\n)\n\n# An object instance can be serialized to JSON using the\n# `sob.serialize` function, or by simply casting it as a string\n\nassert sob.serialize(object_a_instance_1, indent=4) == \"\"\"\n{\n    \"boolean\": true,\n    \"booleanOrString\": \"Maybe\",\n    \"integer\": 99,\n    \"enumerated\": 2,\n    \"number\": 99,\n    \"iso8601DateTime\": \"1999-12-31T23:59:59Z\",\n    \"iso8601Date\": \"1999-12-31\"\n}\n\"\"\".strip()\n\nassert str(object_a_instance_1) == (\n    '{\"boolean\": true, \"booleanOrString\": \"Maybe\", \"integer\": 99, '\n    '\"enumerated\": 2, \"number\": 99, '\n    '\"iso8601DateTime\": \"1999-12-31T23:59:59Z\", '\n    '\"iso8601Date\": \"1999-12-31\"}'\n)\n\n# An object can be converted into a dictionary of JSON-serializable\n# python objects using `sob.marshal`\nassert sob.marshal(object_a_instance_1) == {\n    \"boolean\": True,\n    \"booleanOrString\": \"Maybe\",\n    \"integer\": 99,\n    \"enumerated\": 2,\n    \"number\": 99,\n    \"iso8601DateTime\": \"1999-12-31T23:59:59Z\",\n    \"iso8601Date\": \"1999-12-31\"\n}\n</code></pre> <p>Parameters:</p> <ul> <li> <code>_data</code>               (<code>sob.abc.Object | sob.abc.Dictionary | collections.abc.Mapping[str, sob.abc.MarshallableTypes] | collections.abc.Iterable[tuple[str, sob.abc.MarshallableTypes]] | sob.abc.Readable | str | bytes | None</code>, default:                   <code>None</code> )           \u2013            <p>JSON data with which to initialize this object. This may be a dictionary/mapping, a JSON string or bytes, a file-like object containing JSON data, or an iterable of key/value tuples.</p> </li> </ul> Source code in <code>sob/model.py</code> <pre><code>def __init__(\n    self,\n    _data: (\n        abc.Object\n        | abc.Dictionary\n        | Mapping[str, abc.MarshallableTypes]\n        | Iterable[tuple[str, abc.MarshallableTypes]]\n        | abc.Readable\n        | str\n        | bytes\n        | None\n    ) = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        _data: JSON data with which to initialize this object. This may\n            be a dictionary/mapping, a JSON string or bytes, a\n            file-like object containing JSON data, or an iterable of\n            key/value tuples.\n    \"\"\"\n    self._instance_meta: abc.ObjectMeta | None = None\n    self._instance_hooks: abc.ObjectHooks | None = None\n    self._extra: dict[str, abc.MarshallableTypes] | None = None\n    Model.__init__(self)\n    self._init_url(_data)\n    deserialized_data: (\n        Iterable[abc.MarshallableTypes]\n        | Mapping[str, abc.MarshallableTypes]\n        | abc.Model\n        | None\n    ) = self._init_format(_data)\n    if not (\n        isinstance(\n            deserialized_data, (abc.Object, abc.Dictionary, dict, Mapping)\n        )\n        or (deserialized_data is None)\n    ):\n        raise TypeError(deserialized_data)\n    self._data_init(deserialized_data)\n    self._init_pointer()\n</code></pre>"},{"location":"api/sob.model/#sob.model.marshal","title":"marshal","text":"<pre><code>marshal(\n    data: sob.abc.MarshallableTypes,\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | sob.abc.Types\n        | None\n    ) = None,\n    value_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | sob.abc.Types\n        | None\n    ) = None,\n    item_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | sob.abc.Types\n        | None\n    ) = None,\n) -&gt; typing.Any\n</code></pre> <p>This function recursively converts data which is not serializable using <code>json.dumps</code> into data which can be represented as JSON.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>sob.abc.MarshallableTypes</code>)           \u2013            <p>The data to be marshalled, typically an instance of <code>sob.Model</code>.</p> </li> <li> <code>types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | sob.abc.Types | None</code>, default:                   <code>None</code> )           \u2013            <p>Property definitions or type(s) associated with this data. This is typically only used for recursive calls, so not typically provided explicitly by client applications.</p> </li> <li> <code>value_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | sob.abc.Types | None</code>, default:                   <code>None</code> )           \u2013            <p>Property definitions or type(s) associated with this objects' dictionary values. This is typically only used for recursive calls, so not typically provided explicitly by client applications.</p> </li> <li> <code>item_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | sob.abc.Types | None</code>, default:                   <code>None</code> )           \u2013            <p>Property definitions or type(s) associated with this array's items. This is typically only used for recursive calls, so not typically provided explicitly by client applications.</p> </li> </ul> Source code in <code>sob/model.py</code> <pre><code>def marshal(  # noqa: C901\n    data: abc.MarshallableTypes,\n    types: Iterable[type | abc.Property] | abc.Types | None = None,\n    value_types: Iterable[type | abc.Property] | abc.Types | None = None,\n    item_types: Iterable[type | abc.Property] | abc.Types | None = None,\n) -&gt; Any:\n    \"\"\"\n    This function recursively converts data which is not serializable using\n    `json.dumps` into data which *can* be represented as JSON.\n\n    Parameters:\n        data: The data to be marshalled, typically an instance of `sob.Model`.\n        types: Property definitions or type(s) associated with this data.\n            This is typically only used for recursive calls, so not typically\n            provided explicitly by client applications.\n        value_types: Property definitions or type(s) associated with this\n            objects' dictionary values. This is typically only used for\n            recursive calls, so not typically provided explicitly by client\n            applications.\n        item_types: Property definitions or type(s) associated with this\n            array's items. This is typically only used for recursive calls,\n            so not typically provided explicitly by client applications.\n    \"\"\"\n    marshalled_data: abc.JSONTypes\n    if isinstance(data, Decimal):\n        # Instances of `decimal.Decimal` can'ts be serialized as JSON, so we\n        # convert them to `float`\n        marshalled_data = float(data)\n    elif (data is None) or isinstance(data, (str, int, float)):\n        # Don't do anything with `None`--this just means an attributes is not\n        # used for this instance (an explicit `null` would be passed as\n        # `sob.properties.types.NULL`).\n        marshalled_data = data\n    elif data is NULL:\n        marshalled_data = None\n    elif isinstance(data, abc.Model):\n        marshalled_data = data._marshal()  # noqa: SLF001\n    elif types is not None:\n        marshalled_data = _marshal_typed(data, types)\n    elif isinstance(data, datetime):\n        marshalled_data = datetime2str(data)\n    elif isinstance(data, date):\n        marshalled_data = date2str(data)\n    elif isinstance(data, (bytes, bytearray)):\n        # Convert `bytes` to base-64 encoded strings\n        marshalled_data = str(b64encode(data), \"ascii\")\n    elif isinstance(data, Collection):\n        marshalled_data = _marshal_collection(\n            data, value_types=value_types, item_types=item_types\n        )\n    elif isinstance(data, SupportsBytes):\n        # Convert objects which can be *cast* as `bytes` to\n        # base-64 encoded strings\n        marshalled_data = str(b64encode(bytes(data)), \"ascii\")\n    else:\n        message: str = f\"Cannot unmarshal: {data!r}\"\n        raise ValueError(message)\n    return marshalled_data\n</code></pre>"},{"location":"api/sob.model/#sob.model.unmarshal","title":"unmarshal","text":"<pre><code>unmarshal(\n    data: sob.abc.MarshallableTypes,\n    types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n    ) = (),\n    value_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n    ) = (),\n    item_types: (\n        collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | sob.abc.Types\n    ) = (),\n) -&gt; typing.Any\n</code></pre> <p>Converts deserialized data into one of the provided types.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>sob.abc.MarshallableTypes</code>)           \u2013            </li> <li> <code>types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | type | sob.abc.Property | sob.abc.Types</code>, default:                   <code>()</code> )           \u2013            <p>Property definitions or type(s) into which to attempt to un-marshal the data. If multiple types are provided, the first which does not raise an error or contain extraneous attributes is accepted. If the data has extraneous attributes for all types, the type with the fewest extraneous attributes is accepted.</p> </li> <li> <code>value_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | type | sob.abc.Property | sob.abc.Types</code>, default:                   <code>()</code> )           \u2013            <p>For dictionary-like objects, values will be un-marshalled as one of the provided property definitions or types.</p> </li> <li> <code>item_types</code>               (<code>collections.abc.Iterable[type | sob.abc.Property] | type | sob.abc.Property | sob.abc.Types</code>, default:                   <code>()</code> )           \u2013            <p>For sequences (lists/tuples), items will be un-marshalled as one of the provided property definitions or types.</p> </li> </ul> Source code in <code>sob/model.py</code> <pre><code>def unmarshal(\n    data: abc.MarshallableTypes,\n    types: (\n        Iterable[type | abc.Property] | type | abc.Property | abc.Types\n    ) = (),\n    value_types: (\n        Iterable[type | abc.Property] | type | abc.Property | abc.Types\n    ) = (),\n    item_types: (\n        Iterable[type | abc.Property] | type | abc.Property | abc.Types\n    ) = (),\n) -&gt; Any:\n    \"\"\"\n    Converts deserialized data into one of the provided types.\n\n    Parameters:\n        data:\n        types: Property definitions or type(s) into which to attempt to\n            un-marshal the data. If multiple types are provided,\n            the first which does not raise an error or contain extraneous\n            attributes is accepted. If the data has extraneous attributes\n            for all types, the type with the fewest extraneous attributes is\n            accepted.\n        value_types: For dictionary-like objects, values will be un-marshalled\n            as one of the provided property definitions or types.\n        item_types: For sequences (lists/tuples), items will be un-marshalled\n            as one of the provided property definitions or types.\n    \"\"\"\n    return _Unmarshal(\n        data, types=types, value_types=value_types, item_types=item_types\n    )()\n</code></pre>"},{"location":"api/sob.model/#sob.model.serialize","title":"serialize","text":"<pre><code>serialize(\n    data: sob.abc.MarshallableTypes,\n    indent: int | None = None,\n) -&gt; str\n</code></pre> <p>This function serializes data, particularly instances of <code>sob.Model</code> sub-classes, into JSON encoded strings.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>sob.abc.MarshallableTypes</code>)           \u2013            </li> <li> <code>indent</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of spaces to use for indentation. If <code>None</code>, the JSON will be compacted (no line breaks or indentation).</p> </li> </ul> Source code in <code>sob/model.py</code> <pre><code>def serialize(\n    data: abc.MarshallableTypes,\n    indent: int | None = None,\n) -&gt; str:\n    \"\"\"\n    This function serializes data, particularly instances of `sob.Model`\n    sub-classes, into JSON encoded strings.\n\n    Parameters:\n        data:\n        indent: The number of spaces to use for indentation. If `None`,\n            the JSON will be compacted (no line breaks or indentation).\n    \"\"\"\n    string_data: str\n    if isinstance(data, abc.Model):\n        before_serialize: Callable[[abc.JSONTypes], abc.JSONTypes] | None\n        after_serialize: Callable[[str], str] | None\n        before_serialize, after_serialize = _get_serialize_instance_hooks(data)\n        marshalled_data: abc.JSONTypes = marshal(data)\n        if before_serialize is not None:\n            marshalled_data = before_serialize(marshalled_data)\n        string_data = json.dumps(marshalled_data, indent=indent)\n        if after_serialize is not None:\n            string_data = after_serialize(string_data)\n    else:\n        if not isinstance(data, abc.JSON_TYPES):\n            raise TypeError(data)\n        string_data = json.dumps(data, indent=indent)\n    return string_data\n</code></pre>"},{"location":"api/sob.model/#sob.model.deserialize","title":"deserialize","text":"<pre><code>deserialize(\n    data: str | bytes | sob.abc.Readable | None,\n    coerce_unparseable: type[str | bytes] | None = None,\n) -&gt; typing.Any\n</code></pre> <p>This function deserializes JSON encoded data from a string, bytes, or a file-like object.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>str | bytes | sob.abc.Readable | None</code>)           \u2013            <p>This can be a string or file-like object containing JSON serialized data.</p> </li> <li> <code>coerce_unparseable</code>               (<code>type[str | bytes] | None</code>, default:                   <code>None</code> )           \u2013            <p>If <code>str</code> or <code>bytes</code> are provided, and the data provided cannot be parsed as JSON, it will be returned as the specified type. If <code>None</code> (the default), an error will be raised if the data cannot be parsed as JSON.</p> </li> </ul> <p>This function returns <code>None</code> (for JSON null values), or an instance of <code>str</code>, <code>dict</code>, <code>list</code>, <code>int</code>, <code>float</code> or <code>bool</code>.</p> Source code in <code>sob/model.py</code> <pre><code>def deserialize(\n    data: str | bytes | abc.Readable | None,\n    coerce_unparseable: type[str | bytes] | None = None,\n) -&gt; Any:\n    \"\"\"\n    This function deserializes JSON encoded data from a string, bytes,\n    or a file-like object.\n\n    Parameters:\n        data: This can be a string or file-like object\n            containing JSON serialized data.\n        coerce_unparseable: If `str` or `bytes` are provided, and\n            the data provided cannot be parsed as JSON, it will be returned\n            as the specified type. If `None` (the default), an error\n            will be raised if the data cannot be parsed as JSON.\n\n    This function returns `None` (for JSON null values), or an instance of\n    `str`, `dict`, `list`, `int`, `float` or `bool`.\n    \"\"\"\n    deserialized_data: abc.JSONTypes\n    if isinstance(data, str):\n        try:\n            deserialized_data = json.loads(\n                data,\n                strict=False,\n            )\n        except ValueError as error:\n            if coerce_unparseable:\n                return data\n            raise DeserializeError(\n                data=data,\n                message=get_exception_text(),\n            ) from error\n    elif isinstance(data, bytes):\n        str_data: str = str(data, encoding=\"utf-8\")\n        try:\n            deserialized_data = deserialize(str_data)\n        except DeserializeError as error:\n            if coerce_unparseable:\n                if issubclass(coerce_unparseable, bytes):\n                    return data\n                return str_data\n            raise DeserializeError(\n                data=data,\n                message=get_exception_text(),\n            ) from error\n    else:\n        if not isinstance(data, abc.Readable):\n            raise TypeError(data)\n        deserialized_data = deserialize(\n            read(data), coerce_unparseable=coerce_unparseable\n        )\n    return deserialized_data\n</code></pre>"},{"location":"api/sob.model/#sob.model.validate","title":"validate","text":"<pre><code>validate(\n    data: typing.Any,\n    types: (\n        sob.abc.Types\n        | collections.abc.Iterable[type | sob.abc.Property]\n        | None\n    ) = None,\n    *,\n    raise_errors: bool = True\n) -&gt; collections.abc.Sequence[str]\n</code></pre> <p>This function verifies that all properties/items/values of a model instance are of the correct data type(s), and that all required attributes are present (if applicable).</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>typing.Any</code>)           \u2013            </li> <li> <code>types</code>               (<code>sob.abc.Types | collections.abc.Iterable[type | sob.abc.Property] | None</code>, default:                   <code>None</code> )           \u2013            <p>Property definitions or types against which to attempt to validate the data.</p> </li> <li> <code>raise_errors</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If <code>True</code>, a validation error will be raised if the validation fails. If <code>False</code>, a list of error message strings will be returned.</p> </li> </ul> <p>If <code>raise_errors</code> is <code>True</code> (this is the default), violations will result in a validation error being raised. If <code>raise_errors</code> is <code>False</code>, a list of error messages will be returned.</p> Source code in <code>sob/model.py</code> <pre><code>def validate(\n    data: Any,\n    types: abc.Types | Iterable[type | abc.Property] | None = None,\n    *,\n    raise_errors: bool = True,\n) -&gt; Sequence[str]:\n    \"\"\"\n    This function verifies that all properties/items/values of a model instance\n    are of the correct data type(s), and that all required attributes are\n    present (if applicable).\n\n    Parameters:\n        data:\n        types: Property definitions or types against which to attempt to\n            validate the data.\n        raise_errors: If `True`, a validation error will be raised if\n            the validation fails. If `False`, a list of error message strings\n            will be returned.\n\n    If `raise_errors` is `True` (this is the default), violations will result\n    in a validation error being raised. If `raise_errors` is `False`, a list\n    of error messages will be returned.\n    \"\"\"\n    if isinstance(data, GeneratorType):\n        data = tuple(data)\n    error_messages: list[str] = []\n    if types is not None:\n        error_messages.extend(_validate_typed(data, types))\n    error_messages.extend(_call_validate_method(data))\n    if raise_errors and error_messages:\n        data_representation: str = f\"\\n\\n    {indent_(represent(data))}\"\n        error_messages_representation: str = \"\\n\\n\".join(error_messages)\n        if data_representation not in error_messages_representation:\n            error_messages_representation = (\n                f\"{data_representation}\\n\\n{error_messages_representation}\"\n            )\n        raise errors.ValidationError(error_messages_representation)\n    return error_messages\n</code></pre>"},{"location":"api/sob.model/#sob.model.replace_model_nulls","title":"replace_model_nulls","text":"<pre><code>replace_model_nulls(\n    model_instance: sob.abc.Model,\n    replacement_value: sob.abc.MarshallableTypes = None,\n) -&gt; None\n</code></pre> <p>This function replaces all instances of <code>sob.properties.types.NULL</code>.</p> <p>Parameters:</p> <ul> <li>model_instance (sob.model.Model)</li> <li>replacement_value (typing.Any):   The value with which nulls will be replaced. This defaults to <code>None</code>.</li> </ul> Source code in <code>sob/model.py</code> <pre><code>def replace_model_nulls(\n    model_instance: abc.Model,\n    replacement_value: abc.MarshallableTypes = None,\n) -&gt; None:\n    \"\"\"\n    This function replaces all instances of `sob.properties.types.NULL`.\n\n    Parameters:\n\n    - model_instance (sob.model.Model)\n    - replacement_value (typing.Any):\n      The value with which nulls will be replaced. This defaults to `None`.\n    \"\"\"\n    if isinstance(model_instance, abc.Object):\n        _replace_object_nulls(model_instance, replacement_value)\n    elif isinstance(model_instance, abc.Array):\n        _replace_array_nulls(model_instance, replacement_value)\n    elif isinstance(model_instance, abc.Dictionary):\n        _replace_dictionary_nulls(model_instance, replacement_value)\n</code></pre>"},{"location":"api/sob.model/#sob.model.get_model_from_meta","title":"get_model_from_meta","text":"<pre><code>get_model_from_meta(\n    name: str,\n    metadata: sob.abc.Meta,\n    module: str | None = None,\n    docstring: str | None = None,\n    pre_init_source: str = \"\",\n    post_init_source: str = \"\",\n) -&gt; type[sob.abc.Model]\n</code></pre> <p>Constructs an <code>sob.Object</code>, <code>sob.Array</code>, or <code>sob.Dictionary</code> sub-class from an instance of <code>sob.ObjectMeta</code>, <code>sob.ArrayMeta</code>, or <code>sob.DictionaryMeta</code>.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the class.</p> </li> <li> <code>class_meta</code>           \u2013            </li> <li> <code>module</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify the value for the class definition's <code>__module__</code> property. The invoking module will be used if this is not specified. Note: If using the result of this function with <code>sob.utilities.get_source</code> to generate static code--this should be set to \"main\". The default behavior is only appropriate when using this function as a factory.</p> </li> <li> <code>docstring</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A docstring to associate with the class definition.</p> </li> <li> <code>pre_init_source</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source code to insert before the <code>__init__</code> function in the class definition.</p> </li> <li> <code>post_init_source</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Source code to insert after the <code>__init__</code> function in the class definition.</p> </li> </ul> Source code in <code>sob/model.py</code> <pre><code>def get_model_from_meta(\n    name: str,\n    metadata: abc.Meta,\n    module: str | None = None,\n    docstring: str | None = None,\n    pre_init_source: str = \"\",\n    post_init_source: str = \"\",\n) -&gt; type[abc.Model]:\n    \"\"\"\n    Constructs an `sob.Object`, `sob.Array`, or `sob.Dictionary` sub-class\n    from an instance of `sob.ObjectMeta`, `sob.ArrayMeta`, or\n    `sob.DictionaryMeta`.\n\n    Parameters:\n        name: The name of the class.\n        class_meta:\n        module: Specify the value for the class definition's\n            `__module__` property. The invoking module will be\n            used if this is not specified. Note: If using the result of this\n            function with `sob.utilities.get_source` to generate static\n            code--this should be set to \"__main__\". The default behavior is\n            only appropriate when using this function as a factory.\n        docstring: A docstring to associate with the class definition.\n        pre_init_source: Source code to insert *before* the `__init__`\n            function in the class definition.\n        post_init_source: Source code to insert *after* the `__init__`\n            function in the class definition.\n    \"\"\"\n    # For pickling to work, the __module__ variable needs to be set...\n    module = module or get_calling_module_name(2)\n    class_definition: str = _class_definition_from_meta(\n        name,\n        metadata,\n        docstring=docstring,\n        module=module,\n        pre_init_source=pre_init_source,\n        post_init_source=post_init_source,\n    )\n    namespace: dict[str, Any] = {\"__name__\": f\"from_meta_{name}\"}\n    imports = [\n        \"from __future__ import annotations\",\n        \"import typing\",\n    ]\n    # `decimal.Decimal` may or may not be referenced in a given model--so\n    # check first\n    if re.search(r\"\\bdecimal\\.Decimal\\b\", class_definition):\n        imports.append(\"import decimal\")\n    # `datetime` may or may not be referenced in a given model--so check\n    # first\n    if re.search(r\"\\bdatetime\\b\", class_definition):\n        imports.append(\"import datetime\")\n    imports.append(\"import sob\")\n    source: str = suffix_long_lines(\n        \"{}\\n\\n\\n{}\".format(\"\\n\".join(imports), class_definition)\n    )\n    error: Exception\n    try:\n        exec(source, namespace)  # noqa: S102\n    except Exception as error:\n        append_exception_text(error, f\"\\n\\n{source}\")\n        raise\n    model_class: type[abc.Model] = namespace[name]\n    model_class._source = source  # noqa: SLF001\n    model_class.__module__ = module\n    model_class._class_meta = metadata  # noqa: SLF001\n    return model_class\n</code></pre>"},{"location":"api/sob.model/#sob.model.get_models_source","title":"get_models_source","text":"<pre><code>get_models_source(\n    *model_classes: type[sob.abc.Model],\n) -&gt; str\n</code></pre> <p>Get source code for a series of model classes, organized as a module. This is useful for generating a module from classes generated using <code>get_model_from_meta</code>.</p> Source code in <code>sob/model.py</code> <pre><code>def get_models_source(*model_classes: type[abc.Model]) -&gt; str:\n    \"\"\"\n    Get source code for a series of model classes, organized as a module.\n    This is useful for generating a module from classes generated\n    using `get_model_from_meta`.\n    \"\"\"\n    import_source_lines: list[str] = []\n    class_sources: list[str] = []\n    model_class: type[abc.Model]\n    class_names_metadata: dict[\n        str, abc.ObjectMeta | abc.ArrayMeta | abc.DictionaryMeta\n    ] = {}\n    for model_class in model_classes:\n        import_source: str\n        class_source: str\n        import_source, class_source = (\n            get_source(model_class).strip().rpartition(\"\\n\\n\\n\")[::2]\n        )\n        import_source_lines.extend(import_source.splitlines())\n        class_sources.append(class_source)\n        meta_instance: abc.Meta | None = meta.read_model_meta(model_class)\n        if not isinstance(\n            meta_instance,\n            (abc.ObjectMeta, abc.ArrayMeta, abc.DictionaryMeta),\n        ):\n            raise TypeError(meta_instance)\n        class_names_metadata[model_class.__name__] = meta_instance\n    class_name: str\n    metadata: abc.ObjectMeta | abc.ArrayMeta | abc.DictionaryMeta\n    metadata_sources: list[str] = []\n    for class_name, metadata in class_names_metadata.items():\n        if not isinstance(\n            metadata, (abc.ObjectMeta, abc.ArrayMeta, abc.DictionaryMeta)\n        ):\n            raise TypeError(metadata)\n        if isinstance(metadata, abc.ObjectMeta):\n            metadata_sources.append(\n                _get_class_meta_attribute_assignment_source(\n                    class_name, \"properties\", metadata\n                )\n            )\n        elif isinstance(metadata, abc.ArrayMeta):\n            metadata_sources.append(\n                _get_class_meta_attribute_assignment_source(\n                    class_name, \"item_types\", metadata\n                )\n            )\n        else:\n            metadata_sources.append(\n                _get_class_meta_attribute_assignment_source(\n                    class_name, \"value_types\", metadata\n                )\n            )\n    # De-duplicate imports while preserving order\n    imports_source = \"\\n\".join(dict.fromkeys(import_source_lines).keys())\n    classes_source: str = \"\\n\\n\\n\".join(class_sources)\n    metadata_source: str = \"\\n\".join(metadata_sources)\n    return f\"{imports_source}\\n\\n\\n{classes_source}\\n\\n\\n{metadata_source}\"\n</code></pre>"},{"location":"api/sob.properties/","title":"sob.properties","text":""},{"location":"api/sob.properties/#sob.properties","title":"sob.properties","text":"<p>This module defines classes for describing properties of a model.</p>"},{"location":"api/sob.properties/#sob.properties.Property","title":"Property","text":"<pre><code>Property(\n    types: (\n        sob.abc.Types\n        | collections.abc.Sequence[\n            type | sob.properties.Property\n        ]\n        | type\n        | sob.properties.Property\n        | sob._types.Undefined\n        | None\n    ) = sob._types.UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.abc.Property</code></p> <p>This is the base class for defining a property.</p> <p>Attributes:</p> <ul> <li> <code>types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>One or more types or property definitions. More than one types and/or property definitions results in a polymorphic interpretation wherein a value is un-marshalled in accordance with each type or property in the list (sequentially), until the value is un-marshalled without throwing a <code>TypeError</code> or <code>ValueError</code>. If the list of types and/or properties is exhausted without successfully un-marshalling the value, a <code>TypeError</code> or <code>ValueError</code> error is raised. When types are sub-classes of <code>sob.Object</code>, each type is attempted, and of the resulting instances, the type resulting in the fewest extraneous attributes (attributes not corresponding to any metadata) is used.)</p> </li> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    types: abc.Types\n    | Sequence[type | Property]\n    | type\n    | Property\n    | Undefined\n    | None = UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    self._types: abc.Types | None = type(self)._types  # noqa: SLF001\n    if types is not UNDEFINED:\n        self.types = types  # type: ignore\n    self.name: str | None = name\n    self.required: bool = required\n    self._versions: Sequence[abc.Version] | None = None\n    if versions is not None:\n        self.versions = versions  # type: ignore\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.StringProperty","title":"StringProperty","text":"<pre><code>StringProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.StringProperty</code></p> <p>This class represents metadata describing a string property.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.DateProperty","title":"DateProperty","text":"<pre><code>DateProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None,\n    date2str: collections.abc.Callable[\n        [datetime.date], str\n    ] = sob.properties.DateProperty._date2str,\n    str2date: collections.abc.Callable[\n        [str], datetime.date\n    ] = sob.properties.DateProperty._str2date\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.DateProperty</code></p> <p>This class represents metadata describing a date property.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>required</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>versions</code>               (<code>str | sob.abc.Version | collections.abc.Iterable[str | sob.abc.Version] | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>date2str</code>               (<code>collections.abc.Callable[[datetime.date], str]</code>, default:                   <code>sob.properties.DateProperty._date2str</code> )           \u2013            <p>A function, taking one argument (a python <code>date</code> json_object), and returning a date string in the desired format. The default is <code>datetime.date.isoformat</code> \u2014returning an ISO-8601 compliant date string.</p> </li> <li> <code>str2date</code>               (<code>collections.abc.Callable[[str], datetime.date]</code>, default:                   <code>sob.properties.DateProperty._str2date</code> )           \u2013            <p>A function, taking one argument (a date string), and returning a python <code>date</code> object. By default, this is <code>iso8601.iso8601.parse_date</code>.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n    date2str: Callable[[date], str] = _date2str,\n    str2date: Callable[[str], date] = _str2date,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        name:\n        required:\n        versions:\n        date2str: A function, taking one argument (a python `date`\n            json_object), and returning a date string in the\n            desired format. The default is `datetime.date.isoformat`\n            \u2014returning an ISO-8601 compliant date string.\n\n        str2date: A function, taking one argument (a date string), and\n            returning a python `date` object. By default, this is\n            `iso8601.iso8601.parse_date`.\n    \"\"\"\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n    self._date2str = date2str\n    self._str2date = str2date\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.DateTimeProperty","title":"DateTimeProperty","text":"<pre><code>DateTimeProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None,\n    datetime2str: collections.abc.Callable[\n        [datetime.datetime], str\n    ] = sob.properties.DateTimeProperty._datetime2str,\n    str2datetime: collections.abc.Callable[\n        [str], datetime.datetime\n    ] = sob.properties.DateTimeProperty._str2datetime\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.DateTimeProperty</code></p> <p>This class represents metadata describing a date property.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>required</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            </li> <li> <code>versions</code>               (<code>str | sob.abc.Version | collections.abc.Iterable[str | sob.abc.Version] | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>datetime2str</code>               (<code>collections.abc.Callable[[datetime.datetime], str]</code>, default:                   <code>sob.properties.DateTimeProperty._datetime2str</code> )           \u2013            <p>A function, taking one argument (a python <code>datetime</code> json_object), and returning a date/time string in the desired format. The default is <code>datetime.datetime.isoformat</code>, returning an ISO-8601 compliant date/time string.</p> </li> <li> <code>str2datetime</code>               (<code>collections.abc.Callable[[str], datetime.datetime]</code>, default:                   <code>sob.properties.DateTimeProperty._str2datetime</code> )           \u2013            <p>A function, taking one argument (a datetime string), and returning a python <code>datetime.datetime</code> object. By default, this is <code>iso8601.iso8601.parse_date</code>.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n    datetime2str: Callable[[datetime], str] = _datetime2str,\n    str2datetime: Callable[[str], datetime] = _str2datetime,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        name:\n        required:\n        versions:\n        datetime2str: A function, taking one argument (a python `datetime`\n            json_object), and returning a date/time string in the desired\n            format. The default is `datetime.datetime.isoformat`,\n            returning an ISO-8601 compliant date/time string.\n        str2datetime: A function, taking one argument (a datetime string),\n            and returning a python `datetime.datetime` object. By default,\n            this is `iso8601.iso8601.parse_date`.\n    \"\"\"\n    self._datetime2str = datetime2str\n    self._str2datetime = str2datetime\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.BytesProperty","title":"BytesProperty","text":"<pre><code>BytesProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.BytesProperty</code></p> <p>This class represents metadata describing a property with binary values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.EnumeratedProperty","title":"EnumeratedProperty","text":"<pre><code>EnumeratedProperty(\n    types: (\n        sob.abc.Types\n        | collections.abc.Sequence[\n            type | sob.properties.Property\n        ]\n        | type\n        | sob.properties.Property\n        | sob._types.Undefined\n        | None\n    ) = sob._types.UNDEFINED,\n    values: (\n        collections.abc.Iterable[sob.abc.MarshallableTypes]\n        | None\n    ) = None,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.EnumeratedProperty</code></p> <p>This class represents metadata describing a property having a finite, pre-determined, set of possible values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> <li> <code>values</code>               (<code>set[sob.abc.MarshallableTypes] | None</code>)           \u2013            <p>All possible values for this property.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    types: abc.Types\n    | Sequence[type | Property]\n    | type\n    | Property\n    | Undefined\n    | None = UNDEFINED,\n    values: Iterable[MarshallableTypes] | None = None,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    self._values: set[MarshallableTypes] | None = None\n    super().__init__(\n        types=types, name=name, required=required, versions=versions\n    )\n    self.values = values  # type: ignore\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.NumberProperty","title":"NumberProperty","text":"<pre><code>NumberProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.NumberProperty</code></p> <p>This class represents metadata describing a property having numeric (decimal, float or integer) values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(name=name, required=required, versions=versions)\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.IntegerProperty","title":"IntegerProperty","text":"<pre><code>IntegerProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.IntegerProperty</code></p> <p>This class represents metadata describing a property having integer values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.BooleanProperty","title":"BooleanProperty","text":"<pre><code>BooleanProperty(\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.BooleanProperty</code></p> <p>This class represents metadata describing a property having boolean values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.ArrayProperty","title":"ArrayProperty","text":"<pre><code>ArrayProperty(\n    item_types: (\n        type\n        | collections.abc.Sequence[\n            type | sob.properties.Property\n        ]\n        | sob._types.Undefined\n        | sob.abc.Types\n        | None\n    ) = sob._types.UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.ArrayProperty</code></p> <p>This class represents metadata describing a property accepting array (list/tuple) values.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> <li> <code>item_types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>The type(s) of values/objects contained in the array. Similar to <code>sob.Property().types</code>, but applied to items in the array, not the array itself.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    item_types: type\n    | Sequence[type | Property]\n    | Undefined\n    | abc.Types\n    | None = UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    self._item_types: Types | None = type(self)._item_types  # noqa: SLF001\n    if item_types is not UNDEFINED:\n        self.item_types = item_types  # type: ignore\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.DictionaryProperty","title":"DictionaryProperty","text":"<pre><code>DictionaryProperty(\n    value_types: (\n        type\n        | collections.abc.Sequence[\n            type | sob.properties.Property\n        ]\n        | sob._types.Undefined\n        | sob.abc.Types\n        | None\n    ) = sob._types.UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: (\n        str\n        | sob.abc.Version\n        | collections.abc.Iterable[str | sob.abc.Version]\n        | None\n    ) = None\n)\n</code></pre> <p>               Bases: <code>sob.properties.Property</code>, <code>sob.abc.DictionaryProperty</code></p> <p>This class represents metadata describing a property accepting dictionary values (deserialized JSON objects without a pre-determined set of properties).</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str | None</code>)           \u2013            <p>The name of the property when loaded from or dumped into a JSON object. Specifying a <code>name</code> facilitates mapping of PEP8 compliant property names to JSON attribute names which might be incompatible with well-formatted python code due to various reasons such as being camelCased, or being python keywords. To infer an appropriate property name programmatically, use the utility function <code>sob.utilities.get_property_name</code>.</p> </li> <li> <code>required</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, sob.validate<code>will raise a validation error if this property is missing (is</code>None`).</p> </li> <li> <code>versions</code>               (<code>collections.abc.Sequence[sob.abc.Version] | None</code>)           \u2013            <p>One or more version specifiers to which this property applies.</p> <p>Version numbers prefixed by \"&lt;\" indicate any version less than the one specified, so \"&lt;3.0\" indicates that this property is available in versions prior to 3.0. The inverse is true for version numbers prefixed by \"&gt;\". \"&gt;=\" and \"&lt;=\" have similar meanings, but are inclusive.</p> <p>Versioning can be applied to a model's properties with <code>sob.version_model</code>. For example, one use would be within the <code>__init__</code> method of an <code>sob.Object</code> sub-class, in order to dynamically alter metadata based on version attributes.</p> </li> <li> <code>value_types</code>               (<code>sob.abc.Types | None</code>)           \u2013            <p>The type(s) of values/objects comprising the mapped values. Similar to <code>sob.Property().types</code>, but applied to values in the mapping/dictionary, not to the dictionary itself.</p> </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def __init__(\n    self,\n    value_types: type\n    | Sequence[type | Property]\n    | Undefined\n    | abc.Types\n    | None = UNDEFINED,\n    name: str | None = None,\n    *,\n    required: bool = False,\n    versions: str\n    | abc.Version\n    | Iterable[str | abc.Version]\n    | None = None,\n) -&gt; None:\n    self._value_types: abc.Types | None = type(  # noqa: SLF001\n        self\n    )._value_types\n    if value_types is not UNDEFINED:\n        self.value_types = value_types  # type: ignore\n    super().__init__(\n        name=name,\n        required=required,\n        versions=versions,\n    )\n</code></pre>"},{"location":"api/sob.properties/#sob.properties.has_mutable_types","title":"has_mutable_types","text":"<pre><code>has_mutable_types(\n    property_: sob.abc.Property | type[sob.abc.Property],\n) -&gt; bool\n</code></pre> <p>This function returns <code>True</code> if modification of the <code>.types</code> member of a property class or instance is permitted.</p> <p>Parameters:</p> <ul> <li> <code>property</code>           \u2013            </li> </ul> Source code in <code>sob/properties.py</code> <pre><code>def has_mutable_types(property_: abc.Property | type[abc.Property]) -&gt; bool:\n    \"\"\"\n    This function returns `True` if modification of the `.types` member of a\n    property class or instance is permitted.\n\n    Parameters:\n        property:\n    \"\"\"\n    property_type: type\n    if isinstance(property_, abc.Property):\n        property_type = type(property_)\n    else:\n        if not issubclass(property_, abc.Property):\n            raise TypeError(property_)\n        property_type = property_\n    return property_type._types is None  # noqa: SLF001\n</code></pre>"},{"location":"api/sob.thesaurus/","title":"sob.thesaurus","text":""},{"location":"api/sob.thesaurus/#sob.thesaurus","title":"sob.thesaurus","text":"<p>This module provides functionality for creating a data model from a set of example structures.</p>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Synonyms","title":"Synonyms","text":"<pre><code>Synonyms(\n    items: collections.abc.Iterable[\n        sob.abc.Readable | sob.abc.MarshallableTypes\n    ] = (),\n)\n</code></pre> <p>This class is a set-like object containing deserialized data, implied to represent variations of one type of entity, and is used to infer a model for that entity.</p> Source code in <code>sob/thesaurus.py</code> <pre><code>def __init__(\n    self, items: Iterable[abc.Readable | abc.MarshallableTypes] = ()\n) -&gt; None:\n    self._type: set[type] = set()\n    self._nullable: bool = False\n    self._set: set[abc.MarshallableTypes] = set()\n    if items:\n        self.__ior__(items)\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Synonyms.add","title":"add","text":"<pre><code>add(\n    item: sob.abc.Readable | sob.abc.MarshallableTypes,\n) -&gt; None\n</code></pre> <p>This method adds a synonymous item to the set. If the item is a file-like (input/output) object, that object is first read, deserialized, and unmarshalled.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>sob.abc.Readable | sob.abc.MarshallableTypes</code>)           \u2013            <p>A file-like or a JSON-serializable python object.</p> </li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def add(  # noqa: C901\n    self, item: abc.Readable | abc.MarshallableTypes\n) -&gt; None:\n    \"\"\"\n    This method adds a synonymous item to the set. If the item is a\n    file-like (input/output) object, that object is first read,\n    deserialized, and unmarshalled.\n\n    Parameters:\n        item: A file-like or a JSON-serializable python object.\n    \"\"\"\n    if not isinstance(item, (abc.Readable, *abc.MARSHALLABLE_TYPES)):\n        raise TypeError(item)\n    if isinstance(item, abc.Readable):\n        # Deserialize and unmarshal file-like objects\n        item = unmarshal(deserialize(_read(item))[0])\n    elif isinstance(item, Iterable) and not isinstance(\n        item, (str, abc.Model, Mapping)\n    ):\n        if isinstance(item, Iterable) and not isinstance(item, Sequence):\n            item = tuple(item)\n        # Unmarshal items which appear to not have been part of an\n        # unmarshalled container\n        item = unmarshal(item)\n    if isinstance(item, Null):\n        self._nullable = True\n    elif item is not None:\n        if not isinstance(item, MARSHALLABLE_TYPES):\n            raise TypeError(item)\n        item_type: type = (\n            list\n            if isinstance(item, abc.Array)\n            else dict\n            if isinstance(item, abc.Dictionary)\n            else type(item)\n        )\n        if (item_type is int) and float in self._type:\n            pass\n        elif (item_type is float) and int in self._type:\n            self._type.remove(int)\n            self._type.add(item_type)\n        else:\n            self._type.add(item_type)\n        if not isinstance(item, Hashable):\n            if isinstance(item, Mapping):\n                item = Dictionary(item)\n            if isinstance(item, Sequence):\n                item = Array(item)\n        self._set.add(item)  # type: ignore\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Synonyms.union","title":"union","text":"<pre><code>union(\n    other: collections.abc.Iterable[\n        sob.abc.Readable | sob.abc.MarshallableTypes\n    ],\n) -&gt; sob.thesaurus.Synonyms\n</code></pre> <p>This method returns an instance of <code>Synonyms</code> which incorporates all (non-redundant) items from both <code>self</code> and <code>other</code>.</p> Source code in <code>sob/thesaurus.py</code> <pre><code>def union(\n    self, other: Iterable[abc.Readable | abc.MarshallableTypes]\n) -&gt; Synonyms:\n    \"\"\"\n    This method returns an instance of `Synonyms` which incorporates\n    all (non-redundant) items from both `self` and `other`.\n    \"\"\"\n    new_synonyms: Synonyms = copy(self)\n    new_synonyms |= other\n    return new_synonyms\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Synonyms.get_models","title":"get_models","text":"<pre><code>get_models(\n    pointer: str,\n    module: str = \"__main__\",\n    name: collections.abc.Callable[\n        [str], str\n    ] = sob.thesaurus.get_class_name_from_pointer,\n) -&gt; collections.abc.Iterable[type]\n</code></pre> <p>Retrieve a sequence of class definitions representing a data model capable of describing these synonyms.</p> <p>Parameters:</p> <ul> <li>pointer (str): A JSON pointer for the top-level model class, used to   infer class names.</li> <li>module (str): The name of the module in which model classes will be   defined. This defaults to \"main\".</li> <li>name (str) = sob.thesaurus.get_class_name_from_pointer:   A function which accepts one <code>str</code> argument\u2014a synonym key   concatenated with \"#\" and JSON pointer (for example:   \"key#/body/items/0\") and which returns a <code>str</code> which will be the   resulting class name (for example: \"KeyBodyItemsItem\").</li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def get_models(\n    self,\n    pointer: str,\n    module: str = \"__main__\",\n    name: Callable[[str], str] = get_class_name_from_pointer,\n) -&gt; Iterable[type]:\n    \"\"\"\n    Retrieve a sequence of class definitions representing a data model\n    capable of describing these synonyms.\n\n    Parameters:\n\n    - pointer (str): A JSON pointer for the top-level model class, used to\n      infer class names.\n    - module (str): The name of the module in which model classes will be\n      defined. This defaults to \"__main__\".\n    - name (str) = sob.thesaurus.get_class_name_from_pointer:\n      A function which accepts one `str` argument\u2014a synonym key\n      concatenated with \"#\" and JSON pointer (for example:\n      \"key#/body/items/0\") and which returns a `str` which will be the\n      resulting class name (for example: \"KeyBodyItemsItem\").\n    \"\"\"\n    if not callable(name):\n        raise TypeError(name)\n    # This assertion ensures `self` contains data which can be described by\n    # a model class.\n    message: str\n    if not self._type:\n        message = \"No type could be identified\"\n        raise RuntimeError(message)\n    quoted_pointer: str = \"{}#\".format(quote_plus(pointer, safe=\"/+\"))\n    for model_class in self._iter_types(\n        pointer=quoted_pointer,\n        module=module,\n        name=name,\n    ):\n        if not issubclass(model_class, abc.Model):\n            raise TypeError((quoted_pointer, model_class))\n        yield model_class\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus","title":"Thesaurus","text":"<pre><code>Thesaurus(\n    _items: (\n        collections.abc.Mapping[\n            str,\n            collections.abc.Iterable[\n                sob.abc.Readable | sob.abc.MarshallableTypes\n            ]\n            | sob.thesaurus.Synonyms,\n        ]\n        | collections.abc.Iterable[\n            tuple[\n                str,\n                collections.abc.Iterable[\n                    sob.abc.Readable\n                    | sob.abc.MarshallableTypes\n                ]\n                | sob.thesaurus.Synonyms,\n            ]\n        ]\n        | sob.thesaurus.Thesaurus\n        | None\n    ) = None,\n    **kwargs: collections.abc.Iterable[\n        sob.abc.Readable | sob.abc.MarshallableTypes\n    ]\n)\n</code></pre> <p>An instance of <code>sob.Thesaurus</code> is a dictionary-like object wherein each value is an instance of <code>sob.Synonyms</code>.</p> <p>For example, if you have an API with several GET endpoints, the endpoint paths relative to the API base URL would make ideal keys for your <code>sob.Thesaurus</code> instance. After adding a representative sample of responses from each endpoint to the corresponding <code>sob.Synonyms</code> instance in your <code>sob.Thesaurus</code> instance, your thesaurus will be able to generate a python module with an <code>sob</code> based data model for all of your endpoints, including polymorphism where encountered.</p> <p>The keys of an <code>sob.Thesaurus</code> dictionary are meaningful in that they contribute to the naming of classes (which are formatted to comply with PEP-8, and to avoid collision with builtins, language keywords, etc.).</p> <p>For background: The <code>sob</code> library was designed for authoring a data model representing schemas defined by an OpenAPI specification. Although OpenAPI specifications are increasingly ubiquitous, there are scenarios where you might need to interact with an API which does not have an OpenAPI specification, or for which the OpenAPI specification is simply not available to you. In these cases, you can generate an <code>sob</code> model to validate your API responses using <code>sob.Thesaurus</code>.</p> <p>Parameters:</p> <ul> <li> <code>_items</code>               (<code>collections.abc.Mapping[str, collections.abc.Iterable[sob.abc.Readable | sob.abc.MarshallableTypes] | sob.thesaurus.Synonyms] | collections.abc.Iterable[tuple[str, collections.abc.Iterable[sob.abc.Readable | sob.abc.MarshallableTypes] | sob.thesaurus.Synonyms]] | sob.thesaurus.Thesaurus | None</code>, default:                   <code>None</code> )           \u2013            <p>A mapping of keys to values, where each value is an iterable of items which are synonymous with the key. This can either be an iterable of key/value pair tuples, or a dictionary-like object.</p> </li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def __init__(\n    self,\n    _items: Mapping[\n        str, Iterable[abc.Readable | abc.MarshallableTypes] | Synonyms\n    ]\n    | Iterable[\n        tuple[\n            str, Iterable[abc.Readable | abc.MarshallableTypes] | Synonyms\n        ]\n    ]\n    | Thesaurus\n    | None = None,\n    **kwargs: Iterable[abc.Readable | abc.MarshallableTypes],\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        _items: A mapping of keys to values, where each value is\n            an iterable of items which are synonymous with the key.\n            This can either be an iterable of key/value pair tuples,\n            or a dictionary-like object.\n    \"\"\"\n    self._dict: dict[str, Synonyms] = {}\n    key: str\n    value: Iterable[abc.Readable | abc.MarshallableTypes]\n    for key, value in dict(\n        *((_items,) if _items else ()), **kwargs\n    ).items():\n        self[key] = value\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    key: str,\n    value: (\n        sob.thesaurus.Synonyms\n        | collections.abc.Iterable[\n            sob.abc.Readable | sob.abc.MarshallableTypes\n        ]\n    ),\n) -&gt; None\n</code></pre> <p>This method adds/overwrites the synonyms for the specified <code>key</code>. If the <code>value</code> is not an instance of <code>sob.Synonyms</code>, a new instance of <code>sob.Synonyms</code> is created and JSON data items from <code>value</code> are added to it.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>A string to utilize when attributing a unique name to the class representing these synonyms.</p> </li> <li> <code>value</code>               (<code>sob.thesaurus.Synonyms | collections.abc.Iterable[sob.abc.Readable | sob.abc.MarshallableTypes]</code>)           \u2013            <p>An iterable of JSON data which should be considered synonymous.</p> </li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def __setitem__(\n    self,\n    key: str,\n    value: Synonyms | Iterable[abc.Readable | abc.MarshallableTypes],\n) -&gt; None:\n    \"\"\"\n    This method adds/overwrites the synonyms for the specified `key`.\n    If the `value` is not an instance of `sob.Synonyms`, a new instance\n    of `sob.Synonyms` is created and JSON data items from `value` are\n    added to it.\n\n    Parameters:\n        key: A string to utilize when attributing a unique name to the\n            class representing these synonyms.\n        value: An iterable of JSON data which should be considered\n            synonymous.\n    \"\"\"\n    if not isinstance(value, Synonyms):\n        value = Synonyms(value)\n    return self._dict.__setitem__(key, value)\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key: str) -&gt; None\n</code></pre> <p>This method deletes the synonyms assigned the specified <code>key</code>.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            </li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def __delitem__(self, key: str) -&gt; None:\n    \"\"\"\n    This method deletes the synonyms assigned the specified `key`.\n\n    Parameters:\n        key:\n    \"\"\"\n    self._dict.__delitem__(key)\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.pop","title":"pop","text":"<pre><code>pop(\n    key: str,\n    default: (\n        sob.thesaurus.Synonyms | sob._types.Undefined\n    ) = sob._types.UNDEFINED,\n) -&gt; sob.thesaurus.Synonyms\n</code></pre> <p>This method removes and returns the synonyms assigned to the specified <code>key</code>.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            </li> <li> <code>default</code>               (<code>sob.thesaurus.Synonyms | sob._types.Undefined</code>, default:                   <code>sob._types.UNDEFINED</code> )           \u2013            <p>A value to return if the specified <code>key</code> does not exist. If no default is provided, a <code>KeyError</code> will be raised if the key is not found.</p> </li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def pop(\n    self, key: str, default: Synonyms | Undefined = UNDEFINED\n) -&gt; Synonyms:\n    \"\"\"\n    This method removes and returns the synonyms assigned to the specified\n    `key`.\n\n    Parameters:\n        key:\n        default: A value to return if the specified `key` does not exist.\n            If no default is provided, a `KeyError` will be raised if the\n            key is not found.\n    \"\"\"\n    return self._dict.pop(\n        key,\n        **({} if isinstance(default, Undefined) else {\"default\": default}),\n    )\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.popitem","title":"popitem","text":"<pre><code>popitem() -&gt; tuple[str, sob.thesaurus.Synonyms]\n</code></pre> <p>This method removes and returns a tuple of the most recently added key/synonyms pair (by default), or the first added key/synonyms pair if <code>last</code> is set to <code>False</code>.</p> Source code in <code>sob/thesaurus.py</code> <pre><code>def popitem(self) -&gt; tuple[str, Synonyms]:\n    \"\"\"\n    This method removes and returns a tuple of the most recently added\n    key/synonyms pair (by default), or the first added key/synonyms pair\n    if `last` is set to `False`.\n    \"\"\"\n    return self._dict.popitem()\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>This method clears the thesaurus, removing all synonyms.</p> Source code in <code>sob/thesaurus.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    This method clears the thesaurus, removing all synonyms.\n    \"\"\"\n    self._dict.clear()\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.update","title":"update","text":"<pre><code>update(\n    **kwargs: (\n        sob.thesaurus.Synonyms\n        | collections.abc.Iterable[\n            sob.abc.Readable | sob.abc.MarshallableTypes\n        ]\n    ),\n) -&gt; None\n</code></pre> <p>This method updates the thesaurus with one or more specified synonyms.</p> <p>Parameters:</p> <ul> <li> <code>kwargs</code>               (<code>sob.thesaurus.Synonyms | collections.abc.Iterable[sob.abc.Readable | sob.abc.MarshallableTypes]</code>, default:                   <code>{}</code> )           \u2013            <p>A mapping of keys to values, where each value is an iterable of items which are synonymous with the key, or is an instance of <code>sob.Synonyms</code>.</p> </li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def update(\n    self,\n    **kwargs: Synonyms | Iterable[abc.Readable | abc.MarshallableTypes],\n) -&gt; None:\n    \"\"\"\n    This method updates the thesaurus with one or more specified synonyms.\n\n    Parameters:\n        kwargs: A mapping of keys to values, where each value is\n            an iterable of items which are synonymous with the key,\n            or is an instance of `sob.Synonyms`.\n    \"\"\"\n    key: str\n    value: Iterable[abc.Readable | abc.MarshallableTypes]\n    for key, value in kwargs.items():\n        self[key] = value\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.setdefault","title":"setdefault","text":"<pre><code>setdefault(\n    key: str,\n    default: collections.abc.Iterable[\n        sob.abc.Readable | sob.abc.MarshallableTypes\n    ],\n) -&gt; sob.thesaurus.Synonyms\n</code></pre> <p>This method assigns <code>default</code> synonyms to the specified <code>key</code> if no synonyms have previously been assigned to the key, and returns either the existing or newly assigned synonyms.</p> Source code in <code>sob/thesaurus.py</code> <pre><code>def setdefault(\n    self,\n    key: str,\n    default: Iterable[abc.Readable | abc.MarshallableTypes],\n) -&gt; Synonyms:\n    \"\"\"\n    This method assigns `default` synonyms to the specified `key` if\n    no synonyms have previously been assigned to the key, and returns\n    either the existing or newly assigned synonyms.\n    \"\"\"\n    if not isinstance(default, Synonyms):\n        default = Synonyms(default)\n    return self._dict.setdefault(key, default)\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.get_module_source","title":"get_module_source","text":"<pre><code>get_module_source(\n    name: collections.abc.Callable[\n        [str], str\n    ] = sob.thesaurus.get_class_name_from_pointer,\n) -&gt; str\n</code></pre> <p>This method generates and returns the source code for a module defining data models applicable to the data contained in this thesaurus.</p> <p>Parameters:</p> <ul> <li>name (str) = sob.thesaurus.get_class_name_from_pointer:   A function which accepts one <code>str</code> argument\u2014a synonym key   concatenated with \"#\" and JSON pointer (for example:   \"key#/body/items/0\") and which returns a <code>str</code> which will be the   resulting class name (for example: \"KeyBodyItemsItem\").</li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def get_module_source(\n    self, name: Callable[[str], str] = get_class_name_from_pointer\n) -&gt; str:\n    \"\"\"\n    This method generates and returns the source code for a module\n    defining data models applicable to the data contained in this\n    thesaurus.\n\n    Parameters:\n\n    - name (str) = sob.thesaurus.get_class_name_from_pointer:\n      A function which accepts one `str` argument\u2014a synonym key\n      concatenated with \"#\" and JSON pointer (for example:\n      \"key#/body/items/0\") and which returns a `str` which will be the\n      resulting class name (for example: \"KeyBodyItemsItem\").\n    \"\"\"\n    return get_models_source(\n        *self.get_models(module=\"__main__\", name=name)\n    )\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.get_module","title":"get_module","text":"<pre><code>get_module(\n    name: collections.abc.Callable[\n        [str], str\n    ] = sob.thesaurus.get_class_name_from_pointer,\n) -&gt; types.ModuleType\n</code></pre> <p>This method generates and returns a module defining data models applicable to the data contained in this thesaurus. This module is not suitable for writing out for static use--use <code>Thesaurus.save_module</code> to generate and write a model suitable for static use.</p> <p>Parameters:</p> <ul> <li>name (str) = sob.thesaurus.get_class_name_from_pointer:   A function which accepts one <code>str</code> argument\u2014a synonym key   concatenated with \"#\" and JSON pointer (for example:   \"key#/body/items/0\") and which returns a <code>str</code> which will be the   resulting class name (for example: \"KeyBodyItemsItem\").</li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def get_module(\n    self, name: Callable[[str], str] = get_class_name_from_pointer\n) -&gt; ModuleType:\n    \"\"\"\n    This method generates and returns a module defining data models\n    applicable to the data contained in this thesaurus. This module is not\n    suitable for writing out for static use--use `Thesaurus.save_module`\n    to generate and write a model suitable for static use.\n\n    Parameters:\n\n    - name (str) = sob.thesaurus.get_class_name_from_pointer:\n      A function which accepts one `str` argument\u2014a synonym key\n      concatenated with \"#\" and JSON pointer (for example:\n      \"key#/body/items/0\") and which returns a `str` which will be the\n      resulting class name (for example: \"KeyBodyItemsItem\").\n    \"\"\"\n    # For pickling to work, the `__module__` variable needs to be set to\n    # the calling module.\n    module_name: str = get_calling_module_name(2)\n    module: ModuleType = ModuleType(module_name)\n    exec(  # noqa: S102\n        self._get_module_source(module_name, name=name), module.__dict__\n    )\n    return module\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.Thesaurus.save_module","title":"save_module","text":"<pre><code>save_module(\n    path: str | pathlib.Path,\n    name: collections.abc.Callable[\n        [str], str\n    ] = sob.thesaurus.get_class_name_from_pointer,\n) -&gt; None\n</code></pre> <p>This method generates and saves the source code for a module defining data models applicable to the data contained in this thesaurus.</p> <p>Parameters:</p> <ul> <li>path (str): The file path where the data will be written.</li> <li>name (str) = sob.thesaurus.get_class_name_from_pointer:   A function which accepts one <code>str</code> argument\u2014a synonym key   concatenated with \"#\" and JSON pointer (for example:   \"key#/body/items/0\") and which returns a <code>str</code> which will be the   resulting class name (for example: \"KeyBodyItemsItem\").</li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def save_module(\n    self,\n    path: str | Path,\n    name: Callable[[str], str] = get_class_name_from_pointer,\n) -&gt; None:\n    \"\"\"\n    This method generates and saves the source code for a module\n    defining data models applicable to the data contained in this\n    thesaurus.\n\n    Parameters:\n\n    - path (str): The file path where the data will be written.\n    - name (str) = sob.thesaurus.get_class_name_from_pointer:\n      A function which accepts one `str` argument\u2014a synonym key\n      concatenated with \"#\" and JSON pointer (for example:\n      \"key#/body/items/0\") and which returns a `str` which will be the\n      resulting class name (for example: \"KeyBodyItemsItem\").\n    \"\"\"\n    if isinstance(path, str):\n        path = Path(path)\n    os.makedirs(path.parent, exist_ok=True)\n    module_source: str = self.get_module_source(name=name)\n    with open(path, \"w\") as module_io:\n        module_io.write(f\"{module_source}\\n\")\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.get_class_name_from_pointer","title":"get_class_name_from_pointer","text":"<pre><code>get_class_name_from_pointer(pointer: str) -&gt; str\n</code></pre> <p>This function creates a class name based on the <code>sob.Thesaurus</code> key of the <code>sob.Synonyms</code> instance to which an element belongs, combined with the JSON pointer of the applicable element. This function can be substituted for another, when generating a module from a thesaurus, by passing a function to the <code>name</code> parameter of <code>sob.Thesaurus.get_module_source</code>, <code>sob.Thesaurus.get_module</code>, or <code>sob.Thesaurus.save_module</code>.</p> <p>Parameters:</p> <ul> <li>pointer (str): The synonyms key + JSON pointer of the element for which   the class is being generated.</li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def get_class_name_from_pointer(pointer: str) -&gt; str:\n    \"\"\"\n    This function creates a class name based on the `sob.Thesaurus` key of the\n    `sob.Synonyms` instance to which an element belongs,\n    combined with the *JSON pointer* of the applicable element. This function\n    can be substituted for another, when generating a module from a thesaurus,\n    by passing a function to the `name` parameter of\n    `sob.Thesaurus.get_module_source`, `sob.Thesaurus.get_module`, or\n    `sob.Thesaurus.save_module`.\n\n    Parameters:\n\n    - pointer (str): The synonyms key + JSON pointer of the element for which\n      the class is being generated.\n    \"\"\"\n    return get_class_name(\n        f\"{pointer[:-2]}/item\"\n        if pointer.endswith(\"/0\")\n        else pointer.replace(\"/0/\", \"/item/\")\n    )\n</code></pre>"},{"location":"api/sob.thesaurus/#sob.thesaurus.get_class_meta_attribute_assignment_source","title":"get_class_meta_attribute_assignment_source","text":"<pre><code>get_class_meta_attribute_assignment_source(\n    class_name_: str,\n    attribute_name: str,\n    metadata: sob.abc.Meta,\n) -&gt; str\n</code></pre> <p>This function generates source code for setting a metadata attribute on a class.</p> <p>Parameters:</p> <ul> <li>class_name (str): The name of the class to which we want to assign a   metadata attribute.</li> <li>attribute_name (str): The name of the attribute we want to assign.</li> <li>metadata (sob.abc.Meta): The metadata from which to take the assigned   value.</li> </ul> Source code in <code>sob/thesaurus.py</code> <pre><code>def get_class_meta_attribute_assignment_source(\n    class_name_: str,\n    attribute_name: str,\n    metadata: abc.Meta,\n) -&gt; str:\n    \"\"\"\n    This function generates source code for setting a metadata attribute on\n    a class.\n\n    Parameters:\n\n    - class_name (str): The name of the class to which we want to assign a\n      metadata attribute.\n    - attribute_name (str): The name of the attribute we want to assign.\n    - metadata (sob.abc.Meta): The metadata from which to take the assigned\n      value.\n    \"\"\"\n    writable_function_name: str = \"sob.get_writable_{}_meta\".format(\n        \"object\"\n        if isinstance(metadata, abc.ObjectMeta)\n        else (\"array\" if isinstance(metadata, abc.ArrayMeta) else \"dictionary\")\n    )\n    # We insert \"  # type: ignore\" at the end of the first line where the value\n    # is assigned due to mypy issues with properties having getters and setters\n    return suffix_long_lines(\n        (\n            f\"{writable_function_name}(  # type: ignore\\n\"\n            f\"    {suffix_long_lines(class_name_, -4)}\\n\"\n            f\").{attribute_name} = \"\n            f\"{represent(getattr(metadata, attribute_name))}\"\n        ),\n        -4,\n    )\n</code></pre>"},{"location":"api/sob.types/","title":"sob.types","text":""},{"location":"api/sob.types/#sob.types","title":"sob.types","text":""},{"location":"api/sob.types/#sob.types.NULL","title":"NULL  <code>module-attribute</code>","text":"<pre><code>NULL: sob._types.Null = sob._types.Null()\n</code></pre> <p><code>sob.NULL</code> is the singleton instance of <code>sob.Null</code>, and is used to represent an explicit <code>null</code> value in JSON, whereas in the context of an instance of a sub-class of <code>sob.Object</code>\u2014<code>None</code> indicates the absence of a property value.</p>"},{"location":"api/sob.types/#sob.types.UNDEFINED","title":"UNDEFINED  <code>module-attribute</code>","text":"<pre><code>UNDEFINED: sob._types.Undefined = sob._types.Undefined()\n</code></pre> <p><code>sob.UNDEFINED</code> is the singleton instance of <code>sob.Undefined</code>, and is used to indicate that a parameter has not been passed to a function or method keyword.</p>"},{"location":"api/sob.types/#sob.types.Null","title":"Null","text":"<pre><code>Null()\n</code></pre> <p>Instances of this class represent an explicit null value, rather than the absence of a property/attribute/element, as would be inferred from a value of <code>None</code>.</p> <p>Note: Like the built-in value <code>None</code>, only one instance of this class is permitted (it's a singleton), so this class should never be instantiated, it should always be referenced through the constant <code>sob.NULL</code>.</p> Source code in <code>sob/_types.py</code> <pre><code>def __init__(self) -&gt; None:\n    if \"NULL\" in _module_locals:\n        message: str = f\"{self!r} may only be defined once.\"\n        raise DefinitionExistsError(message)\n</code></pre>"},{"location":"api/sob.types/#sob.types.Undefined","title":"Undefined","text":"<pre><code>Undefined()\n</code></pre> <p>This class is intended to indicate that a parameter has not been passed to a keyword argument in situations where <code>None</code> is to be used as a meaningful value.</p> <p>The <code>Undefined</code> class is a singleton, so only one instance of this class is permitted: <code>sob.UNDEFINED</code>.</p> Source code in <code>sob/_types.py</code> <pre><code>def __init__(self) -&gt; None:\n    # Only one instance of `Undefined` is permitted, so initialization\n    # checks to make sure this is the first use.\n    if \"UNDEFINED\" in _module_locals:\n        message: str = f\"{self!r} may only be instantiated once.\"\n        raise DefinitionExistsError(message)\n</code></pre>"},{"location":"api/sob.types/#sob.types.Types","title":"Types","text":"<pre><code>Types(\n    items: (\n        sob.abc.Types\n        | collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Types</code></p> <p>Instances of this class are immutable lists of types and/or property definitions.</p> Source code in <code>sob/types.py</code> <pre><code>def __init__(\n    self,\n    items: abc.Types\n    | Iterable[type | abc.Property]\n    | type\n    | abc.Property\n    | None = None,\n) -&gt; None:\n    if isinstance(items, (type, abc.Property)):\n        items = (items,)\n    self._list: list[type | abc.Property] = []\n    if items is not None:\n        self._extend(items)\n</code></pre>"},{"location":"api/sob.types/#sob.types.MutableTypes","title":"MutableTypes","text":"<pre><code>MutableTypes(\n    items: (\n        sob.abc.Types\n        | collections.abc.Iterable[type | sob.abc.Property]\n        | type\n        | sob.abc.Property\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.types.Types</code>, <code>sob.abc.MutableTypes</code></p> <p>Instances of this class are (mutable) lists of types and/or property definitions.</p> Source code in <code>sob/types.py</code> <pre><code>def __init__(\n    self,\n    items: abc.Types\n    | Iterable[type | abc.Property]\n    | type\n    | abc.Property\n    | None = None,\n) -&gt; None:\n    if isinstance(items, (type, abc.Property)):\n        items = (items,)\n    self._list: list[type | abc.Property] = []\n    if items is not None:\n        self._extend(items)\n</code></pre>"},{"location":"api/sob.utilities/","title":"sob.utilities","text":""},{"location":"api/sob.utilities/#sob.utilities","title":"sob.utilities","text":""},{"location":"api/sob.utilities/#sob.utilities.get_property_name","title":"get_property_name","text":"<pre><code>get_property_name(name: str) -&gt; str\n</code></pre> <p>Converts a \"camelCased\" attribute/property name, a name which conflicts with a python keyword, or an otherwise non-compatible string to a PEP-8 compliant property name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBees\"))\nthe_birds_and_the_bees\n\n&gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBEEs\"))\nthe_birds_and_the_bees\n\n&gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBEEsEs\"))\nthe_birds_and_the_be_es_es\n\n&gt;&gt;&gt; print(get_property_name(\"FYIThisIsAnAcronym\"))\nfyi_this_is_an_acronym\n\n&gt;&gt;&gt; print(get_property_name(\"in\"))\nin_\n\n&gt;&gt;&gt; print(get_property_name(\"id\"))\nid_\n\n&gt;&gt;&gt; print(get_property_name(\"one2one\"))  # No change needed\none2one\n\n&gt;&gt;&gt; print(get_property_name(\"One2One\"))\none_2_one\n\n&gt;&gt;&gt; print(get_property_name(\"@One2One\"))\none_2_one\n\n&gt;&gt;&gt; print(get_property_name(\"One2One-ALL\"))\none_2_one_all\n\n&gt;&gt;&gt; print(get_property_name(\"one2one-ALL\"))\none2one_all\n\n&gt;&gt;&gt; print(get_property_name(\"type\"))\ntype_\n\n&gt;&gt;&gt; print(get_property_name(\"@type\"))\ntype_\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def get_property_name(name: str) -&gt; str:\n    \"\"\"\n    Converts a \"camelCased\" attribute/property name, a name which conflicts\n    with a python keyword, or an otherwise non-compatible string to a PEP-8\n    compliant property name.\n\n    Examples:\n\n        &gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBees\"))\n        the_birds_and_the_bees\n\n        &gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBEEs\"))\n        the_birds_and_the_bees\n\n        &gt;&gt;&gt; print(get_property_name(\"theBirdsAndTheBEEsEs\"))\n        the_birds_and_the_be_es_es\n\n        &gt;&gt;&gt; print(get_property_name(\"FYIThisIsAnAcronym\"))\n        fyi_this_is_an_acronym\n\n        &gt;&gt;&gt; print(get_property_name(\"in\"))\n        in_\n\n        &gt;&gt;&gt; print(get_property_name(\"id\"))\n        id_\n\n        &gt;&gt;&gt; print(get_property_name(\"one2one\"))  # No change needed\n        one2one\n\n        &gt;&gt;&gt; print(get_property_name(\"One2One\"))\n        one_2_one\n\n        &gt;&gt;&gt; print(get_property_name(\"@One2One\"))\n        one_2_one\n\n        &gt;&gt;&gt; print(get_property_name(\"One2One-ALL\"))\n        one_2_one_all\n\n        &gt;&gt;&gt; print(get_property_name(\"one2one-ALL\"))\n        one2one_all\n\n        &gt;&gt;&gt; print(get_property_name(\"type\"))\n        type_\n\n        &gt;&gt;&gt; print(get_property_name(\"@type\"))\n        type_\n    \"\"\"\n    # Replace accented and otherwise modified latin characters with their\n    # basic latin equivalent\n    name = normalize(\"NFKD\", name)\n    # Replace any remaining non-latin characters with underscores\n    name = re.sub(r\"([^\\x20-\\x7F]|\\s)+\", \"_\", name)\n    # Only insert underscores between letters and numbers if camelCasing is\n    # found in the original string\n    if re.search(r\"[A-Z][a-z]\", name) or re.search(r\"[a-z][A-Z]\", name):\n        name = re.sub(r\"([0-9])([a-zA-Z])\", r\"\\1_\\2\", name)\n        name = re.sub(r\"([a-zA-Z])([0-9])\", r\"\\1_\\2\", name)\n    # Insert underscores between lowercase and uppercase characters\n    name = re.sub(r\"([a-z])([A-Z])\", r\"\\1_\\2\", name)\n    # Insert underscores between uppercase characters and following uppercase\n    # characters which are followed by lowercase characters (indicating the\n    # latter uppercase character was intended as part of a capitalized word),\n    # except where the trailing lowercase character is a solo lowercase \"s\"\n    # (pluralizing the acronym).\n    name = re.sub(r\"([A-Z])([A-Z])([a-rt-z]|s(?!\\b))\", r\"\\1_\\2\\3\", name)\n    # Replace any series of one or more non-alphanumeric characters remaining\n    # with a single underscore\n    name = re.sub(r\"[^\\w_]+\", \"_\", name).lower()\n    # Replace any two or more adjacent underscores with a single underscore\n    name = re.sub(r\"__+\", \"_\", name).lstrip(\"_\")\n    # Append an underscore to the keyword until it does not conflict with any\n    # python keywords, built-ins, or potential module imports\n    while (\n        iskeyword(name)\n        or (name in builtins.__dict__)\n        or (name in {\"self\", \"decimal\", \"datetime\", \"typing\", \"type\"})\n    ):\n        name = f\"{name}_\"\n    return name\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.get_class_name","title":"get_class_name","text":"<pre><code>get_class_name(name: str) -&gt; str\n</code></pre> <p>This function accepts a string and returns a variation of that string which is a PEP-8 compatible python class name.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(get_class_name(\"the birds and the bees\"))\nTheBirdsAndTheBees\n\n&gt;&gt;&gt; print(get_class_name(\"the-birds-and-the-bees\"))\nTheBirdsAndTheBees\n\n&gt;&gt;&gt; print(get_class_name(\"**the - birds - and - the - bees**\"))\nTheBirdsAndTheBees\n\n&gt;&gt;&gt; print(get_class_name(\"FYI is an acronym\"))\nFYIIsAnAcronym\n\n&gt;&gt;&gt; print(get_class_name(\"in-you-go\"))\nInYouGo\n\n&gt;&gt;&gt; print(get_class_name(\"False\"))\nFalse_\n\n&gt;&gt;&gt; print(get_class_name(\"True\"))\nTrue_\n\n&gt;&gt;&gt; print(get_class_name(\"ABC Acronym\"))\nABCAcronym\n\n&gt;&gt;&gt; print(get_class_name(\"AB CD Efg\"))\nABCdEfg\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def get_class_name(name: str) -&gt; str:\n    \"\"\"\n    This function accepts a string and returns a variation of that string\n    which is a PEP-8 compatible python class name.\n\n    Examples:\n\n        &gt;&gt;&gt; print(get_class_name(\"the birds and the bees\"))\n        TheBirdsAndTheBees\n\n        &gt;&gt;&gt; print(get_class_name(\"the-birds-and-the-bees\"))\n        TheBirdsAndTheBees\n\n        &gt;&gt;&gt; print(get_class_name(\"**the - birds - and - the - bees**\"))\n        TheBirdsAndTheBees\n\n        &gt;&gt;&gt; print(get_class_name(\"FYI is an acronym\"))\n        FYIIsAnAcronym\n\n        &gt;&gt;&gt; print(get_class_name(\"in-you-go\"))\n        InYouGo\n\n        &gt;&gt;&gt; print(get_class_name(\"False\"))\n        False_\n\n        &gt;&gt;&gt; print(get_class_name(\"True\"))\n        True_\n\n        &gt;&gt;&gt; print(get_class_name(\"ABC Acronym\"))\n        ABCAcronym\n\n        &gt;&gt;&gt; print(get_class_name(\"AB CD Efg\"))\n        ABCdEfg\n    \"\"\"\n    name = camel(name, capitalize=True)\n    while iskeyword(name) or (name in builtins.__dict__):\n        name = f\"{name}_\"\n    if name.startswith(_DIGITS_TUPLE):\n        name = f\"_{name}\"\n    return name\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.camel","title":"camel","text":"<pre><code>camel(string: str, *, capitalize: bool = False) -&gt; str\n</code></pre> <p>This function returns a camelCased representation of the input string.</p> <p>Parameters:</p> <ul> <li> <code>string</code>               (<code>str</code>)           \u2013            <p>The string to be camelCased.</p> </li> <li> <code>capitalize</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If this is <code>true</code>, the first letter will be capitalized.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(camel(\"the birds and the bees\"))\ntheBirdsAndTheBees\n\n&gt;&gt;&gt; print(camel(\"the birds and the bees\", capitalize=True))\nTheBirdsAndTheBees\n\n&gt;&gt;&gt; print(camel(\"the-birds-and-the-bees\"))\ntheBirdsAndTheBees\n\n&gt;&gt;&gt; print(camel(\"**the - birds - and - the - bees**\"))\ntheBirdsAndTheBees\n\n&gt;&gt;&gt; print(camel(\"FYI is an acronym\"))\nFYIIsAnAcronym\n\n&gt;&gt;&gt; print(camel(\"in-you-go\"))\ninYouGo\n\n&gt;&gt;&gt; print(camel(\"False\"))\nfalse\n\n&gt;&gt;&gt; print(camel(\"True\"))\ntrue\n\n&gt;&gt;&gt; print(camel(\"in\"))\nin\n\n&gt;&gt;&gt; print(camel(\"AB CD Efg\", capitalize=True))\nABCdEfg\n\n&gt;&gt;&gt; print(camel(\"ABC DEF GHI\", capitalize=True))\nAbcDefGhi\n\n&gt;&gt;&gt; print(camel(\"ABC_DEF_GHI\", capitalize=True))\nAbcDefGhi\n\n&gt;&gt;&gt; print(camel(\"ABC DEF GHI\"))\nabcDefGhi\n\n&gt;&gt;&gt; print(camel(\"ABC_DEF_GHI\"))\nabcDefGhi\n\n&gt;&gt;&gt; print(camel(\"AB_CDEfg\"))\nABCdEfg\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def camel(string: str, *, capitalize: bool = False) -&gt; str:\n    \"\"\"\n    This function returns a camelCased representation of the input string.\n\n    Parameters:\n        string: The string to be camelCased.\n        capitalize: If this is `true`, the first letter will be capitalized.\n\n    Examples:\n\n        &gt;&gt;&gt; print(camel(\"the birds and the bees\"))\n        theBirdsAndTheBees\n\n        &gt;&gt;&gt; print(camel(\"the birds and the bees\", capitalize=True))\n        TheBirdsAndTheBees\n\n        &gt;&gt;&gt; print(camel(\"the-birds-and-the-bees\"))\n        theBirdsAndTheBees\n\n        &gt;&gt;&gt; print(camel(\"**the - birds - and - the - bees**\"))\n        theBirdsAndTheBees\n\n        &gt;&gt;&gt; print(camel(\"FYI is an acronym\"))\n        FYIIsAnAcronym\n\n        &gt;&gt;&gt; print(camel(\"in-you-go\"))\n        inYouGo\n\n        &gt;&gt;&gt; print(camel(\"False\"))\n        false\n\n        &gt;&gt;&gt; print(camel(\"True\"))\n        true\n\n        &gt;&gt;&gt; print(camel(\"in\"))\n        in\n\n        &gt;&gt;&gt; print(camel(\"AB CD Efg\", capitalize=True))\n        ABCdEfg\n\n        &gt;&gt;&gt; print(camel(\"ABC DEF GHI\", capitalize=True))\n        AbcDefGhi\n\n        &gt;&gt;&gt; print(camel(\"ABC_DEF_GHI\", capitalize=True))\n        AbcDefGhi\n\n        &gt;&gt;&gt; print(camel(\"ABC DEF GHI\"))\n        abcDefGhi\n\n        &gt;&gt;&gt; print(camel(\"ABC_DEF_GHI\"))\n        abcDefGhi\n\n        &gt;&gt;&gt; print(camel(\"AB_CDEfg\"))\n        ABCdEfg\n    \"\"\"\n    index: int\n    character: str\n    string = normalize(\"NFKD\", string)\n    characters: list[str] = []\n    all_uppercase: bool = string.upper() == string\n    capitalize_next: bool = capitalize\n    uncapitalize_next: bool = (not capitalize) and (\n        len(string) &lt; 2  # noqa: PLR2004\n        or all_uppercase\n        or not (\n            string[0] in _UPPERCASE_ALPHABET\n            and string[1] in _UPPERCASE_ALPHABET\n        )\n    )\n    for index, character in enumerate(string):\n        if character in _ALPHANUMERIC_CHARACTERS:\n            if capitalize_next:\n                if all_uppercase:\n                    uncapitalize_next = True\n                elif capitalize or characters:\n                    # This prevents two acronyms which are adjacent from\n                    # retaining capitalization (since word separations would\n                    # not be possible to identify if caps were kept for both)\n                    if characters and (characters[-1] in _UPPERCASE_ALPHABET):\n                        uncapitalize_next = True\n                    character = character.upper()  # noqa: PLW2901\n            elif uncapitalize_next and character:\n                if character in _LOWERCASE_ALPHABET:\n                    uncapitalize_next = False\n                else:\n                    character = character.lower()  # noqa: PLW2901\n                    # Halt lowercasing if the next character starts a\n                    # camelCased word\n                    next_index: int = index + 1\n                    tail: str = string[next_index:]\n                    if (\n                        len(tail) &gt; 1\n                        and tail[0] in _UPPERCASE_ALPHABET\n                        and tail[1] in _LOWERCASE_ALPHABET\n                    ):\n                        uncapitalize_next = False\n            characters.append(character)\n            capitalize_next = False\n        else:\n            capitalize_next = True\n            uncapitalize_next = False\n    return \"\".join(characters)\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.camel_split","title":"camel_split","text":"<pre><code>camel_split(string: str) -&gt; tuple[str, ...]\n</code></pre> <p>Split a string of camelCased words into a tuple.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; camel_split(\"theBirdsAndTheBees\")\n('the', 'Birds', 'And', 'The', 'Bees')\n\n&gt;&gt;&gt; camel_split(\"theBirdsAndTheBees123\")\n('the', 'Birds', 'And', 'The', 'Bees', '123')\n\n&gt;&gt;&gt; camel_split(\"theBirdsAndTheBeesABC123\")\n('the', 'Birds', 'And', 'The', 'Bees', 'ABC', '123')\n\n&gt;&gt;&gt; camel_split(\"the-Birds-&amp;-The-Bs-ABC--123\")\n('the', '-', 'Birds', '-&amp;-', 'The', '-', 'Bs', '-', 'ABC', '--', '123')\n\n&gt;&gt;&gt; camel_split(\"THEBirdsAndTheBees\")\n('THE', 'Birds', 'And', 'The', 'Bees')\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def camel_split(string: str) -&gt; tuple[str, ...]:\n    \"\"\"\n    Split a string of camelCased words into a tuple.\n\n    Examples:\n\n        &gt;&gt;&gt; camel_split(\"theBirdsAndTheBees\")\n        ('the', 'Birds', 'And', 'The', 'Bees')\n\n        &gt;&gt;&gt; camel_split(\"theBirdsAndTheBees123\")\n        ('the', 'Birds', 'And', 'The', 'Bees', '123')\n\n        &gt;&gt;&gt; camel_split(\"theBirdsAndTheBeesABC123\")\n        ('the', 'Birds', 'And', 'The', 'Bees', 'ABC', '123')\n\n        &gt;&gt;&gt; camel_split(\"the-Birds-&amp;-The-Bs-ABC--123\")\n        ('the', '-', 'Birds', '-&amp;-', 'The', '-', 'Bs', '-', 'ABC', '--', '123')\n\n        &gt;&gt;&gt; camel_split(\"THEBirdsAndTheBees\")\n        ('THE', 'Birds', 'And', 'The', 'Bees')\n    \"\"\"\n    words: list[list[str]] = []\n    preceding_character_type: _CharacterType | None = None\n    for character in string:\n        character_type: _CharacterType = (\n            _CharacterType.LOWERCASE\n            if character in _LOWERCASE_ALPHABET\n            else (\n                _CharacterType.DIGIT\n                if character in _DIGITS\n                else (\n                    _CharacterType.UPPERCASE\n                    if character in _UPPERCASE_ALPHABET\n                    else _CharacterType.OTHER\n                )\n            )\n        )\n        if character_type == _CharacterType.LOWERCASE:\n            if preceding_character_type == _CharacterType.LOWERCASE:\n                # If following another lowercase character, a lowercase\n                # character always continues that word\n                words[-1].append(character)\n            elif preceding_character_type == _CharacterType.UPPERCASE:\n                if len(words[-1]) &gt; 1:\n                    # When following a multi-character uppercase word,\n                    # the preceding word's last character should be removed\n                    # and a new word created from that preceding character\n                    # as well as the current lowercase character (until\n                    # followed by a lowercase character, the preceding\n                    # uppercase character was inferred to be part of an,\n                    # however now we know it was either following an acronym,\n                    # or following a single-character word)\n                    words.append([words[-1].pop(), character])\n                else:\n                    # When following an uppercase character, a lowercase\n                    # character should be added to the preceding word if that\n                    # word has only one character thus far\n                    words[-1].append(character)\n            else:\n                words.append([character])\n            preceding_character_type = _CharacterType.LOWERCASE\n        else:\n            # Any type of character besides one from the *lowercase alphabet*\n            # should start a new word if it follows a character of a\n            # different type\n            if preceding_character_type == character_type:\n                words[-1].append(character)\n            else:\n                words.append([character])\n            preceding_character_type = character_type\n    return tuple(\"\".join(word) for word in words)\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.indent","title":"indent","text":"<pre><code>indent(\n    string: str,\n    number_of_spaces: int = 4,\n    start: int = 1,\n    stop: int | None = None,\n) -&gt; str\n</code></pre> <p>Indent text by <code>number_of_spaces</code> starting at line index <code>start</code> and stopping at line index <code>stop</code>.</p> Source code in <code>sob/utilities.py</code> <pre><code>def indent(\n    string: str,\n    number_of_spaces: int = 4,\n    start: int = 1,\n    stop: int | None = None,\n) -&gt; str:\n    \"\"\"\n    Indent text by `number_of_spaces` starting at line index `start` and\n    stopping at line index `stop`.\n    \"\"\"\n    indented_text = string\n    if (\"\\n\" in string) or start == 0:\n        lines: list[str] = string.split(\"\\n\")\n        if stop:\n            if stop &lt; 0:\n                stop = len(lines) - stop\n        else:\n            stop = len(lines)\n        index: int\n        for index in range(start, stop):\n            line: str = lines[index]\n            line_indent: str = \" \" * number_of_spaces\n            lines[index] = f\"{line_indent}{line}\".rstrip()\n        indented_text = \"\\n\".join(lines)\n    return indented_text\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.get_url_relative_to","title":"get_url_relative_to","text":"<pre><code>get_url_relative_to(\n    absolute_url: str, base_url: str\n) -&gt; str\n</code></pre> <p>Returns a relative URL given an absolute URL and a base URL</p> Source code in <code>sob/utilities.py</code> <pre><code>def get_url_relative_to(absolute_url: str, base_url: str) -&gt; str:\n    \"\"\"\n    Returns a relative URL given an absolute URL and a base URL\n    \"\"\"\n    # If no portion of the absolute URL is shared with the base URL--the\n    # absolute URL will be returned\n    relative_url: str = absolute_url\n    base_url = _url_directory_and_file_name(base_url)[0]\n    if base_url:\n        relative_url = \"\"\n        # URLs are not case-sensitive\n        base_url = base_url.lower()\n        lowercase_absolute_url = absolute_url.lower()\n        while base_url and (\n            base_url.lower() != lowercase_absolute_url[: len(base_url)]\n        ):\n            relative_url = \"../\" + relative_url\n            base_url = _url_directory_and_file_name(base_url[:-1])[0]\n        base_url_length: int = len(base_url)\n        relative_url += absolute_url[base_url_length:]\n    return relative_url\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.split_long_docstring_lines","title":"split_long_docstring_lines","text":"<pre><code>split_long_docstring_lines(\n    docstring: str,\n    max_line_length: int = sob.utilities.MAX_LINE_LENGTH,\n    indent: int = 4,\n) -&gt; str\n</code></pre> <p>Split long docstring lines.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; print(\n...     split_long_docstring_lines(\n...         \"    Lorem ipsum dolor sit amet, consectetur adipiscing \"\n...         \"elit. Nullam faucibu odio a urna elementum, eu tempor \"\n...         \"nisl efficitur.\"\n...     )\n... )\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam faucibu\n    odio a urna elementum, eu tempor nisl efficitur.\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def split_long_docstring_lines(\n    docstring: str,\n    max_line_length: int = MAX_LINE_LENGTH,\n    indent: int = 4,\n) -&gt; str:\n    \"\"\"\n    Split long docstring lines.\n\n    Example:\n\n        &gt;&gt;&gt; print(\n        ...     split_long_docstring_lines(\n        ...         \"    Lorem ipsum dolor sit amet, consectetur adipiscing \"\n        ...         \"elit. Nullam faucibu odio a urna elementum, eu tempor \"\n        ...         \"nisl efficitur.\"\n        ...     )\n        ... )\n            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam faucibu\n            odio a urna elementum, eu tempor nisl efficitur.\n    \"\"\"  # noqa: E501\n    line: str\n    indent_: str = \"    \"\n    if \"\\t\" in docstring:\n        docstring = docstring.replace(\"\\t\", indent_)\n    lines: list[str] = docstring.split(\"\\n\")\n    indentation_length: int = sys.maxsize\n    for line in filter(None, lines):\n        matched = re.match(r\"^[ ]+\", line)\n        if matched:\n            indentation_length = min(indentation_length, len(matched.group()))\n        else:\n            indentation_length = 0\n            break\n    indent_ = \" \" * (indentation_length or indent)\n    if indentation_length &lt; sys.maxsize:\n        docstring = \"\\n\".join(\n            _split_long_comment_line(\n                indent_ + line[indentation_length:],\n                max_line_length,\n                prefix=\"\",\n            )\n            for line in lines\n        )\n    # Strip trailing whitespace and empty lines\n    return re.sub(r\"[ ]+(\\n|$)\", r\"\\1\", docstring)\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.suffix_long_lines","title":"suffix_long_lines","text":"<pre><code>suffix_long_lines(\n    text: str,\n    max_line_length: int = sob.utilities.MAX_LINE_LENGTH,\n    suffix: str = \"  # noqa: E501\",\n) -&gt; str\n</code></pre> <p>This function adds a suffix to the end of any line of code longer than <code>max_line_length</code>.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>Text representing python code</p> </li> <li> <code>max_line_length</code>               (<code>int</code>, default:                   <code>sob.utilities.MAX_LINE_LENGTH</code> )           \u2013            <p>The length at which a line should have the <code>suffix</code> appended. If this is a negative integer (or zero), the sum of this integer + <code>MAX_LINE_LENGTH</code> is used</p> </li> <li> <code>suffix</code>               (<code>str</code>, default:                   <code>'  # noqa: E501'</code> )           \u2013            <p>The default suffix indicates to linters that a long line should be permitted</p> </li> </ul> <p>Example:</p> <pre><code>&gt;&gt;&gt; print(\n...     suffix_long_lines(\n...         \"A short line...\\n\"\n...         \"Lorem ipsum dolor sit amet, consectetur adipiscing \"\n...         \"elit. Nullam faucibu odio a urna elementum, eu tempor \"\n...         \"nisl efficitur.\\n\"\n...         \"...another short line\"\n...     )\n... )\nA short line...\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam faucibu odio a urna elementum, eu tempor nisl efficitur.\n...another short line\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def suffix_long_lines(\n    text: str,\n    max_line_length: int = MAX_LINE_LENGTH,\n    suffix: str = \"  # noqa: E501\",\n) -&gt; str:\n    \"\"\"\n    This function adds a suffix to the end of any line of code longer than\n    `max_line_length`.\n\n    Parameters:\n        text: Text representing python code\n        max_line_length:\n            The length at which a line should have the `suffix` appended. If\n            this is a *negative* integer (or zero), the sum of this integer +\n            `MAX_LINE_LENGTH` is used\n        suffix: The default suffix indicates to linters that\n            a long line should be permitted\n\n    Example:\n\n        &gt;&gt;&gt; print(\n        ...     suffix_long_lines(\n        ...         \"A short line...\\\\n\"\n        ...         \"Lorem ipsum dolor sit amet, consectetur adipiscing \"\n        ...         \"elit. Nullam faucibu odio a urna elementum, eu tempor \"\n        ...         \"nisl efficitur.\\\\n\"\n        ...         \"...another short line\"\n        ...     )\n        ... )\n        A short line...\n        Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam faucibu odio a urna elementum, eu tempor nisl efficitur.\n        ...another short line\n\n    \"\"\"  # noqa: E501\n    return \"\\n\".join(\n        _iter_suffix_long_lines(\n            text, max_line_length=max_line_length, suffix=suffix\n        )\n    )\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.iter_properties_values","title":"iter_properties_values","text":"<pre><code>iter_properties_values(\n    object_: object, *, include_private: bool = False\n) -&gt; collections.abc.Iterable[tuple[str, typing.Any]]\n</code></pre> <p>This function iterates over an object's public (non-callable) properties, yielding a tuple comprised of each attribute/property name and value.</p> <p>Parameters:</p> <ul> <li> <code>object_</code>               (<code>object</code>)           \u2013            </li> <li> <code>include_private</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If this is <code>True</code>, private properties (those starting with an underscore) will be included in the iteration.</p> </li> </ul> Source code in <code>sob/utilities.py</code> <pre><code>def iter_properties_values(\n    object_: object, *, include_private: bool = False\n) -&gt; Iterable[tuple[str, Any]]:\n    \"\"\"\n    This function iterates over an object's public (non-callable)\n    properties, yielding a tuple comprised of each attribute/property name and\n    value.\n\n    Parameters:\n        object_:\n        include_private: If this is `True`, private properties (those\n            starting with an underscore) will be included in the iteration.\n    \"\"\"\n    names: Iterable[str] = dir(object_)\n    if not include_private:\n        names = filter(_is_public, names)\n\n    def get_name_value(name: str) -&gt; tuple[str, str] | None:\n        value: Any = getattr(object_, name, lambda: None)\n        if callable(value):\n            return None\n        return name, value\n\n    return filter(None, map(get_name_value, names))\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.get_qualified_name","title":"get_qualified_name","text":"<pre><code>get_qualified_name(\n    type_or_module: (\n        type | collections.abc.Callable | types.ModuleType\n    ),\n) -&gt; str\n</code></pre> <p>This function return the fully qualified name for a type or module.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(get_qualified_name(get_qualified_name))\nsob.utilities.get_qualified_name\n\n&gt;&gt;&gt; from sob import model\n&gt;&gt;&gt; print(get_qualified_name(model.marshal))\nsob.model.marshal\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def get_qualified_name(type_or_module: type | Callable | ModuleType) -&gt; str:\n    \"\"\"\n    This function return the fully qualified name for a type or module.\n\n    Examples:\n\n        &gt;&gt;&gt; print(get_qualified_name(get_qualified_name))\n        sob.utilities.get_qualified_name\n\n        &gt;&gt;&gt; from sob import model\n        &gt;&gt;&gt; print(get_qualified_name(model.marshal))\n        sob.model.marshal\n    \"\"\"\n    if not isinstance(type_or_module, QUALIFIED_NAME_ARGUMENT_TYPES):\n        raise TypeError(type_or_module)\n    type_name: str\n    if isinstance(type_or_module, ModuleType):\n        type_name = type_or_module.__name__\n    else:\n        type_name = getattr(\n            type_or_module,\n            \"__qualname__\",\n            getattr(type_or_module, \"__name__\", \"\"),\n        )\n        if \"&lt;\" in type_name:\n            name_part: str\n            type_name = \".\".join(\n                filter(\n                    lambda name_part: not name_part.startswith(\"&lt;\"),\n                    type_name.split(\".\"),\n                )\n            )\n        if (not type_name) and hasattr(type_or_module, \"__origin__\"):\n            # If this is a generic alias, we can use `repr`\n            # to get the qualified type name\n            type_name = repr(type_or_module)\n        if not type_name:\n            msg = (\n                \"A qualified type name could not be inferred for \"\n                f\"`{type_or_module!r}` \"\n                f\"(an instance of {type(type_or_module).__name__})\"\n            )\n            raise TypeError(msg)\n        if type_or_module.__module__ not in (\n            \"builtins\",\n            \"__builtin__\",\n            \"__main__\",\n            \"__init__\",\n        ):\n            type_name = type_or_module.__module__ + \".\" + type_name\n    return type_name\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.get_calling_module_name","title":"get_calling_module_name","text":"<pre><code>get_calling_module_name(depth: int = 1) -&gt; str\n</code></pre> <p>This function returns the name of the module from which the function which invokes this function was called.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>This defaults to <code>1</code>, indicating we want to return the name of the module wherein <code>get_calling_module_name</code> is being called. If set to <code>2</code>, it would instead indicate the module.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(get_calling_module_name())\nsob.utilities\n\n&gt;&gt;&gt; print(get_calling_module_name(2))\ndoctest\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def get_calling_module_name(depth: int = 1) -&gt; str:\n    \"\"\"\n    This function returns the name of the module from which the function\n    which invokes this function was called.\n\n    Parameters:\n        depth: This defaults to `1`, indicating we want to return the name\n            of the module wherein `get_calling_module_name` is being called.\n            If set to `2`, it would instead indicate the module.\n\n    Examples:\n\n        &gt;&gt;&gt; print(get_calling_module_name())\n        sob.utilities\n\n        &gt;&gt;&gt; print(get_calling_module_name(2))\n        doctest\n    \"\"\"\n    name: str\n    try:\n        name = sys._getframe(depth).f_globals.get(  # noqa: SLF001\n            \"__name__\", \"__main__\"\n        )\n    except (AttributeError, ValueError):\n        name = \"__main__\"\n    return name\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.get_calling_function_qualified_name","title":"get_calling_function_qualified_name","text":"<pre><code>get_calling_function_qualified_name(\n    depth: int = 1,\n) -&gt; str | None\n</code></pre> <p>Return the fully qualified name of the function from within which this is being called</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def my_function() -&gt; str:\n...     return get_calling_function_qualified_name()\n&gt;&gt;&gt; print(my_function())\nsob.utilities.my_function\n\n&gt;&gt;&gt; class MyClass:\n...     def __call__(self) -&gt; None:\n...         return self.my_method()\n...\n...     def my_method(self) -&gt; str:\n...         return get_calling_function_qualified_name()\n&gt;&gt;&gt; print(MyClass()())\nsob.utilities.MyClass.my_method\n</code></pre> Source code in <code>sob/utilities.py</code> <pre><code>def get_calling_function_qualified_name(depth: int = 1) -&gt; str | None:\n    \"\"\"\n    Return the fully qualified name of the function from within which this is\n    being called\n\n    Examples:\n\n        &gt;&gt;&gt; def my_function() -&gt; str:\n        ...     return get_calling_function_qualified_name()\n        &gt;&gt;&gt; print(my_function())\n        sob.utilities.my_function\n\n        &gt;&gt;&gt; class MyClass:\n        ...     def __call__(self) -&gt; None:\n        ...         return self.my_method()\n        ...\n        ...     def my_method(self) -&gt; str:\n        ...         return get_calling_function_qualified_name()\n        &gt;&gt;&gt; print(MyClass()())\n        sob.utilities.MyClass.my_method\n    \"\"\"\n    if not isinstance(depth, int):\n        raise TypeError(depth)\n    try:\n        stack_ = stack()\n    except IndexError:\n        return None\n    if len(stack_) &lt; (depth + 1):\n        return None\n    return \".\".join(reversed(tuple(_iter_frame_info_names(stack_[depth]))))\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.get_source","title":"get_source","text":"<pre><code>get_source(\n    object_: (\n        type | collections.abc.Callable | types.ModuleType\n    ),\n) -&gt; str\n</code></pre> <p>Get the source code which defined an object.</p> Source code in <code>sob/utilities.py</code> <pre><code>def get_source(object_: type | Callable | ModuleType) -&gt; str:\n    \"\"\"\n    Get the source code which defined an object.\n    \"\"\"\n    object_source: str = getattr(object_, \"_source\", \"\")\n    if not object_source:\n        object_source = getsource(object_)\n    return object_source\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.represent","title":"represent","text":"<pre><code>represent(value: typing.Any) -&gt; str\n</code></pre> <p>Returns a string representation of a value, formatted to minimize character width, and utilizing fully qualified class/function names (including module) where applicable.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>typing.Any</code>)           \u2013            </li> </ul> Source code in <code>sob/utilities.py</code> <pre><code>def represent(value: Any) -&gt; str:\n    \"\"\"\n    Returns a string representation of a value, formatted to minimize\n    character width, and utilizing fully qualified class/function names\n    (including module) where applicable.\n\n    Parameters:\n        value:\n    \"\"\"\n    value_representation: str\n    if isinstance(value, type):\n        value_representation = get_qualified_name(value)\n    else:\n        value_type: type = type(value)\n        if value_type is list:\n            value_representation = _repr_list(value)\n        elif value_type is tuple:\n            value_representation = _repr_tuple(value)\n        elif value_type is set:\n            value_representation = _repr_set(value)\n        elif value_type is dict:\n            value_representation = _repr_dict(value)\n        else:\n            value_representation = repr(value)\n            if (\n                value_type is str\n                and '\"' not in value_representation\n                and value_representation.startswith(\"'\")\n                and value_representation.endswith(\"'\")\n            ):\n                value_representation = f'\"{value_representation[1:-1]}\"'\n    return value_representation\n</code></pre>"},{"location":"api/sob.utilities/#sob.utilities.get_method","title":"get_method","text":"<pre><code>get_method(\n    object_instance: object,\n    method_name: str,\n    default: (\n        collections.abc.Callable\n        | sob._types.Undefined\n        | None\n    ) = sob._types.UNDEFINED,\n) -&gt; collections.abc.Callable[..., typing.Any] | None\n</code></pre> <p>This function attempts to retrieve an object's method, by name, if the method exists. If the object does not have a method with the given name, this function returns the <code>defualt</code> function (if provided), otherwise <code>None</code>.</p> <p>Parameters:</p> <ul> <li> <code>object_instance</code>               (<code>object</code>)           \u2013            </li> <li> <code>method_name</code>               (<code>str</code>)           \u2013            </li> <li> <code>default</code>               (<code>collections.abc.Callable | sob._types.Undefined | None</code>, default:                   <code>sob._types.UNDEFINED</code> )           \u2013            </li> </ul> Source code in <code>sob/utilities.py</code> <pre><code>def get_method(\n    object_instance: object,\n    method_name: str,\n    default: Callable | Undefined | None = UNDEFINED,\n) -&gt; Callable[..., Any] | None:\n    \"\"\"\n    This function attempts to retrieve an object's method, by name, if the\n    method exists. If the object does not have a method with the given name,\n    this function returns the `defualt` function (if provided), otherwise\n    `None`.\n\n    Parameters:\n        object_instance:\n        method_name:\n        default:\n    \"\"\"\n    method: Callable\n    try:\n        method = getattr(object_instance, method_name)\n    except AttributeError:\n        if isinstance(default, Undefined):\n            raise\n        return default\n    if callable(method):\n        return method\n    if isinstance(default, Undefined):\n        message: str = (\n            f\"{get_qualified_name(type(object_instance))}.{method_name} \"\n            \"is not callable.\"\n        )\n        raise AttributeError(message)  # noqa: TRY004\n    return method\n</code></pre>"},{"location":"api/sob.version/","title":"sob.version","text":""},{"location":"api/sob.version/#sob.version","title":"sob.version","text":""},{"location":"api/sob.version/#sob.version.Version","title":"Version","text":"<pre><code>Version(\n    version_string: str | None = None,\n    specification: str = \"\",\n    compatible_with: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    equals: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    exactly_equals: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    not_equals: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    less_than: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    less_than_or_equal_to: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    greater_than: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n    greater_than_or_equal_to: (\n        collections.abc.Sequence[\n            str | int | float | decimal.Decimal\n        ]\n        | None\n    ) = None,\n)\n</code></pre> <p>               Bases: <code>sob.abc.Version</code></p> <p>Instances of this class represent specification version compatibility.</p> <p>An instance of <code>sob.Version</code> can be initialized from a version string formatted similarly to python package dependency specifiers as documented in PEP-440, but instead of representing package version compatibility, it represents compatibility with a specification version.</p> <p>Attributes:</p> <ul> <li> <code>specification</code>           \u2013            <p>A specification name/identifier. This can be any string, so long as the same string is used when representing versions in property metadata as when applying the version using <code>sob.version_model</code>.</p> </li> <li> <code>compatible_with</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>~=</code> in PEP-440.</p> </li> <li> <code>equals</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>==</code> in PEP-440.</p> </li> <li> <code>exactly_equals</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>===</code> in PEP-440.</p> </li> <li> <code>not_equals</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>!=</code> in PEP-440.</p> </li> <li> <code>less_than</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&lt;</code> in PEP-440.</p> </li> <li> <code>less_than_or_equal_to</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&lt;=</code> in PEP-440.</p> </li> <li> <code>greater_than</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&gt;</code> in PEP-440.</p> </li> <li> <code>greater_than_or_equal_to</code>           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&gt;=</code> in PEP-440.</p> </li> </ul> <p>Parameters:</p> <ul> <li> <code>version_string</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A version string formatted similarly to python package dependency specifiers as documented in PEP-440.</p> </li> <li> <code>specification</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>A specification name/identifier. This can be any string, so long as the same string is used when representing versions in property metadata as when applying the version using <code>sob.version_model</code>.</p> </li> <li> <code>compatible_with</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>~=</code> in PEP-440.</p> </li> <li> <code>equals</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>==</code> in PEP-440.</p> </li> <li> <code>exactly_equals</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>===</code> in PEP-440.</p> </li> <li> <code>not_equals</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>!=</code> in PEP-440.</p> </li> <li> <code>less_than</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&lt;</code> in PEP-440.</p> </li> <li> <code>less_than_or_equal_to</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&lt;=</code> in PEP-440.</p> </li> <li> <code>greater_than</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&gt;</code> in PEP-440.</p> </li> <li> <code>greater_than_or_equal_to</code>               (<code>collections.abc.Sequence[str | int | float | decimal.Decimal] | None</code>, default:                   <code>None</code> )           \u2013            <p>A sequence of version numbers for which comparisons should be evaluated as described for <code>&gt;=</code> in PEP-440.</p> </li> </ul> Source code in <code>sob/version.py</code> <pre><code>def __init__(\n    self,\n    version_string: str | None = None,\n    specification: str = \"\",\n    compatible_with: Sequence[str | int | float | Decimal] | None = None,\n    equals: Sequence[str | int | float | Decimal] | None = None,\n    exactly_equals: Sequence[str | int | float | Decimal] | None = None,\n    not_equals: Sequence[str | int | float | Decimal] | None = None,\n    less_than: Sequence[str | int | float | Decimal] | None = None,\n    less_than_or_equal_to: Sequence[str | int | float | Decimal]\n    | None = None,\n    greater_than: Sequence[str | int | float | Decimal] | None = None,\n    greater_than_or_equal_to: Sequence[str | int | float | Decimal]\n    | None = None,\n) -&gt; None:\n    \"\"\"\n    Parameters:\n        version_string: A version string formatted similarly to python\n            package dependency specifiers as documented in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        specification: A specification name/identifier. This can be any\n            string, so long as the same string is used when representing\n            versions in property metadata as when applying the version\n            using `sob.version_model`.\n        compatible_with: A sequence of version numbers for which\n            comparisons should be evaluated as described for `~=` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        equals: A sequence of version numbers for which comparisons\n            should be evaluated as described for `==` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        exactly_equals: A sequence of version numbers for which comparisons\n            should be evaluated as described for `===` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        not_equals: A sequence of version numbers for which comparisons\n            should be evaluated as described for `!=` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        less_than: A sequence of version numbers for which comparisons\n            should be evaluated as described for `&lt;` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        less_than_or_equal_to: A sequence of version numbers for which\n            comparisons should be evaluated as described for `&lt;=` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        greater_than: A sequence of version numbers for which\n            comparisons should be evaluated as described for `&gt;` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n        greater_than_or_equal_to:  A sequence of version numbers for which\n            comparisons should be evaluated as described for `&gt;=` in\n            [PEP-440](https://www.python.org/dev/peps/pep-0440).\n    \"\"\"\n    self.specification = specification\n    self.compatible_with = compatible_with\n    self.exactly_equals = exactly_equals\n    self.equals = equals\n    self.not_equals = not_equals\n    self.less_than = less_than\n    self.less_than_or_equal_to = less_than_or_equal_to\n    self.greater_than = greater_than\n    self.greater_than_or_equal_to = greater_than_or_equal_to\n    if version_string is not None:\n        if not isinstance(version_string, str):\n            raise TypeError(version_string)\n        self._update_version_parameters_from_string(version_string)\n</code></pre>"}]}